"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[2501],{10466:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>h,default:()=>j,frontMatter:()=>d,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"general/object-pooling","title":"Object Pooling","description":"Object pooling is a design pattern (specifically: creational pattern) that you can use to optimize your projects by lowering the burden that is placed on the CPU when having to rapidly instantiate and destroy GameObjects. It is particularly useful for top-down bullethell games, or games that have swarms of monsters that are constantly created and destroyed at runtime.","source":"@site/resources/general/object-pooling.md","sourceDirName":"general","slug":"/general/object-pooling","permalink":"/50033/resources/general/object-pooling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Using Sprite Resolver With Sprite Library","permalink":"/50033/resources/general/sprite-resolver"},"next":{"title":"Data-Driven Player Stats Architecture","permalink":"/50033/resources/general/data-driven-stats"}}');var i=t(74848),a=t(28453),s=t(72206),l=t(82223),r=(t(53398),t(19894),t(88761)),c=(t(89166),t(384));const d={sidebar_position:7},h="Object Pooling",p={},m=[{value:"The Object Pooler",id:"the-object-pooler",level:2},{value:"ObjectType",id:"objecttype",level:3},{value:"ObjectPoolItem",id:"objectpoolitem",level:3},{value:"ExistingPoolItem",id:"existingpoolitem",level:3},{value:"ObjectPooler",id:"objectpooler",level:3},{value:"ItemsToPool",id:"itemstopool",level:4},{value:"Awake &amp; Initialize Pool",id:"awake--initialize-pool",level:4},{value:"GetPooledObject",id:"getpooledobject",level:4},{value:"SpawnFromPooler",id:"spawnfrompooler",level:3},{value:"IPoolable",id:"ipoolable",level:3},{value:"Returning Object to the pool",id:"returning-object-to-the-pool",level:3},{value:"Demo",id:"demo",level:2},{value:"Caveats",id:"caveats",level:2},{value:"Performance Tradeoffs",id:"performance-tradeoffs",level:3},{value:"State Leakage",id:"state-leakage",level:3},{value:"Scene Reloading Edge Cases",id:"scene-reloading-edge-cases",level:3}];function b(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"object-pooling",children:"Object Pooling"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Object pooling"})," is a design pattern (specifically: creational pattern) that you can use to optimize your projects by lowering the burden that is placed on the CPU when having to rapidly ",(0,i.jsx)(n.strong,{children:"instantiate"})," and ",(0,i.jsx)(n.strong,{children:"destroy"})," GameObjects. It is particularly useful for top-down bullethell games, or games that have swarms of monsters that are constantly created and destroyed at runtime."]})}),"\n",(0,i.jsx)(n.p,{children:"Without pooling, frequent instantiation and garbage collection can cause frame rate drops and stuttering. By keeping a pool of inactive objects ready to be activated and recycled, games reduce CPU and memory overhead, achieve smoother performance on both high-end and mobile devices, and maintain more predictable behavior during action-heavy moments."}),"\n",(0,i.jsx)(n.p,{children:"The main idea of Object Pooling is as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Instantiate ",(0,i.jsx)(n.code,{children:"N"})," objects at ",(0,i.jsx)(n.code,{children:"Awake()"}),", but render them ",(0,i.jsx)(n.strong,{children:"inactive"}),". Place all of them in a ",(0,i.jsx)(n.em,{children:"pool"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Activate each objects at runtime accordingly, instead of instantiating new ones. This action removes ",(0,i.jsx)(n.em,{children:"available"})," objects from the ",(0,i.jsx)(n.em,{children:"pool"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["After we are done with these objects, ",(0,i.jsx)("span",{class:"orange-bold",children:"deactivate"})," them. This essentially returns the object back to the ",(0,i.jsx)(n.em,{children:"pool"}),", ready to be reused next time."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.em,{children:"pool"})," may run out of objects to be activated eventually, and we can optionally ",(0,i.jsx)(n.em,{children:"expand"})," the pool at runtime. This requires instantiation of new gameObjects obviously, so try to reduce the need to do so and instantiate enough relevant game objects at ",(0,i.jsx)(n.code,{children:"Awake()"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-object-pooler",children:"The Object Pooler"}),"\n",(0,i.jsx)(n.p,{children:"The Object Pooler script is going to be attached to an empty gameobject in the Scene, and it is typically made persistent (a Singleton)."}),"\n",(0,i.jsx)(n.p,{children:"It utilises three classes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ObjectPoolItem"}),": A class to define the data structure of an Object metadata to be spawned into the pool"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ExistingPoolItem"}),": A class to define the data structure of an Object ",(0,i.jsx)(n.em,{children:"in"})," the pool"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ObjectType"}),": A SO class that serves as a concrete representation of a type of an object (as opposed to using enums or strings)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"objecttype",children:"ObjectType"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",metastring:'title="ObjectType.cs"',children:'using UnityEngine;\n\n[CreateAssetMenu(menuName = "Object Pool/Object Type")]\npublic class ObjectType : ScriptableObject\n{\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"With this, you can right click in the Project window >> Object Pool >> Object Type to create any type you want as shown below:"}),"\n",(0,i.jsx)(r.A,{path:t(98817).A,widthPercentage:"100%"}),"\n",(0,i.jsx)(n.h3,{id:"objectpoolitem",children:"ObjectPoolItem"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",metastring:'title="ObjectPoolItem.cs"',children:"[System.Serializable]\npublic class ObjectPoolItem\n{\n    public int amount;\n    public GameObject prefab;\n    public bool expandPool;\n    public ObjectType type;   // ScriptableObject reference\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This class will be used later on by the ",(0,i.jsx)(n.code,{children:"ObjectPooler"})," script to define the objects to instantiate in the pool. We can conventiently define in the inspector the characteristics of the objects to be spawned."]}),"\n",(0,i.jsx)(n.h3,{id:"existingpoolitem",children:"ExistingPoolItem"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",metastring:'title="ExistingPoolItem.cs"',children:"\npublic class ExistingPoolItem\n{\n    public GameObject gameObject;\n    public ObjectType type;\n    private Vector3 defaultScale;\n    private Quaternion defaultRotation;\n\n    public ExistingPoolItem(GameObject gameObject, ObjectType type)\n    {\n        this.gameObject = gameObject;\n        this.type = type;\n\n        defaultScale = gameObject.transform.localScale;\n        defaultRotation = gameObject.transform.localRotation;\n    }\n\n    public void ResetState()\n    {\n        // Reset transform\n        gameObject.transform.localScale = defaultScale;\n        gameObject.transform.localRotation = defaultRotation;\n\n        // Re-enable all behaviours\n        foreach (var comp in gameObject.GetComponentsInChildren<Behaviour>(true))\n        {\n            comp.enabled = true;\n        }\n\n        // Reset rigidbodies\n        foreach (var rb in gameObject.GetComponentsInChildren<Rigidbody2D>())\n        {\n            rb.linearVelocity = Vector2.zero;\n            rb.angularVelocity = 0f;\n        }\n        foreach (var rb in gameObject.GetComponentsInChildren<Rigidbody>())\n        {\n            rb.linearVelocity = Vector3.zero;\n            rb.angularVelocity = Vector3.zero;\n        }\n\n        // Script hook\n        foreach (var poolable in gameObject.GetComponentsInChildren<IPoolable>())\n        {\n            poolable.OnReused();\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is the data structure to describe ",(0,i.jsx)(n.em,{children:"each"})," instantiated object in the pool. The ",(0,i.jsx)(n.code,{children:"ObjectPooler"})," script will go through a list of ",(0,i.jsx)(n.code,{children:"ObjectPoolItem"})," and then instantiate the appropriate GameObject based on the defined prefab and quantity, then instantiate new ",(0,i.jsx)(n.code,{children:"ExistingPoolItem"})," with that detail."]}),"\n",(0,i.jsx)(n.h3,{id:"objectpooler",children:"ObjectPooler"}),"\n",(0,i.jsxs)(s.A,{children:[(0,i.jsx)(l.A,{value:"1",label:"ObjectPooler.cs",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\n\n\npublic class ObjectPooler : Singleton<ObjectPooler>\n{\n    public List<ObjectPoolItem> itemsToPool;      // types of different objects to pool\n    public List<ExistingPoolItem> pooledObjects;  // list of all pooled objects\n    private Transform sceneContainer;\n    override public void Awake()\n    {\n        base.Awake();\n        SceneManager.sceneLoaded += OnSceneLoaded; // SceneManager.sceneLoaded always fires when a scene is loaded, including the very first scene of the game\n    }\n\n    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)\n    {\n        InitializePools(); // re-run init logic for the new scene\n    }\n\n    private void InitializePool()\n    {\n        Debug.Log("[Pooler] Initializing pool");\n        CreateSceneContainer();\n        pooledObjects = new List<ExistingPoolItem>();\n        foreach (ObjectPoolItem item in itemsToPool)\n        {\n            for (int i = 0; i < item.amount; i++)\n            {\n                GameObject pickup = Instantiate(item.prefab, sceneContainer);\n                pickup.SetActive(false);\n\n                var e = new ExistingPoolItem(pickup, item.type);\n                pooledObjects.Add(e);\n\n                Debug.Log($"[Pooler] Added {pickup.name} of type {item.type.name}");\n            }\n        }\n    }\n\n\n\n    private void CreateSceneContainer()\n    {\n        GameObject container = new GameObject("PoolContainer");\n        sceneContainer = container.transform;\n    }\n\n    private GameObject GetPooledObject(ObjectType type)\n    {\n        // 1. Try to find an inactive object to reuse\n        for (int i = 0; i < pooledObjects.Count; i++)\n        {\n            var pooled = pooledObjects[i];\n            if (!pooled.gameObject.activeInHierarchy && pooled.type == type)\n            {\n                Debug.Log($"[Pooler] Reusing pooled object of type {type.name}");\n                pooled.ResetState(); //  reset when reused\n                return pooled.gameObject;\n            }\n        }\n\n        // 2. If none available, expand pool if allowed\n        foreach (ObjectPoolItem item in itemsToPool)\n        {\n            if (item.type == type && item.expandPool)\n            {\n                GameObject pickup = Instantiate(item.prefab);\n                pickup.SetActive(false);\n                pickup.transform.parent = this.transform;\n\n                var newItem = new ExistingPoolItem(pickup, item.type);\n                pooledObjects.Add(newItem);\n\n                Debug.Log($"[Pooler] Expanded pool for type {type.name}");\n                newItem.ResetState(); //  also reset when newly created\n                return pickup;\n            }\n        }\n\n        // 3. Nothing found or expandable\n        Debug.LogWarning($"[Pooler] No pooled object available for type {type.name}");\n        return null;\n    }\n\n\n    public void SpawnFromPooler(ObjectType type, Vector3 position)\n    {\n        GameObject item = GetPooledObject(type);\n        if (item != null)\n        {\n            // example random spawn\n            item.transform.position = position;\n            item.SetActive(true);\n\n            Debug.Log($"[Pooler] Spawned object of type {type.name} at {item.transform.position}");\n        }\n        else\n        {\n            Debug.LogWarning($"[Pooler] Not enough items in the pool for type {type.name}");\n        }\n    }\n}\n\n\n'})})}),(0,i.jsx)(l.A,{value:"2",label:"Singleton.cs",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"using UnityEngine;\n\npublic class Singleton<T> : MonoBehaviour where T : MonoBehaviour\n{\n    private static T _instance;\n    public static T instance\n    {\n        get\n        {\n            return _instance;\n        }\n    }\n\n    public virtual void Awake()\n    {\n\n        if (_instance == null)\n        {\n            _instance = this as T;\n            DontDestroyOnLoad(this.gameObject);\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ObjectPooler"})," inherits the ",(0,i.jsx)(n.code,{children:"Singleton"})," class, so that only one instance is created once the scene loads for as long as the Application is running."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.p,{children:"Common practice in most games:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep a persistent global singleton pooler"}),"\n",(0,i.jsxs)(n.li,{children:["Subscribe to ",(0,i.jsx)(n.code,{children:"SceneManager.sceneLoaded"})," and rebuild/extend pools if scene-specific prefabs are needed"]}),"\n",(0,i.jsx)(n.li,{children:"Pooled objects themselves don\u2019t need to know about scenes (not made singleton)"}),"\n"]})]}),"\n",(0,i.jsx)(n.h4,{id:"itemstopool",children:"ItemsToPool"}),"\n",(0,i.jsx)(n.p,{children:"This list will be exposed to the inspector and we can define what objects we want the pooler the spawn, the prefabs, and the quantity, as well as its type."}),"\n",(0,i.jsx)(r.A,{path:t(60199).A,widthPercentage:"40%"}),"\n",(0,i.jsx)(n.h4,{id:"awake--initialize-pool",children:"Awake & Initialize Pool"}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.code,{children:"Awake"}),". we immediately subscribed to ",(0,i.jsx)(n.code,{children:"OnSceneLoaded"})," method which call ",(0,i.jsx)(n.code,{children:"InitializePool"}),". This ensures that the pool is re-created when new scene is loaded, given that this instance is a Singleton."]}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.code,{children:"InitializePool"})," method, we create a SceneContainer, which is a new GameObject in the scene which will be the parent object of all spawned objects in the pool as dictated by ",(0,i.jsx)(n.code,{children:"itemsToPool"}),". We cannot make it the child of ",(0,i.jsx)(n.code,{children:"this"})," instance as it will make all the child objects persists under ",(0,i.jsx)(n.code,{children:"DontDestroyOnLoad"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Pooler singleton is marked ",(0,i.jsx)(n.code,{children:"DontDestroyOnLoad"}),", so the manager survives across scenes"]}),"\n",(0,i.jsxs)(n.li,{children:["The pooled object will be assigned as the children of ",(0,i.jsx)(n.code,{children:"SceneContainer"})," so it doesn't survive across scenes because typically we have different things to spawn then (we can change ",(0,i.jsx)(n.code,{children:"itemsToPool"})," in the ObjectPooler while prepping for scene change so it will initialize different things then)"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"getpooledobject",children:"GetPooledObject"}),"\n",(0,i.jsxs)(n.p,{children:["This private method tries to find an inactive object to reuse. If one exists, then it will call ",(0,i.jsx)(n.code,{children:"ResetState"})," method:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Defined in ",(0,i.jsx)(n.code,{children:"ExistingPoolItem"})]}),"\n",(0,i.jsx)(n.li,{children:"Does standard hardcoded behavior: reset transform scale and rotation, re-enable all components, reset rigidbodies"}),"\n",(0,i.jsxs)(n.li,{children:["Calls ",(0,i.jsx)(n.code,{children:"OnReused()"})," method implemented by ",(0,i.jsx)(n.a,{href:"#IPoolable",children:(0,i.jsx)(n.code,{children:"IPoolable"})})]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"It is important to reset the states of a pooled object before spawning them, except its transform location."})}),"\n",(0,i.jsxs)(n.p,{children:["If we run out of pool object and if ",(0,i.jsx)(n.code,{children:"expandPool"})," flag for that type is ticked, then the ObjectPooler will create new instances of that object during runtime."]}),"\n",(0,i.jsx)(n.h3,{id:"spawnfrompooler",children:"SpawnFromPooler"}),"\n",(0,i.jsx)(n.p,{children:"This is a public method that can be directly called by other script to spawn (activate) available object from the pooler. It requires the type of object (SO reference created earlier) and the location of spawning."}),"\n",(0,i.jsx)(n.h3,{id:"ipoolable",children:"IPoolable"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes we have custom setting that we need to do to the object in the pool before we spawn them. We can do this in any script ",(0,i.jsx)("span",{class:"orange-bold",children:"attached to the pooled object prefab"}),", as long as it implements IPoolable:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",metastring:'title="IPoolable.cs"',children:"\npublic interface IPoolable\n{\n    void OnReused() { }         // optional: called when pulled from pool\n}\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ExistingPoolItem"})," always calls ",(0,i.jsx)(n.code,{children:"OnReused"})," in its ",(0,i.jsx)(n.code,{children:"ResetState"})," to apply these additional logic."]}),"\n",(0,i.jsx)(n.h3,{id:"returning-object-to-the-pool",children:"Returning Object to the pool"}),"\n",(0,i.jsxs)(n.p,{children:["There's ",(0,i.jsx)("span",{class:"orange-bold",children:"no"}),' method to "return" the object to the pool. We simply ',(0,i.jsx)(n.em,{children:"deactivate"})," the object using the following to effectively tell the ",(0,i.jsx)(n.code,{children:"ObjectPooler"})," that this item is available to be reused:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"    gameObject.SetActive(false);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"demo",children:"Demo"}),"\n",(0,i.jsx)(n.p,{children:"Attach the ObjectPooler script to a gameobject, and set up the initial values like so:"}),"\n",(0,i.jsx)(r.A,{path:t(74280).A,widthPercentage:"100%"}),"\n",(0,i.jsx)(n.p,{children:"To test, we can create an object spawner script as such:"}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["It relies on custom InspectorButton attribute so that we can conveniently call the function via a button on the inspector. Read this ",(0,i.jsx)(n.a,{href:"/resources/general/helper-buttons#generic-debut-button-generator-editor-script",children:"guide"})," to find out more."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",metastring:'title="ObjectSpawner.cs"',children:'using System.Collections.Generic;\nusing UnityEngine;\nusing Game.DebugTools;\n\n// Spawner: decides what to spawn and where. It should never care about internal prefab state.\npublic class ObjectSpawner : MonoBehaviour\n{\n    public Camera cam;                  // assign main camera in Inspector (or get in Awake)\n    [Header("Put all kinds of types to spawn automatically when Space key is pressed")]\n    public List<ObjectType> spawnTypes; // drag Enemy.asset, Bullet.asset, etc. here\n    [Header("Pick the type you want to spawn in the Inspector")]\n    public ObjectType typeToSpawn;  // drag Enemy.asset, Bullet.asset, etc.\n    void Awake()\n    {\n        if (cam == null) cam = Camera.main;\n    }\n\n    void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            // 1. Pick a random type\n            ObjectType randomType = spawnTypes[Random.Range(0, spawnTypes.Count)];\n\n            // 2. Pick a random position inside camera bounds\n            Vector3 pos = GetRandomScreenPosition();\n\n            // 3. Spawn using ObjectPooler\n            ObjectPooler.instance.SpawnFromPooler(randomType, pos);\n        }\n    }\n\n    private Vector3 GetRandomScreenPosition()\n    {\n        float height = cam.orthographicSize * 2f;\n        float width = height * cam.aspect;\n\n        float x = Random.Range(-width / 2f, width / 2f);\n        float y = Random.Range(-height / 2f, height / 2f);\n\n        return new Vector3(x, y, 0f);\n    }\n\n    [InspectorButton]\n    public void SpawnFromInspectorType()\n    {\n        Vector3 pos = GetRandomScreenPosition();\n        ObjectPooler.instance.SpawnFromPooler(typeToSpawn, pos);\n    }\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"Then simply attach it to any gameobject:"}),"\n",(0,i.jsx)(r.A,{path:t(44351).A,widthPercentage:"100%"}),"\n",(0,i.jsxs)(n.p,{children:["We wrote a simple floating behavior of the objects in the pool when spawned, where it implements the ",(0,i.jsx)(n.code,{children:"IPoolable"})," interface. This way we can write our object-specific logic before it's reactivated from the pool:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",metastring:'title="FloatingEffect.cs"',children:'using UnityEngine;\n\npublic class FloatingEffect : MonoBehaviour, IPoolable\n{\n    [Header("Floating Settings")]\n    public float floatAmplitude = 0.5f;   // vertical float height\n    public float floatFrequency = 1f;     // vertical float speed\n\n    [Header("Drift Settings")]\n    public float driftRadius = 0.5f;      // horizontal drift distance\n    public float driftSpeed = 0.5f;       // drift speed\n\n    [Header("Lifetime Settings")]\n    public float lifetime = 5f;           // total lifetime before disabling\n    public float shrinkDuration = 0.5f;   // time spent shrinking before disable\n\n    private Vector3 startPos;\n    private float randomOffset;\n    private Camera mainCam;\n    private float disableTime;\n\n    private bool isShrinking = false;\n    private Vector3 originalScale;\n\n    void OnEnable()\n    {\n        mainCam = Camera.main;\n        startPos = transform.position;\n        randomOffset = Random.Range(0f, 100f);\n\n        originalScale = transform.localScale;\n        transform.localScale = originalScale; // reset size\n\n        disableTime = Time.time + lifetime;\n        isShrinking = false;\n    }\n\n    void Update()\n    {\n        if (mainCam == null) return;\n\n        // Floating up/down\n        float yOffset = Mathf.Sin((Time.time + randomOffset) * floatFrequency) * floatAmplitude;\n\n        // Smooth drift in XY\n        float xOffset = (Mathf.PerlinNoise((Time.time + randomOffset) * driftSpeed, 0f) - 0.5f) * 2f * driftRadius;\n        float yDrift = (Mathf.PerlinNoise(0f, (Time.time + randomOffset) * driftSpeed) - 0.5f) * 2f * driftRadius;\n\n        Vector3 newPos = startPos + new Vector3(xOffset, yOffset + yDrift, 0f);\n\n        // Clamp inside viewport\n        Vector3 viewportPos = mainCam.WorldToViewportPoint(newPos);\n        viewportPos.x = Mathf.Clamp01(viewportPos.x);\n        viewportPos.y = Mathf.Clamp01(viewportPos.y);\n        newPos = mainCam.ViewportToWorldPoint(viewportPos);\n\n        transform.position = newPos;\n\n        // Shrink before disabling\n        if (!isShrinking && Time.time >= disableTime - shrinkDuration)\n        {\n            isShrinking = true;\n            StartCoroutine(ShrinkAndDisable());\n        }\n    }\n\n    private System.Collections.IEnumerator ShrinkAndDisable()\n    {\n        Vector3 startScale = transform.localScale;\n        float t = 0f;\n\n        while (t < shrinkDuration)\n        {\n            t += Time.deltaTime;\n            float lerp = Mathf.Clamp01(t / shrinkDuration);\n            transform.localScale = Vector3.Lerp(startScale, Vector3.zero, lerp);\n            yield return null;\n        }\n\n        gameObject.SetActive(false);\n\n\n    }\n\n    // Called by pool when reused\n    public void OnReused()\n    {\n        transform.localScale = originalScale;\n        isShrinking = false;\n    }\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"The result of the whole object pooler setup is as follows:"}),"\n",(0,i.jsx)(c.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/object-pooler.mp4",widthPercentage:"100%"}),"\n",(0,i.jsx)(n.p,{children:"Observation:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Objects are spawned at runtime and never destroyed, only deactivated"}),"\n",(0,i.jsxs)(n.li,{children:['Inactive objects are seen as "ready" items in the pool, there\'s ',(0,i.jsx)("span",{class:"orange-bold",children:"no need"}),' to explicitly write a method to "return" object into the pool']}),"\n",(0,i.jsxs)(n.li,{children:["The ObjectPooler is a Singleton, but the objects in the pools are not (they're children of the ",(0,i.jsx)(n.code,{children:"Container"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["You can implement the reuse logic on the object itself as long as you attach a MonoBehaviour script that implements ",(0,i.jsx)(n.code,{children:"IPoolable"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"caveats",children:"Caveats"}),"\n",(0,i.jsx)(n.h3,{id:"performance-tradeoffs",children:"Performance Tradeoffs"}),"\n",(0,i.jsxs)(n.p,{children:["The purpose of object pooling is to improve performance, but if we preload a very large number of objects (thousands) at ",(0,i.jsx)(n.code,{children:"Awake()"}),", the startup time and memory footprint can spike. For example, hundreds of bullets, particles, or enemies all created up front may cause a noticeable hitch on low-end devices."]}),"\n",(0,i.jsx)(n.h3,{id:"state-leakage",children:"State Leakage"}),"\n",(0,i.jsxs)(n.p,{children:["Resetting pooled objects is tricky. We've handled scale, rotation, rigidbodies, and custom ",(0,i.jsx)(n.code,{children:"IPoolable.OnReused"}),", but pooled objects may still carry ",(0,i.jsx)(n.strong,{children:"hidden"})," state (e.g., animations mid-clip, timers, NavMeshAgent state, static variables). If reset logic misses something, you get inconsistent behavior that only appears after reuse."]}),"\n",(0,i.jsx)(n.h3,{id:"scene-reloading-edge-cases",children:"Scene Reloading Edge Cases"}),"\n",(0,i.jsxs)(n.p,{children:["We're subscribing to ",(0,i.jsx)(n.code,{children:"SceneManager.sceneLoaded"})," to re-initialize pools. However, if ",(0,i.jsx)(n.code,{children:"itemsToPool"})," is not updated before scene load, the pool may rebuild with the wrong prefab set or wipe existing objects unexpectedly."]}),"\n",(0,i.jsxs)(n.p,{children:["Also, pooled objects under the ",(0,i.jsx)(n.code,{children:"SceneContainer"})," won\u2019t persist because that\u2019s what we wanted. This is ",(0,i.jsx)("span",{class:"red-bold",children:"not suitable"})," for persistent projectiles or effects across scenes."]})]})}function j(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}},98817:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/2025-10-02-10-51-45-e854637d11f6557a1ef80d8e5a470f27.png"},60199:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/2025-10-03-09-19-20-824eafc9d3f834af32411efd4c7bad48.png"},74280:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/2025-10-03-15-21-12-6837cd27b3763b68cce8c930501dd653.png"},44351:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/2025-10-03-15-28-16-45eab98413f2a3d82550f0950b52675b.png"}}]);