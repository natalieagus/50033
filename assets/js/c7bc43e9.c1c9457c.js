"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[8221],{45965:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>g,frontMatter:()=>c,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"general/combo","title":"Combo System","description":"Modern action games use combo systems to transform simple button presses into expressive and skillful combat sequences. These systems define how attacks connect, how player inputs are interpreted, and how timing affects responsiveness. Over the years, developers have explored many different philosophies for designing combos, each shaping the rhythm and style of combat in distinctive ways.","source":"@site/resources/general/combo.md","sourceDirName":"general","slug":"/general/combo","permalink":"/50033/resources/general/combo","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Data-Driven Player Stats Architecture","permalink":"/50033/resources/general/data-driven-stats"}}');var s=i(74848),o=i(28453),r=(i(72206),i(82223),i(53398),i(19894),i(88761)),a=(i(89166),i(384));const c={sidebar_position:9},l="Combo System",d={},h=[{value:"Prerequisite",id:"prerequisite",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"High Level Class Composition",id:"high-level-class-composition",level:3},{value:"Sample Combat Moveset and Combo",id:"sample-combat-moveset-and-combo",level:3},{value:"FireSlash Combo Chain",id:"fireslash-combo-chain",level:4},{value:"IceSlash Combo Chain",id:"iceslash-combo-chain",level:4},{value:"GroundSlam Combo Chain",id:"groundslam-combo-chain",level:4},{value:"Single Tap (Fallback Chain)",id:"single-tap-fallback-chain",level:4},{value:"The Big Picture: Resolving and Executing Combos",id:"the-big-picture-resolving-and-executing-combos",level:3},{value:"Step 1: Player Input",id:"step-1-player-input",level:4},{value:"Step 2: Combo Resolution",id:"step-2-combo-resolution",level:4},{value:"Step 3: Execution",id:"step-3-execution",level:4},{value:"Step 4: Combo Timing Control",id:"step-4-combo-timing-control",level:4},{value:"Step 5: State Update",id:"step-5-state-update",level:4},{value:"Step 6: Finisher Check",id:"step-6-finisher-check",level:4},{value:"Step 7: Return to Idle",id:"step-7-return-to-idle",level:4},{value:"Timing Example",id:"timing-example",level:3},{value:"1. Anatomy of a Combo Step",id:"1-anatomy-of-a-combo-step",level:4},{value:"2. Animation Length vs Combo Window",id:"2-animation-length-vs-combo-window",level:4},{value:"3. Example Timeline: <code>Light 1</code> \u2192 <code>Light 2</code> \u2192 <code>Light 3</code> (\u201cIceSlash\u201d)",id:"3-example-timeline-light-1--light-2--light-3-iceslash",level:4},{value:"4. Multiple Active Chains &amp; \u201cLongest Match\u201d vs \u201cCompleted\u201d",id:"4-multiple-active-chains--longest-match-vs-completed",level:4},{value:"5. Finisher Timing",id:"5-finisher-timing",level:4},{value:"6. Visual Recap",id:"6-visual-recap",level:4},{value:"System Composition and Code Structure",id:"system-composition-and-code-structure",level:2},{value:"Foundation Layer: Data &amp; Stateless Components",id:"foundation-layer-data--stateless-components",level:2},{value:"<code>AttackType.cs</code>",id:"attacktypecs",level:3},{value:"<code>AttackData.cs</code>",id:"attackdatacs",level:3},{value:"<code>ComboStep.cs</code>",id:"combostepcs",level:3},{value:"<code>ComboChain.cs</code>",id:"combochaincs",level:3},{value:"<code>CombatConfig.cs</code>",id:"combatconfigcs",level:3},{value:"<code>PlayerStats.cs</code>",id:"playerstatscs",level:3},{value:"<code>CooldownManager.cs</code>",id:"cooldownmanagercs",level:3},{value:"<code>ComboTiming.cs</code>",id:"combotimingcs",level:3},{value:"<code>ActiveCombo.cs</code>",id:"activecombocs",level:3},{value:"State Layer",id:"state-layer",level:2},{value:"<code>ComboState.cs</code>",id:"combostatecs",level:3},{value:"<code>ComboTiming</code>",id:"combotiming",level:3},{value:"Logic Layer",id:"logic-layer",level:2},{value:"<code>ComboResolver.cs</code>",id:"comboresolvercs",level:3},{value:"<code>ComboExecutor.cs</code>",id:"comboexecutorcs",level:3},{value:"<code>FinisherEvaluator.cs</code>",id:"finisherevaluatorcs",level:4},{value:"Runtime Layer: The Orchestrator <code>ComboManager</code>",id:"runtime-layer-the-orchestrator-combomanager",level:2},{value:"<code>ComboManager.cs</code>",id:"combomanagercs",level:4},{value:"Unpacking the Manager",id:"unpacking-the-manager",level:3},{value:"Collaborators (composition)",id:"collaborators-composition",level:4},{value:"Lifecycle &amp; wiring",id:"lifecycle--wiring",level:4},{value:"Input path (no attack in progress)",id:"input-path-no-attack-in-progress",level:4},{value:"Execution path",id:"execution-path",level:4},{value:"Timing loop (combo window open/close)",id:"timing-loop-combo-window-openclose",level:4},{value:"Finisher gate",id:"finisher-gate",level:4},{value:"Clip completion &amp; queued input",id:"clip-completion--queued-input",level:4},{value:"Hit confirmation (optional)",id:"hit-confirmation-optional",level:4},{value:"Cooldowns &amp; stamina gates",id:"cooldowns--stamina-gates",level:4},{value:"Reset utilities",id:"reset-utilities",level:4},{value:"Runtime Responsibilities",id:"runtime-responsibilities",level:3},{value:"Using <code>ComboManager</code>",id:"using-combomanager",level:2},{value:"Public Interface",id:"public-interface",level:3},{value:"Sequence Diagram: Player Input to Finisher",id:"sequence-diagram-player-input-to-finisher",level:3},{value:"Summary",id:"summary",level:3},{value:"Runtime Examples",id:"runtime-examples",level:2},{value:"Runtime Timeline A: <em>\u201cIceSlash Cancelled, FireSlash Finisher Triggered\u201d</em>",id:"runtime-timeline-a-iceslash-cancelled-fireslash-finisher-triggered",level:3},{value:"Scenario",id:"scenario",level:4},{value:"Runtime Timeline B: <em>\u201cIceSlash Completed, GroundSlam Finisher Triggered, FireSlash Finisher Cancelled\u201d</em>",id:"runtime-timeline-b-iceslash-completed-groundslam-finisher-triggered-fireslash-finisher-cancelled",level:3},{value:"Scenario",id:"scenario-1",level:4},{value:"Preparing the Animation Clip and Setting up the Animator FSM",id:"preparing-the-animation-clip-and-setting-up-the-animator-fsm",level:2},{value:"Step 1: Create clips for all combat movement step and special finisher animation",id:"step-1-create-clips-for-all-combat-movement-step-and-special-finisher-animation",level:3},{value:"Step 2: Create Animator FSM",id:"step-2-create-animator-fsm",level:3},{value:"Trigger",id:"trigger",level:4},{value:"Demo",id:"demo",level:2},{value:"Basic Single Tap (no combo)",id:"basic-single-tap-no-combo",level:3},{value:"FireSlash",id:"fireslash",level:3},{value:"IceSlash",id:"iceslash",level:3},{value:"Failed IceSlash",id:"failed-iceslash",level:3},{value:"GroundSlam",id:"groundslam",level:3}];function m(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"combo-system",children:"Combo System"})}),"\n",(0,s.jsxs)(n.p,{children:["Modern action games use combo systems to transform simple button presses into expressive and skillful combat sequences. These systems define how attacks ",(0,s.jsx)(n.strong,{children:"connect"}),", how player inputs are interpreted, and how timing affects ",(0,s.jsx)(n.strong,{children:"responsiveness"}),". Over the years, developers have explored many different philosophies for designing combos, each shaping the rhythm and style of combat in distinctive ways."]}),"\n",(0,s.jsxs)(n.p,{children:["In games like ",(0,s.jsx)(n.em,{children:"God of War"})," or ",(0,s.jsx)(n.em,{children:"Nier: Automata"}),", combos are typically built around a ",(0,s.jsx)("span",{class:"orange-bold",children:"chain"}),"-based structure. Each button press leads naturally to the next animation, forming a rhythmic sequence that feels powerful and cinematic. These systems prioritize accessibility and flow. The player doesn\u2019t need to memorize complex inputs, only to sense the right timing. In contrast, games such as ",(0,s.jsx)(n.em,{children:"Devil May Cry"})," or ",(0,s.jsx)(n.em,{children:"Bayonetta"})," elevate player expression by allowing ",(0,s.jsx)("span",{class:"orange-bold",children:"cancels and branching"})," patterns. Attacks can be interrupted mid-animation or chained into other moves depending on frame timing, producing a fluid, improvisational style that rewards mechanical mastery."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Competitive"})," fighting games like ",(0,s.jsx)(n.em,{children:"Street Fighter"})," or ",(0,s.jsx)(n.em,{children:"Tekken"})," take a different approach: combos there are ",(0,s.jsx)("span",{class:"orange-bold",children:"input-pattern-driven"}),". The focus is on precision and memorization, where every motion and button press sequence must be executed with near-perfect timing ",(0,s.jsx)(n.strong,{children:"to link attacks successfully"}),". Meanwhile, tactical action titles like ",(0,s.jsx)(n.em,{children:"Monster Hunter"})," or ",(0,s.jsx)(n.em,{children:"Nioh"})," integrate stance-based or weapon-specific combos, where each weapon has its own rules and timing rhythm. In these games, combos are ",(0,s.jsx)(n.em,{children:"slower"})," but highly deliberate. Success depends on managing stamina, distance, and commitment."]}),"\n",(0,s.jsx)(n.p,{children:"The combo system implemented here takes inspiration from several of these design philosophies."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Structurally, it resembles ",(0,s.jsx)(n.em,{children:"God of War"}),"\u2019s readable ",(0,s.jsx)(n.strong,{children:"chain-based approach"}),", but internally, it is built to support ",(0,s.jsx)(n.strong,{children:"flexible branching and timing rules"})," more akin to ",(0,s.jsx)(n.em,{children:"Bayonetta"})," or ",(0,s.jsx)(n.em,{children:"Devil May Cry"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["It is ",(0,s.jsx)(n.strong,{children:"data-driven"}),", meaning designers define attacks, chains, and timings entirely through ",(0,s.jsx)(n.code,{children:"ScriptableObjects"})," rather than code.\nThe system dynamically interprets player input in real time, matching button sequences against a library of combo patterns and deciding whether to start a new chain, advance an existing one, or trigger a finisher."]}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{title:"The System's Philosophy",type:"note",children:[(0,s.jsxs)(n.p,{children:["This proposed approach creates a clear separation between ",(0,s.jsx)(n.strong,{children:"data"})," and ",(0,s.jsx)(n.strong,{children:"logic"}),"."]}),(0,s.jsx)(n.p,{children:"Each combo is a piece of data: a configuration of steps, windows, and animation triggers\u2014while the runtime system handles resolution, timing, and feedback. The result is a modular and scalable design where new weapons or fighting styles can be added without modifying code, only by creating new data assets. In practice, this allows the same engine to support everything from a simple three-hit sword combo to a complex branching martial arts system."})]}),"\n",(0,s.jsx)(n.h3,{id:"prerequisite",children:"Prerequisite"}),"\n",(0,s.jsxs)(n.p,{children:["This system relies on ",(0,s.jsx)(n.a,{href:"/resources/general/data-driven-stats",children:"Data-Driven Player Stats architecture"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsxs)(n.p,{children:["A combo system may appear simple: \u201cpress attack three times to chain hits\u201d but under the hood, it\u2019s an intricate network of ",(0,s.jsx)(n.em,{children:"timing"}),", ",(0,s.jsx)(n.em,{children:"state"}),", and data ",(0,s.jsx)(n.em,{children:"interpretation"}),". The architecture here separates those concerns cleanly so that combat logic remains readable, extensible, and designer-friendly (can be tuned to improve feel via inspector without touching code)."]}),"\n",(0,s.jsx)(n.p,{children:"At its core, this system follows a three-layer architecture:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Layer"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Example Classes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Data Layer"})}),(0,s.jsx)(n.td,{children:"Stores designer-defined information about attacks, stamina, and combo sequences."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"AttackData"}),", ",(0,s.jsx)(n.code,{children:"ComboStep"}),", ",(0,s.jsx)(n.code,{children:"ComboChain"}),", ",(0,s.jsx)(n.code,{children:"CombatConfig"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Runtime Layer"})}),(0,s.jsx)(n.td,{children:"Handles moment-to-moment logic: input processing, timing, animation, and execution."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboManager"}),", ",(0,s.jsx)(n.code,{children:"ComboExecutor"}),", ",(0,s.jsx)(n.code,{children:"ComboResolver"}),", ",(0,s.jsx)(n.code,{children:"CooldownManager"}),", ",(0,s.jsx)(n.code,{children:"FinisherEvaluator"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"State Layer"})}),(0,s.jsx)(n.td,{children:"Tracks what\u2019s currently happening such as active combos, queued attacks, current timing windows."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboState"}),", ",(0,s.jsx)(n.code,{children:"ComboTiming"}),", ",(0,s.jsx)(n.code,{children:"ActiveCombo"})]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Each layer interacts through well-defined data boundaries. The runtime ",(0,s.jsx)("span",{class:"orange-bold",children:"never"})," directly ",(0,s.jsx)("span",{class:"orange-bold",children:"hardcodes"})," what an attack does; it merely reads from the data layer and updates the state layer accordingly. This makes the entire combat system data-driven, testable, and non-destructive. We can iterate on weapon design without recompiling code."]}),"\n",(0,s.jsx)(n.h3,{id:"high-level-class-composition",children:"High Level Class Composition"}),"\n",(0,s.jsx)(n.mermaid,{value:"classDiagram\n  %% === DATA LAYER ===\n  class AttackType {\n    <<enum>>\n  }\n\n  class AttackData {\n    <<ScriptableObject>>\n    +attackType : AttackType\n    +staminaCost : float\n    +cooldown : float\n    +animationTrigger : string\n    +comboWindowStart : float\n    +comboWindowEnd : float\n    +outcomeTrigger : string\n  }\n\n  class ComboStep {\n    +attackType : AttackType\n    +attackData : AttackData\n  }\n\n  class ComboChain {\n    <<ScriptableObject>>\n    +chainName : string\n    +steps : List~ComboStep~\n    +requiresAllHits : bool\n  }\n\n  class CombatConfig {\n    <<ScriptableObject>>\n    +comboChains : List~ComboChain~\n    +runtimeStats : PlayerStats\n  }\n\n  class PlayerStats {\n    +currentStamina : float\n    +maxStamina : float\n    +TickRegen()\n    +ConsumeStamina()\n  }\n\n  %% === STATE LAYER ===\n  class ComboTiming {\n    +openTime : float\n    +closeTime : float\n    +comboWindowOpen : bool\n    +ShouldOpenWindow() bool\n    +ShouldCloseWindow() bool\n  }\n\n  class ActiveCombo {\n    +chain : ComboChain\n    +currentIndex : int\n    +hasCompletedAllSteps : bool\n    +AllStepsHit() bool\n  }\n\n  class ComboState {\n    +activeCombos : List~ActiveCombo~\n    +inputHistory : List~AttackType~\n    +pendingFinisher : ActiveCombo\n  }\n\n  %% === RUNTIME LAYER ===\n  class ComboResolver {\n    +Resolve(List~ActiveCombo~, AttackType) List~ActiveCombo~\n    +SelectBest(List~ActiveCombo~) ActiveCombo\n  }\n\n  class ComboExecutor {\n    +ExecuteStep(ActiveCombo)\n  }\n\n  class FinisherEvaluator {\n    +TryFinishForChain(ActiveCombo)\n  }\n\n  class CooldownManager {\n    +Tick(float deltaTime)\n    +StartCooldown(AttackType, float duration)\n    +IsOnCooldown(AttackType) bool\n  }\n\n  class ComboManager {\n    -resolver : ComboResolver\n    -executor : ComboExecutor\n    -finisher : FinisherEvaluator\n    -cooldowns : CooldownManager\n    -comboState : ComboState\n    -timing : ComboTiming\n    -runtimeStats : PlayerStats\n    +HandleAttackInput(AttackType)\n    +HandleComboWindowTiming()\n    +ExecuteStep(ActiveCombo)\n    +CloseComboWindow()\n    +ResetAll()\n  }\n\n  %% === RELATIONSHIPS ===\n  ComboManager --\x3e ComboResolver\n  ComboManager --\x3e ComboExecutor\n  ComboManager --\x3e FinisherEvaluator\n  ComboManager --\x3e CooldownManager\n  ComboManager --\x3e ComboState\n  ComboManager --\x3e ComboTiming\n  ComboManager --\x3e PlayerStats\n\n  ComboResolver --\x3e ComboChain\n  ComboExecutor --\x3e AttackData\n  FinisherEvaluator --\x3e ComboChain\n  ActiveCombo --\x3e ComboChain\n  ComboChain --\x3e ComboStep\n  ComboStep --\x3e AttackData\n  CombatConfig --\x3e ComboChain\n  CombatConfig --\x3e PlayerStats\n"}),"\n",(0,s.jsx)(n.p,{children:"Design Intent:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No subclassing"}),": None of these types inherit from one another. Each one represents a distinct role in the combat pipeline."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single-responsibility"}),": Each class owns a single concept, such as resolution, execution, timing, etc. This means you can test them individually or replace implementations (e.g. swap ComboResolver for one that supports branching)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Runtime composition"}),": The ",(0,s.jsx)(n.code,{children:"ComboManager"})," instantiates and wires all of them. It doesn\u2019t override behavior through inheritance; it ",(0,s.jsx)("span",{class:"orange-bold",children:"delegates"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It has the following composition hierarchy:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Layer"}),(0,s.jsx)(n.th,{children:"Owned By"}),(0,s.jsx)(n.th,{children:"Example Responsibilities"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Data"})}),(0,s.jsx)(n.td,{children:"Asset (ScriptableObject)"}),(0,s.jsx)(n.td,{children:"Defines what attacks exist, how long windows last, stamina costs, animation triggers."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"State"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboManager"})," instance"]}),(0,s.jsx)(n.td,{children:"Tracks what is happening right now \u2014 active combos, pending finishers, timing."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Runtime"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboManager"})," composition"]}),(0,s.jsx)(n.td,{children:"Executes logic, updates state, reads data, and signals animations."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"sample-combat-moveset-and-combo",children:"Sample Combat Moveset and Combo"}),"\n",(0,s.jsxs)(n.p,{children:["In order to understand how things work in an abstract level, we need to use an example. Assume we have these clips and their ",(0,s.jsx)(n.code,{children:"AttackType"})," values:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Clip Name"}),(0,s.jsx)(n.th,{children:"Attack Type (key specific)"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Sword_Light1"})," (basic)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:"First fast horizontal slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Sword_Light2"})," (basic)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light2"})}),(0,s.jsx)(n.td,{children:"Second faster returning slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Sword_Light3"})," (basic)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light3"})}),(0,s.jsx)(n.td,{children:"Third downward secondary slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Sword_Light3_Ice"})," (special)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light3"})}),(0,s.jsx)(n.td,{children:"Downward secondary slash with Ice effect"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Sword_Heavy1"})," (basic)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Heavy"})}),(0,s.jsx)(n.td,{children:"A slower, stamina-heavy overhead strike"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FireSlash_Finisher"})}),(0,s.jsx)(n.td,{children:"--"}),(0,s.jsx)(n.td,{children:"Finisher animation for FireSlash Combo"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"GroundSlam_Finisher"})}),(0,s.jsx)(n.td,{children:"--"}),(0,s.jsx)(n.td,{children:"Finisher animation for Groundslam Combo"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Then, suppose we have these combo chains (the clips played are the basic ones unless otherwise stated):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FireSlash"}),": ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"})," (has finisher, hits not required)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IceSlash"}),": ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light3"})," (no finisher)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GroundSlam"}),": ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light3"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light1"})," (has finisher, all hits required)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single tap"}),": Any one-step opener (e.g., just ",(0,s.jsx)(n.code,{children:"Light1"}),") should also perform a valid attack (basic clip)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A combo sequence can look as simple as pressing a few buttons in rhythm but internally each press moves through a strict orchestration of logic, timing, and state updates."}),"\n",(0,s.jsxs)(n.p,{children:["Since certain key press like ",(0,s.jsx)(n.code,{children:"Light3"})," in different chains might trigger different clips, we need to decompose the chains into Combo Steps (not just key presses)"]}),"\n",(0,s.jsx)(n.h4,{id:"fireslash-combo-chain",children:"FireSlash Combo Chain"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," A short, 2-step chain that always triggers its finisher.\n",(0,s.jsx)(n.strong,{children:"Rule:"})," Finisher plays automatically after the second step; intermediate hits not required."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Step"}),(0,s.jsx)(n.th,{children:"Attack Type"}),(0,s.jsx)(n.th,{children:"Clip Played"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light1"})}),(0,s.jsx)(n.td,{children:"Opener horizontal slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light2"})}),(0,s.jsx)(n.td,{children:"Returning slash; triggers Fire finisher"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"F"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.em,{children:"(auto)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FireSlash_Finisher"})}),(0,s.jsx)(n.td,{children:"Finisher animation after step 2"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"iceslash-combo-chain",children:"IceSlash Combo Chain"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," A 3-step sequence ending with an ice-enhanced downward strike.\n",(0,s.jsx)(n.strong,{children:"Rule:"})," No finisher; each hit must connect to progress."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Step"}),(0,s.jsx)(n.th,{children:"Attack Type"}),(0,s.jsx)(n.th,{children:"Clip Played"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light1"})}),(0,s.jsx)(n.td,{children:"Basic horizontal opener"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light2"})}),(0,s.jsx)(n.td,{children:"Follow-up returning slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light3"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light3_Ice"})}),(0,s.jsx)(n.td,{children:"Downward ice effect strike (variant of Light3)"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h4,{id:"groundslam-combo-chain",children:"GroundSlam Combo Chain"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," A demanding 5-step chain with all hits required; ends in a heavy slam finisher.\n",(0,s.jsx)(n.strong,{children:"Rule:"})," Finisher only triggers if every hit connects."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Step"}),(0,s.jsx)(n.th,{children:"Attack Type"}),(0,s.jsx)(n.th,{children:"Clip Played"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light1"})}),(0,s.jsx)(n.td,{children:"Horizontal opener"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light1"})}),(0,s.jsx)(n.td,{children:"Repeated opening slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light2"})}),(0,s.jsx)(n.td,{children:"Mid combo returning slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light3"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light3"})}),(0,s.jsx)(n.td,{children:"Downward secondary slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light1"})}),(0,s.jsx)(n.td,{children:"Final connecting slash before finisher"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"F"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.em,{children:"(auto)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"GroundSlam_Finisher"})}),(0,s.jsx)(n.td,{children:"Finisher only if all 5 hits succeeded"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"single-tap-fallback-chain",children:"Single Tap (Fallback Chain)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," Default chain for any isolated key press.\n",(0,s.jsx)(n.strong,{children:"Rule:"})," A single-step combo that always resolves successfully the moment that Attack Type key is pressed."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Step"}),(0,s.jsx)(n.th,{children:"Attack Type"}),(0,s.jsx)(n.th,{children:"Clip Played"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1a"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light1"})}),(0,s.jsx)(n.td,{children:"Basic slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1b"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light2"})}),(0,s.jsx)(n.td,{children:"Optional single second slash variant"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1c"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Heavy"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Heavy1"})}),(0,s.jsx)(n.td,{children:"Heavy strike variant"})]})]})]}),"\n",(0,s.jsx)(n.admonition,{title:"Combo Step and Combo Chain",type:"note",children:(0,s.jsx)(n.p,{children:"A Combo Step defines the attack data: clip to play, key press to trigger, and combo window. A Combo Chain is made of several combo steps in succession."})}),"\n",(0,s.jsx)(n.h3,{id:"the-big-picture-resolving-and-executing-combos",children:"The Big Picture: Resolving and Executing Combos"}),"\n",(0,s.jsx)(n.h4,{id:"step-1-player-input",children:"Step 1: Player Input"}),"\n",(0,s.jsxs)(n.p,{children:["A button press (",(0,s.jsx)(n.code,{children:"Light1"}),", ",(0,s.jsx)(n.code,{children:"Heavy"}),", etc.) is captured and passed to ",(0,s.jsx)(n.code,{children:"ComboManager"}),".\nInput is read using ",(0,s.jsx)(n.a,{href:"/docs/toddlers/management",children:"Unity\u2019s Input System"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"step-2-combo-resolution",children:"Step 2: Combo Resolution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ComboResolver"})," checks ",(0,s.jsx)(n.em,{children:"all"})," known combo chains and decides whether this input:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Starts"})," a new combo (if no active one exists or the input matches a new opener), or"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Advances"})," an existing combo if it matches the expected next step."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If several chains share the same prefix (all begin with ",(0,s.jsx)(n.code,{children:"Light1"}),"), they are ",(0,s.jsx)("span",{class:"orange-bold",children:"all"})," temporarily active until later inputs disambiguate."]}),"\n",(0,s.jsxs)(n.p,{children:["The resolver should also compute the ",(0,s.jsx)(n.em,{children:"best"})," chain so that only one combo step executes at a time: the completed chain is ",(0,s.jsx)(n.strong,{children:"chosen"})," when multiple are valid. If no chain is completed, then it will select the ",(0,s.jsx)(n.strong,{children:"longest"})," chain instead."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, suppose we received ",(0,s.jsx)(n.code,{children:"Light1"}),". This tracks all three chains: FireSlash, IceSlash, and GroundSlam. Then ",(0,s.jsx)(n.code,{children:"Light2"})," is pressed. The resolver computes that:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2"})," ",(0,s.jsx)(n.strong,{children:"continues"})," the ",(0,s.jsx)(n.strong,{children:"FireSlash"})," chain (incomplete)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2"})," also ",(0,s.jsx)(n.strong,{children:"continues"})," toward ",(0,s.jsx)(n.strong,{children:"IceSlash"})," chain (incomplete)."]}),"\n",(0,s.jsxs)(n.li,{children:["However it no longer tracks the ",(0,s.jsx)(n.strong,{children:"GroundSlam"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Creates new single-tap combo ",(0,s.jsx)(n.code,{children:"Light2"})," (instantly completed)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["At this point, the ",(0,s.jsx)(n.strong,{children:"best"})," chain would be ",(0,s.jsx)(n.code,{children:"Light2"})," (single-tap combo chain)."]}),"\n",(0,s.jsx)(n.h4,{id:"step-3-execution",children:"Step 3: Execution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ComboExecutor"})," ",(0,s.jsx)(n.strong,{children:"triggers"})," the animation clip for the current (",(0,s.jsx)(n.em,{children:"best"}),") step, ",(0,s.jsx)(n.strong,{children:"consumes"})," stamina, ",(0,s.jsx)(n.strong,{children:"applies"})," cooldowns, and ",(0,s.jsx)(n.strong,{children:"determines"})," the next combo-window timing from either animation events or ratio settings."]}),"\n",(0,s.jsx)(n.h4,{id:"step-4-combo-timing-control",children:"Step 4: Combo Timing Control"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ComboTiming"})," ",(0,s.jsx)("span",{class:"orange-bold",children:"stores"})," the ",(0,s.jsx)(n.code,{children:"open"})," and ",(0,s.jsx)(n.code,{children:"close"})," combo timestamps for the next input window, allowing the player to ",(0,s.jsx)(n.em,{children:"chain smoothly"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It never triggers events itself; it only exposes\n",(0,s.jsx)(n.code,{children:"ShouldOpenWindow()"})," / ",(0,s.jsx)(n.code,{children:"ShouldCloseWindow()"})," predicates that the ",(0,s.jsx)(n.code,{children:"ComboManager"})," polls every frame."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)("span",{class:"red-bold",children:"Important:"})," each move\u2019s animation clip must be ",(0,s.jsx)(n.strong,{children:"longer than its combo window"}),", so the system has time to open the window mid-animation before closing it near the end."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If the player presses the next attack ",(0,s.jsx)(n.strong,{children:"inside"})," the open window, the all active combo chains ",(0,s.jsx)(n.strong,{children:"advances"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If pressed ",(0,s.jsx)(n.strong,{children:"too early or too late"}),", the manager either ",(0,s.jsx)(n.strong,{children:"buffers"})," one queued input or ",(0,s.jsx)(n.strong,{children:"drops"})," it once the window expires."]}),"\n",(0,s.jsx)(n.h4,{id:"step-5-state-update",children:"Step 5: State Update"}),"\n",(0,s.jsxs)(n.p,{children:["We need to store some kind of ",(0,s.jsx)(n.code,{children:"ComboState"})," that holds the ",(0,s.jsx)(n.strong,{children:"global"})," runtime context\u2014active chains, input history, and the currently playing combo. Therefore, once we decide the execute a combo and set up all the timings (animation clip window and combo window), we need to update our ",(0,s.jsx)(n.code,{children:"ComboState"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Recall that if several combos chains are active (e.g., ",(0,s.jsx)(n.code,{children:"FireSlash"})," and ",(0,s.jsx)(n.code,{children:"IceSlash"})," after ",(0,s.jsx)(n.code,{children:"Light2"}),"), the system keeps both but executes whichever has the ",(0,s.jsx)(n.strong,{children:"deepest"})," progress or is already ",(0,s.jsx)(n.strong,{children:"complete"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"step-6-finisher-check",children:"Step 6: Finisher Check"}),"\n",(0,s.jsx)(n.p,{children:"Finishers mark the completion point of a combo chain. When a chain reaches its final step, the system arms its finisher, but doesn\u2019t play it right away."}),"\n",(0,s.jsxs)(n.p,{children:["Instead, the finisher is triggered ",(0,s.jsx)(n.em,{children:"contextually"}),", depending on what happens next:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"If the player stops input, then the finisher plays naturally as the combo concludes."}),"\n",(0,s.jsxs)(n.li,{children:["If the next input starts a new chain (for example, pressing ",(0,s.jsx)(n.code,{children:"Light3"})," after completing ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"}),") then the system first plays the previous combo\u2019s finisher, then begins the ",(0,s.jsx)(n.em,{children:"new"})," chain."]}),"\n",(0,s.jsxs)(n.li,{children:["If the next input continues the same combo (e.g. ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light3"})," in a longer chain), then the finisher is suppressed until that longer sequence finishes."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This ensures short combos still deliver their finishing payoff, while longer or branching chains remain smooth and uninterrupted. The result is a combat flow that feels responsive, readable, and cinematic as finishers punctuate the action only when a combo truly ends."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"If we want to add damage computation logic (AOE hits, explosions, shockwaves, etc.) for certain finishers,\nthe clean and scalable way is to attach that behaviour to the animation clip via events, not to the combo logic itself."})}),"\n",(0,s.jsx)(n.h4,{id:"step-7-return-to-idle",children:"Step 7: Return to Idle"}),"\n",(0,s.jsx)(n.p,{children:"If no input is queued when the animation ends, the combo state is cleared and the system returns to idle, ready for a fresh sequence."}),"\n",(0,s.jsx)(n.h3,{id:"timing-example",children:"Timing Example"}),"\n",(0,s.jsx)(n.p,{children:"Timing determines whether an input continues a combo or fails to register."}),"\n",(0,s.jsxs)(n.p,{children:["Even a perfectly defined chain (",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2 \u2192 Light3"}),") will not feel responsive unless its combo windows line up naturally with animation playback."]}),"\n",(0,s.jsx)(n.h4,{id:"1-anatomy-of-a-combo-step",children:"1. Anatomy of a Combo Step"}),"\n",(0,s.jsxs)(n.p,{children:["Each attack animation (e.g. ",(0,s.jsx)(n.code,{children:"Light1"}),") has two critical regions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|--------------- Animation Clip (0.0 \u2192 1.0 normalized) ---------------|\n^ Start: Attack Triggered                                             |\n|              ^ Combo Window Opens                                   |\n|                                                           ^ Combo Window Closes\n|                                                                     ^ Animation Ends\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"animation clip"})," represents the full motion of a single attack."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"combo window"})," is a time slice within that motion where the next input is allowed."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"manager"})," uses the window timestamps (start / end) stored in ",(0,s.jsx)(n.code,{children:"ComboTiming"})," to decide when to accept chaining."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("span",{class:"orange-bold",children:"Example:"}),"\nIf the clip is 1.0 s long and the window starts at 0.45 s and ends at 0.80 s, then:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Pressing the ",(0,s.jsx)(n.em,{children:"next"})," input between ",(0,s.jsx)(n.strong,{children:"0.45 s\u20130.80 s"})," ",(0,s.jsx)("span",{class:"orange-bold",children:"continues"})," the combo."]}),"\n",(0,s.jsx)(n.li,{children:"Pressing before 0.45 s buffers one input (queued)."}),"\n",(0,s.jsx)(n.li,{children:"Pressing after 0.80 s is ignored (the window closed)."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"2-animation-length-vs-combo-window",children:"2. Animation Length vs Combo Window"}),"\n",(0,s.jsxs)(n.p,{children:["It is assumed that the ",(0,s.jsx)(n.strong,{children:"animation clip length must always be longer than the combo window"})," for that step.\nThis ensures the window opens ",(0,s.jsx)(n.strong,{children:"while"})," the move is still visible and playable."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Correct:\n|---------------------- Clip (1.0s) ----------------------|\n         |------ Combo Window (0.45\u20130.80s) ------|\n\nIncorrect:\n|----- Clip (0.5s) -----|\n      |------ Combo Window (0.45\u20130.80s) ------| exceeds clip length\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Designer Tips",type:"info",children:(0,s.jsxs)(n.p,{children:["When designing new moves, always adjust the window so that it fits comfortably ",(0,s.jsx)(n.em,{children:"within"})," the visible attack animation.\nIf the window opens too early or closes too late, the system will either never open it or fail to chain correctly."]})}),"\n",(0,s.jsxs)(n.h4,{id:"3-example-timeline-light-1--light-2--light-3-iceslash",children:["3. Example Timeline: ",(0,s.jsx)(n.code,{children:"Light 1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light 2"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light 3"})," (\u201cIceSlash\u201d)"]}),"\n",(0,s.jsxs)(n.admonition,{title:"Combo Chain: IceSlash",type:"note",children:[(0,s.jsx)(n.p,{children:"This combo chain is consisted of 3 combo steps:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Step 1: Light1 input, Sword_Light1 clip"}),"\n",(0,s.jsx)(n.li,{children:"Step 2: Light2 input, Sword_Light2 clip"}),"\n",(0,s.jsx)(n.li,{children:"Step 3: Light3 input, Sword_Light3_Ice clip"}),"\n"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Time (s)   0.0      0.4      0.8     1.2     1.6     2.0\n        |--------|---------|-------|-------|-------|\n         \u2b95 Input: Light1 accepted\nLight1   \u25b6 [Animation Sword_Light1]\n              [\u23f2 Combo Window]\n                        \u2b95 Input: Light2 accepted\nLight2                             \u25b6 [Animation Sword_Light2]\n                                        [\u23f2 Combo Window]\n                                             \u2b95 Input: Light3 accepted\nLight3                                                       \u25b6 [Animation Sword_Light3_Ice]\n                                                                    [\u23f2 Combo Window]\n                                                                                            \u2b95 Finisher triggered if any (after Light 3 animation ends)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Each animation plays ",(0,s.jsx)("span",{class:"orange-bold",children:"fully"}),", with its own embedded window."]})}),"\n",(0,s.jsx)(n.p,{children:"The player presses at the rhythm of the combo window opening. If any input misses its combo window, the chain breaks and the manager resets state."}),"\n",(0,s.jsx)(n.h4,{id:"4-multiple-active-chains--longest-match-vs-completed",children:"4. Multiple Active Chains & \u201cLongest Match\u201d vs \u201cCompleted\u201d"}),"\n",(0,s.jsxs)(n.p,{children:["During execution, several combos can remain active at once. For example, after pressing ",(0,s.jsx)(n.code,{children:"Light2"}),", both ",(0,s.jsx)(n.code,{children:"FireSlash"})," and ",(0,s.jsx)(n.code,{children:"IceSlash"})," may still be valid continuations."]}),"\n",(0,s.jsxs)(n.p,{children:["The resolver keeps ",(0,s.jsx)("span",{class:"orange-bold",children:"all"})," active possibilities alive until input or timing disambiguates them. When the next input arrives, or when the current combo window closes, it determines the ",(0,s.jsx)(n.strong,{children:"best chain"})," to advance or finish."]}),"\n",(0,s.jsx)(n.p,{children:"Priority follows two rules:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"If a chain can still advance (combo window open):"}),"\nPick the chain with the ",(0,s.jsx)(n.strong,{children:"longest valid progress"})," (deepest index).\nThis lets complex combos naturally override simpler ones that share prefixes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"If the combo window closes (no further input can advance):"}),"\nIf one or more active chains have reached their ",(0,s.jsx)(n.strong,{children:"final step"}),", the system picks that chain and triggers its ",(0,s.jsx)(n.strong,{children:"finisher"}),".\nIf no chain can continue, but a new input begins a ",(0,s.jsx)(n.em,{children:"different"})," chain (a new opener), then the ",(0,s.jsx)(n.strong,{children:"previous finished chain\u2019s finisher"})," triggers ",(0,s.jsx)(n.em,{children:"first"}),", immediately followed by the new chain\u2019s opener."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This timing rule ensures finishers are not fired prematurely, only when the system is certain no more valid continuation exists for the current combo."}),"\n",(0,s.jsx)(n.h4,{id:"5-finisher-timing",children:"5. Finisher Timing"}),"\n",(0,s.jsxs)(n.p,{children:["A finisher is evaluated ",(0,s.jsx)(n.strong,{children:"when the combo window closes"}),", signalling that no further continuation is possible."]}),"\n",(0,s.jsxs)(n.p,{children:["If the next input after this point starts a ",(0,s.jsx)(n.em,{children:"new"})," chain rather than extending the current one,\nthe finisher for the old chain plays ",(0,s.jsx)(n.strong,{children:"first"}),", and then the new opener executes."]}),"\n",(0,s.jsxs)(n.p,{children:["This gives clean transitions and ",(0,s.jsx)("span",{class:"orange-bold",children:"prevents"})," double-triggering."]}),"\n",(0,s.jsx)(n.h4,{id:"6-visual-recap",children:"6. Visual Recap"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n  A["Attack Start"] --\x3e B["Combo Window Opens"]\n  B --\x3e C{"Player Input Detected?"}\n  C --\x3e|Yes: continues same chain| D["Next Step Executes"]\n  C --\x3e|No input| E["Combo Window Closes"]\n  E --\x3e H["Finisher Triggers"]\n  H --\x3e J["Idle"]\n  C --\x3e|New chain input| F["Finisher Triggers"]\n  F --\x3e I["Start New Chain"]'}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Design takeaway:"}),"\nA finisher doesn\u2019t just mark \u201ccombo completed\u201d, it marks ",(0,s.jsx)("span",{class:"orange-bold",children:"\u201ccombo no longer extendable.\u201d"})," It\u2019s only triggered once the system knows the current sequence has ended, either naturally or because the next input belongs to a new chain."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"system-composition-and-code-structure",children:"System Composition and Code Structure"}),"\n",(0,s.jsxs)(n.admonition,{title:"Composition Over Inheritance",type:"success",children:[(0,s.jsx)(n.p,{children:"The goal here is not inheritance, but composition. Each subsystem performs one job, and the ComboManager composes them together at runtime. Composition over inheritance keeps logic modular, testable, and replaceable."}),(0,s.jsx)(n.p,{children:"Each component is stateless or self-contained, and the manager owns them by refer"})]}),"\n",(0,s.jsx)(n.h2,{id:"foundation-layer-data--stateless-components",children:"Foundation Layer: Data & Stateless Components"}),"\n",(0,s.jsxs)(n.p,{children:["These are the basic data definitions and lightweight utilities. They contain ",(0,s.jsx)(n.strong,{children:"no logic"})," besides what\u2019s necessary to store or expose information used by the runtime."]}),"\n",(0,s.jsx)(n.h3,{id:"attacktypecs",children:(0,s.jsx)(n.code,{children:"AttackType.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="AttackType.cs"',children:"public enum AttackType\n{\n    Light1,\n    Light2,\n    Light3,\n    Heavy,\n    None\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Simple identifier for different attacks.\nUsed across chains and runtime systems."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"attackdatacs",children:(0,s.jsx)(n.code,{children:"AttackData.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="AttackData.cs"',children:'using UnityEngine;\n\n/// <summary>\n/// Defines reusable data for a single attack animation:\n/// stamina cost, cooldown, animation triggers, and timing overrides.\n/// </summary>\n[CreateAssetMenu(fileName = "NewAttackData", menuName = "Combat/Attack Data")]\npublic class AttackData : ScriptableObject\n{\n    [Header("Animation Settings")]\n    [Tooltip("Animator trigger that starts this attack")]\n    public string animTrigger;\n    [Tooltip("The clip used for this attack")]\n    public AnimationClip clip;\n\n    [Tooltip("Optional follow-up animation (e.g., finisher). Leave empty for normal attacks")]\n    public string outcomeTrigger;\n\n    [Header("Combat Stats")]\n    [Tooltip("Stamina consumed when performing this attack")]\n    public float staminaCost = 10f;\n\n    [Tooltip("Delay before another attack can be triggered")]\n    public float cooldown = 0.1f;\n\n\n}\n\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Defines per-attack gameplay and animation parameters.\n",(0,s.jsx)(n.a,{href:"#preparing-the-animation-clip-and-setting-up-the-animator-fsm",children:"Animator FSM transitions"})," must be designed to match this.\nUsed by ",(0,s.jsx)(n.code,{children:"ComboExecutor"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This is an ",(0,s.jsx)(n.code,{children:"AttackData"})," for Single Tap Light1 Combo Step:"]}),"\n",(0,s.jsx)(r.A,{path:i(84618).A,widthPercentage:"100%"}),"\n",(0,s.jsxs)(n.p,{children:["This is an ",(0,s.jsx)(n.code,{children:"AttackData"})," for the second Combo Step in FireSlash Combo Chain (has finisher trigger):"]}),"\n",(0,s.jsx)(r.A,{path:i(8858).A,widthPercentage:"100%"}),"\n",(0,s.jsxs)(n.p,{children:["This is an ",(0,s.jsx)(n.code,{children:"AttackData"})," for the third Combo Step in IceSlash Combo Chain:"]}),"\n",(0,s.jsx)(r.A,{path:i(75427).A,widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"combostepcs",children:(0,s.jsx)(n.code,{children:"ComboStep.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ComboStep.cs"',children:'using System.Collections.Generic;\nusing UnityEngine;\n\n/// <summary>\n/// Represents one step in the combo chain\n/// </summary>\n[System.Serializable]\npublic class ComboStep\n{\n    [Tooltip("The button pressed to trigger this step.")]\n    public AttackType attackType;\n\n    [Tooltip("Attack properties: stamina, animation, timing, etc.")]\n    public AttackData attackData;\n\n    [Header("Combo Window (optional override)")]\n    [Tooltip("If true, uses these values instead of animation events")]\n    public bool useWindowOverride = false;\n\n    [Range(0f, 1f)] public float comboWindowStart = 0.45f;\n    [Range(0f, 1f)] public float comboWindowEnd = 0.85f;\n}\n\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Represents a single node in a combo chain.\nA ",(0,s.jsx)(n.code,{children:"ComboChain"})," is simply an ordered list of ",(0,s.jsx)(n.code,{children:"ComboStep"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"combochaincs",children:(0,s.jsx)(n.code,{children:"ComboChain.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ComboChain.cs"',children:'using System.Collections.Generic;\nusing UnityEngine;\n\n/// <summary>\n/// Collection of combo steps that form a complete combo tree for a weapon or stance.\n/// </summary>\n[CreateAssetMenu(fileName = "NewComboChain", menuName = "Combat/Combo Chain")]\npublic class ComboChain : ScriptableObject\n{\n    [Tooltip("If true, finisher requires every previous attack in this chain to land a hit.")]\n\n    public string chainName;\n    public bool requiresAllHits = false;\n    public List<ComboStep> steps = new();\n\n}\n\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"ScriptableObject"})," defining a full combo pattern (e.g., ",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2 \u2192 Light3"}),").\nDesigners can author multiple chains per weapon."]}),"\n"]}),"\n",(0,s.jsx)(r.A,{path:i(17824).A,widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"combatconfigcs",children:(0,s.jsx)(n.code,{children:"CombatConfig.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="CombatConfig.cs"',children:'using UnityEngine;\n\n[CreateAssetMenu(menuName = "Combat/Config/Combat Config")]\npublic class CombatConfig : ScriptableObject\n{\n\n\n    [Tooltip("Global stamina cost multiplier applied to all ComboSteps.")]\n    public float staminaCostMultiplier = 1.0f;\n\n\n    [Header("Combo Window Defaults")]\n    [Range(0f, 1f)] public float defaultComboWindowStart = 0.5f;\n    [Range(0f, 1f)] public float defaultComboWindowEnd = 0.8f;\n}\n\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Bundles all combo chains and stats into one configuration per weapon or character.\nReferenced by ",(0,s.jsx)(n.code,{children:"ComboManager"})," on startup."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"playerstatscs",children:(0,s.jsx)(n.code,{children:"PlayerStats.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="PlayerStats.cs"',children:'using UnityEngine;\n\n[CreateAssetMenu(menuName = "Player/Stats/Player Stats")]\npublic class PlayerStats : ScriptableObject\n{\n    [Header("Core")]\n    public float maxStamina = 100f;\n    public float staminaRegenRate = 10f;\n    public float staminaRegenDelay = 1f;\n\n    [Header("Health")]\n    public float maxHealth = 100f;\n}\n\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Static, fixed starting stats for Player object in the system. It is ",(0,s.jsx)("span",{class:"red-bold",children:"not runtime stats"}),"."]}),"\n"]}),"\n",(0,s.jsx)(r.A,{path:i(61658).A,widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"cooldownmanagercs",children:(0,s.jsx)(n.code,{children:"CooldownManager.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="CooldownManager.cs"',children:"using System.Collections.Generic;\nusing System.Linq;\n\npublic class CooldownManager\n{\n    private readonly Dictionary<AttackType, float> timers = new();\n\n    public void Tick(float dt)\n    {\n        foreach (var key in timers.Keys.ToList())\n        {\n            timers[key] -= dt;\n            if (timers[key] <= 0f) timers.Remove(key);\n        }\n    }\n\n    public bool IsOnCooldown(AttackType type, out float remaining) =>\n        timers.TryGetValue(type, out remaining);\n\n    public void Set(AttackType type, float duration)\n    {\n        if (duration > 0f) timers[type] = duration;\n    }\n\n    public void Clear() => timers.Clear();\n}\n\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Tracks and updates cooldowns per attack.\nQueried in ",(0,s.jsx)(n.code,{children:"ComboManager"})," before executing a step."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"combotimingcs",children:(0,s.jsx)(n.code,{children:"ComboTiming.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ComboTiming.cs"',children:"[System.Serializable]\npublic struct ComboTiming\n{\n    // ---------------------------\n    // Core timing flags\n    // ---------------------------\n    public bool manualTimingControlActive; // true if using manual window timing\n    public bool comboWindowOpen;           // true while player can chain attacks\n    public bool attackInProgress;          // true while attack animation is active\n    public AttackType? queuedAttackType;   // one buffered attack type, if any\n\n    // ---------------------------\n    // Combo window tracking\n    // ---------------------------\n    private float windowStartTime;\n    private float windowEndTime;\n\n    // ---------------------------\n    // Semantic helpers\n    // ---------------------------\n    public bool HasQueue => queuedAttackType != null;\n    public bool IsIdle => !attackInProgress && queuedAttackType == null;\n\n    // ---------------------------\n    // Methods\n    // ---------------------------\n\n    public void Reset(bool includeQueue = false)\n    {\n        manualTimingControlActive = false;\n        comboWindowOpen = false;\n        attackInProgress = false;\n        if (includeQueue)\n            queuedAttackType = null;\n    }\n\n    public void SetComboWindow(float start, float end)\n    {\n        windowStartTime = start;\n        windowEndTime = end;\n        manualTimingControlActive = true;\n        comboWindowOpen = false;\n    }\n\n    public bool ShouldOpenWindow(float now) =>\n        manualTimingControlActive && !comboWindowOpen && now >= windowStartTime;\n\n    public bool ShouldCloseWindow(float now) =>\n        manualTimingControlActive && comboWindowOpen && now >= windowEndTime;\n\n    public void ClearWindow()\n    {\n        manualTimingControlActive = false;\n        comboWindowOpen = false;\n        windowStartTime = 0f;\n        windowEndTime = 0f;\n    }\n}\n\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Holds the open/close timing for chaining combo inputs and ",(0,s.jsx)("span",{class:"orange-bold",children:"queued attack buffer"})," (1 queue slot only).\nPolled by the manager each frame; never triggers events on its own."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"activecombocs",children:(0,s.jsx)(n.code,{children:"ActiveCombo.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ActiveCombo.cs"',children:'\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n/// <summary>\n/// Runtime tracker for an active combo chain.\n/// </summary>\npublic class ActiveCombo\n{\n    public ComboChain chain { get; private set; }\n    public bool hasCompletedAllSteps { get; private set; }\n\n    private List<bool> stepHits;\n    private int _currentIndex;\n    public int currentIndex\n    {\n        get => _currentIndex;\n        set\n        {\n            _currentIndex = value;\n            TrySetComboCompletion();\n        }\n    }\n\n    public ComboStep currentStep\n    {\n        get\n        {\n            return chain.steps[currentIndex];\n        }\n    }\n\n    public AttackType currentAttackType\n    {\n        get\n        {\n            return currentStep.attackType;\n        }\n    }\n\n    public ActiveCombo(ComboChain c, int startIndex = 0)\n    {\n        chain = c;\n        currentIndex = startIndex;\n        stepHits = Enumerable.Repeat(false, chain.steps.Count).ToList();\n    }\n\n    private void TrySetComboCompletion()\n    {\n        hasCompletedAllSteps = _currentIndex >= chain.steps.Count - 1;\n    }\n\n    public void RegisterHit()\n    {\n        stepHits[_currentIndex] = true;\n    }\n\n    public bool AllStepsHit()\n    {\n        return stepHits.All(hit => hit);\n    }\n\n\n\n    public void DebugPrintHits()\n    {\n        var sb = new StringBuilder();\n        sb.AppendLine($"[ActiveCombo Debug] Chain: {chain.name} (Steps: {chain.steps.Count})");\n        for (int i = 0; i < stepHits.Count; i++)\n        {\n            string status = stepHits[i] ? "\u2705 HIT" : "\u274c MISS";\n            string currentMarker = (i == currentIndex) ? " <-- current" : "";\n            sb.AppendLine($"  Step {i + 1}: {chain.steps[i].attackType}  [{status}]{currentMarker}");\n        }\n        sb.AppendLine($"All steps hit: {AllStepsHit()}");\n        sb.AppendLine($"Has completed all steps: {hasCompletedAllSteps}");\n        UnityEngine.Debug.Log(sb.ToString());\n    }\n\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Tracks runtime progress through a single combo chain:\ncurrent step, hits, and completion status."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"state-layer",children:"State Layer"}),"\n",(0,s.jsx)(n.h3,{id:"combostatecs",children:(0,s.jsx)(n.code,{children:"ComboState.cs"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"ComboState"})," is the runtime data container that holds everything the combo system knows about the ",(0,s.jsx)(n.em,{children:"current"})," combat situation.\nIt\u2019s never responsible for gameplay logic or animation, but only for ",(0,s.jsx)(n.strong,{children:"remembering state"})," between frames and inputs."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ComboState.cs"',children:"using System.Collections.Generic;\n#nullable enable\n[System.Serializable]\npublic class ComboState\n{\n    public List<AttackType> inputHistory { get; set; } = new();\n    public List<ActiveCombo> activeCombos { get; set; } = new();\n    public ActiveCombo? currentActiveChain { get; set; }\n    public ActiveCombo? pendingFinisher { get; private set; }\n\n\n    public bool hasActive => activeCombos.Count > 0;\n    public bool hasCompletedAllSteps => currentActiveChain != null && currentActiveChain.hasCompletedAllSteps;\n    public bool canLaunchFinisher => currentActiveChain != null && (!currentActiveChain.chain.requiresAllHits || currentActiveChain.AllStepsHit());\n    public void SetPendingFinisher(ActiveCombo combo) => pendingFinisher = combo;\n    public void ClearPendingFinisher() => pendingFinisher = null;\n\n    public void ClearTracking()\n    {\n        inputHistory.Clear();\n        activeCombos.Clear();\n        pendingFinisher = null;\n    }\n\n    public void ClearAll()\n    {\n        ClearTracking();\n        currentActiveChain = null;\n    }\n\n\n}\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"This table summarizes its conceptual role:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Category"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Purpose"})}),(0,s.jsx)(n.td,{children:"Holds transient runtime data such as input history, active combo chains, and current progression."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Ownership"})}),(0,s.jsxs)(n.td,{children:["Only the ",(0,s.jsx)(n.code,{children:"ComboManager"})," writes to it; other systems (UI, analytics, VFX) can read from it."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Persistence"})}),(0,s.jsx)(n.td,{children:"It\u2019s serializable for debugging and playtesting, but never saved between sessions."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Pending Finishers"})}),(0,s.jsx)(n.td,{children:"Stores deferred finishers if a combo just ended but the system needs to wait before triggering it (e.g., player started a new chain immediately)."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["With this, we can keep the ",(0,s.jsx)(n.strong,{children:"manager stateless"})," since it just manipulates ",(0,s.jsx)(n.code,{children:"ComboState"}),". It makes debugging straightforward and allows new runtime tools (e.g. \u201ccombo replay visualizer\u201d or analytics) without touching the core logic."]}),"\n",(0,s.jsxs)(n.p,{children:["Perfect \u2014 here\u2019s how to document and present ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ComboTiming"})}),", the second pillar of your ",(0,s.jsx)(n.em,{children:"State Layer"}),".\nIt\u2019s short and important \u2014 it gives the combo system its sense of ",(0,s.jsx)(n.em,{children:"tempo"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"combotiming",children:(0,s.jsx)(n.code,{children:"ComboTiming"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"ComboTiming"})," class represents the ",(0,s.jsx)(n.strong,{children:"temporal state"})," of the combo system. It tracks when combo windows ",(0,s.jsx)(n.strong,{children:"open"})," and ",(0,s.jsx)(n.strong,{children:"close"}),", and exposes simple predicates to help the ",(0,s.jsx)(n.code,{children:"ComboManager"})," decide when chaining is allowed."]}),"\n",(0,s.jsx)(n.p,{children:"It never plays animations or checks inputs directly; it only holds timestamps."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ComboTiming.cs"',children:"[System.Serializable]\npublic class ComboTiming\n{\n    // ---------------------------\n    // Core timing flags\n    // ---------------------------\n    public bool manualTimingControlActive; // true if using manual window timing\n    public bool comboWindowOpen;           // true while player can chain attacks\n    public bool attackInProgress;          // true while attack animation is active\n    public AttackType? queuedAttackType;   // one buffered attack type, if any\n\n    // ---------------------------\n    // Combo window tracking\n    // ---------------------------\n    private float windowStartTime;\n    private float windowEndTime;\n\n    // ---------------------------\n    // Semantic helpers\n    // ---------------------------\n    public bool HasQueue => queuedAttackType != null;\n    public bool IsIdle => !attackInProgress && queuedAttackType == null;\n\n    // ---------------------------\n    // Methods\n    // ---------------------------\n\n    public void Reset(bool includeQueue = false)\n    {\n        manualTimingControlActive = false;\n        comboWindowOpen = false;\n        attackInProgress = false;\n        if (includeQueue)\n            queuedAttackType = null;\n    }\n\n    public void SetComboWindow(float start, float end)\n    {\n        windowStartTime = start;\n        windowEndTime = end;\n        manualTimingControlActive = true;\n        comboWindowOpen = false;\n    }\n\n    public bool ShouldOpenWindow(float now) =>\n        manualTimingControlActive && !comboWindowOpen && now >= windowStartTime;\n\n    public bool ShouldCloseWindow(float now) =>\n        manualTimingControlActive && comboWindowOpen && now >= windowEndTime;\n\n    public void ClearWindow()\n    {\n        manualTimingControlActive = false;\n        comboWindowOpen = false;\n        windowStartTime = 0f;\n        windowEndTime = 0f;\n    }\n}\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"The table below summarises its conceptual role:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Category"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Purpose"})}),(0,s.jsxs)(n.td,{children:["Defines the timing boundaries (",(0,s.jsx)(n.code,{children:"openTime"}),", ",(0,s.jsx)(n.code,{children:"closeTime"}),") of the combo input window."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Responsibility"})}),(0,s.jsxs)(n.td,{children:["Only knows ",(0,s.jsx)(n.em,{children:"when"})," events happen \u2014 never triggers them itself."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Used by"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboManager"})," (which polls ",(0,s.jsx)(n.code,{children:"ShouldOpenWindow()"})," and ",(0,s.jsx)(n.code,{children:"ShouldCloseWindow()"})," every frame)."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Stateful Fields"})}),(0,s.jsx)(n.td,{children:"Tracks queued input (buffered attack) and recovery phase between moves."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ComboTiming"})," acts as a ",(0,s.jsx)(n.strong,{children:"stopwatch"}),", not a conductor. It simply keeps track of time and the ",(0,s.jsx)(n.code,{children:"ComboManager"})," decides what to do when that time runs out."]}),"\n",(0,s.jsx)(n.h2,{id:"logic-layer",children:"Logic Layer"}),"\n",(0,s.jsx)(n.h3,{id:"comboresolvercs",children:(0,s.jsx)(n.code,{children:"ComboResolver.cs"})}),"\n",(0,s.jsxs)(n.p,{children:["The resolver is the ",(0,s.jsx)(n.strong,{children:"decision-maker"})," of the system.\nIt takes the current active combos, the new input, and determines:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Which chains can advance."}),"\n",(0,s.jsx)(n.li,{children:"Which new chains should start."}),"\n",(0,s.jsxs)(n.li,{children:["Which one is the ",(0,s.jsx)(n.strong,{children:"best"})," to execute right now."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It never plays animations or handles stamina. It just performs ",(0,s.jsx)(n.strong,{children:"data matching"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ComboResolver.cs"',children:'using System.Collections.Generic;\nusing System.Linq;\n#nullable enable\n/// <summary>\n/// Determines which combos advance or start when a new input arrives.\n/// </summary>\npublic class ComboResolver\n{\n    private readonly List<ComboChain> comboChains;\n    private readonly System.Action<string, string>? log; // optional log hook\n\n    public ComboResolver(List<ComboChain> comboChains, System.Action<string, string>? log = null)\n    {\n        this.comboChains = comboChains;\n        this.log = log;\n    }\n\n    /// <summary>\n    /// Given the current active combos and an input, returns the new set of active combos.\n    /// May advance existing combos and/or start new ones.\n    /// </summary>\n    public List<ActiveCombo> Resolve(List<ActiveCombo> current, AttackType input)\n    {\n        var nextActive = new List<ActiveCombo>();\n        int advanced = 0, started = 0;\n\n        // Advance existing combos if the next step matches the input\n        foreach (var combo in current)\n        {\n            int next = combo.currentIndex + 1;\n            if (next < combo.chain.steps.Count &&\n                combo.chain.steps[next].attackType == input)\n            {\n                combo.currentIndex = next;\n                nextActive.Add(combo);\n                advanced++;\n                log?.Invoke(\n                    $"Advanced combo <b>{combo.chain.chainName}</b> \u2192 step {next + 1}",\n                    LogUtil.Color.Info\n                );\n            }\n        }\n\n        // Start new combos whose first step matches the input\n        foreach (var chain in comboChains)\n        {\n            bool alreadyTracked = nextActive.Any(c => c.chain == chain);\n            bool startsNew = !alreadyTracked &&\n                             chain.steps.Count > 0 &&\n                             chain.steps[0].attackType == input;\n\n            if (startsNew)\n            {\n                var newCombo = new ActiveCombo(chain);\n                nextActive.Add(newCombo);\n                started++;\n                log?.Invoke(\n                    $"Started new combo <b>{chain.chainName}</b> (first step: {input})",\n                    LogUtil.Color.Success\n                );\n            }\n        }\n\n        log?.Invoke(\n            $"Resolved combos: {nextActive.Count} active ({advanced} advanced, {started} started)",\n            LogUtil.Color.Info\n        );\n\n        return nextActive;\n    }\n\n    /// <summary>\n    /// Chooses the best combo among currently active ones (deepest or completed first).\n    /// </summary>\n    public ActiveCombo? SelectBest(List<ActiveCombo> active)\n    {\n        if (active.Count == 0) return null;\n\n        return active\n            .OrderByDescending(c => c.hasCompletedAllSteps) // prefer finished chains\n            .ThenByDescending(c => c.currentIndex)          // else deepest progress\n            .FirstOrDefault();\n    }\n}\n\n'})}),"\n",(0,s.jsxs)(n.p,{children:["How ",(0,s.jsx)(n.code,{children:"Resolve"})," works:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Advancement phase:"}),"\nFor each currently active combo, if the new input matches its next ",(0,s.jsx)(n.code,{children:"ComboStep.attackType"}),", that combo advances."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Creation phase:"}),"\nIf the input matches the opener of a new combo chain, a new ",(0,s.jsx)(n.code,{children:"ActiveCombo"})," is created."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Return phase"}),": returns a new list of active combos based on this input"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It also offers a selection logic:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Among all active combos, ",(0,s.jsx)(n.code,{children:"SelectBest()"})," picks the one that either"]}),"\n",(0,s.jsx)(n.li,{children:"has completed all steps, or (if unavailable)"}),"\n",(0,s.jsxs)(n.li,{children:["has the deepest progress (",(0,s.jsx)(n.code,{children:"currentIndex"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"comboexecutorcs",children:(0,s.jsx)(n.code,{children:"ComboExecutor.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="ComboExecutor.cs"',children:'using UnityEngine;\n#nullable enable\n/// <summary>\n/// Handles the execution of a single combo step:\n/// plays animation, consumes stamina, applies cooldown,\n/// and sets up combo timing.\n/// </summary>\npublic class ComboExecutor\n{\n    private readonly Animator animator;\n    private readonly PlayerRuntimeStats stats;\n    private readonly CombatConfig config;\n    private readonly CooldownManager cooldowns;\n    private readonly int attackLayerIndex;\n    private readonly System.Action<string, string>? log; // optional\n\n    public ComboExecutor(\n        Animator animator,\n        PlayerRuntimeStats stats,\n        CombatConfig config,\n        CooldownManager cooldowns,\n        int attackLayerIndex,\n        System.Action<string, string>? log = null)\n    {\n        this.animator = animator;\n        this.stats = stats;\n        this.config = config;\n        this.cooldowns = cooldowns;\n        this.attackLayerIndex = attackLayerIndex;\n        this.log = log;\n    }\n\n    /// <summary>\n    /// Executes the provided combo step and configures timing.\n    /// Returns true if this step uses animation events for combo window control.\n    /// </summary>\n    public bool Execute(ActiveCombo combo, ref ComboTiming timing)\n    {\n        var step = combo.currentStep;\n        var data = step.attackData;\n        var attackType = step.attackType;\n\n        Log($"Execute {data.name}: {data.animTrigger} (stamina {data.staminaCost}, cooldown {data.cooldown:F2})", LogUtil.Color.Event);\n\n        // trigger animation\n        animator.SetTrigger(data.animTrigger);\n\n        // apply stamina & cooldown\n        stats.UseStamina(data.staminaCost * config.staminaCostMultiplier);\n        cooldowns.Set(attackType, data.cooldown);\n\n        // check animation events\n        bool hasAnimEvents = HasComboEvents(data.animTrigger);\n        if (hasAnimEvents)\n        {\n            Log($"Using animation-event combo windows for {data.clip.name}", LogUtil.Color.Event);\n            return true;\n        }\n\n        // compute manual window\n        float clipLength = GetClipLength(combo);\n        if (clipLength <= 0f) clipLength = 0.5f;\n\n        float startRatio, endRatio;\n        if (step.useWindowOverride)\n        {\n            startRatio = step.comboWindowStart;\n            endRatio = step.comboWindowEnd;\n            Log($"Using AttackData Override window ({startRatio:F2}\u2013{endRatio:F2})", LogUtil.Color.Event);\n        }\n        else\n        {\n            startRatio = config.defaultComboWindowStart;\n            endRatio = config.defaultComboWindowEnd;\n            Log($"Using CombatConfig Default window ({startRatio:F2}\u2013{endRatio:F2})", LogUtil.Color.Event);\n        }\n\n        float start = Time.time + startRatio * clipLength;\n        float end = Time.time + endRatio * clipLength;\n        timing.SetComboWindow(start, end);\n        return false;\n    }\n\n    // ------------------------------------------------------------------------\n    // Helper Methods\n    // ------------------------------------------------------------------------\n\n    private void Log(string message, string color = "#FFFFFF")\n    {\n        log?.Invoke(message, color);\n    }\n\n    private bool HasComboEvents(string animName)\n    {\n        if (animator.runtimeAnimatorController == null) return false;\n\n        foreach (var clip in animator.runtimeAnimatorController.animationClips)\n        {\n            if (clip.name != animName) continue;\n            foreach (var evt in clip.events)\n            {\n                if (evt.functionName == nameof(ComboManager.OpenComboWindow) ||\n                    evt.functionName == nameof(ComboManager.CloseComboWindow))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private float GetClipLength(ActiveCombo combo)\n    {\n        var data = combo.currentStep.attackData;\n        if (data?.clip == null) return 0.5f;\n\n        float speed = animator != null ? animator.speed : 1f;\n        return data.clip.length / Mathf.Max(speed, 0.0001f);\n    }\n}\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"The table below summarises its behavior:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Step"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1. Resource checks"}),(0,s.jsx)(n.td,{children:"Ensures player has stamina and no cooldown conflict."}),(0,s.jsx)(n.td,{children:"Cancels attack if failed."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2. Animation trigger"}),(0,s.jsxs)(n.td,{children:["Fires the Animator trigger from ",(0,s.jsx)(n.code,{children:"AttackData"}),"."]}),(0,s.jsx)(n.td,{children:"Decoupled from logic."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3. Cooldown setup"}),(0,s.jsx)(n.td,{children:"Starts cooldown timer for this attack."}),(0,s.jsx)(n.td,{children:"Prevents immediate reuse."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4. Timing setup"}),(0,s.jsx)(n.td,{children:"Defines open/close times for chaining."}),(0,s.jsxs)(n.td,{children:["Used by ",(0,s.jsx)(n.code,{children:"ComboManager"})," each frame."]})]})]})]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"This class is Compositional because:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No awareness"})," of combos, branching, or finishers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No dependency"})," on ",(0,s.jsx)(n.code,{children:"ComboManager"})," \u2014 it\u2019s just invoked by it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Self-contained"}),": can be tested or reused by AI or cutscene logic."]}),"\n"]})]}),"\n",(0,s.jsx)(n.h4,{id:"finisherevaluatorcs",children:(0,s.jsx)(n.code,{children:"FinisherEvaluator.cs"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"FinisherEvaluator"})," is a lightweight component that decides ",(0,s.jsx)(n.em,{children:"when and how"})," to trigger a finisher animation.\nIt doesn\u2019t contain combo resolution or timing logic as those are handled by ",(0,s.jsx)(n.code,{children:"ComboManager"})," (later).\nIts sole responsibility is to ",(0,s.jsx)(n.strong,{children:"translate a completed combo into a final animation trigger."})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:'title="FinisherEvaluator.cs"',children:'using System;\nusing UnityEngine;\n#nullable enable\npublic class FinisherEvaluator\n{\n    private readonly Animator animator;\n    private readonly Action<string, string>? log;\n\n    public FinisherEvaluator(Animator animator, Action<string, string>? log = null)\n    {\n        this.animator = animator;\n        this.log = log;\n    }\n    public void TryFinishForChain(ActiveCombo combo)\n    {\n        var trigger = combo.currentStep.attackData?.outcomeTrigger;\n        if (string.IsNullOrEmpty(trigger)) return;\n        log?.Invoke($"[Finisher] Triggered for {combo.chain.chainName}: {trigger}", LogUtil.Color.Input);\n        animator.SetTrigger(trigger);\n    }\n\n    public void TryFinish(ComboState state)\n    {\n        if (!state.hasCompletedAllSteps)\n        {\n            log?.Invoke("Finisher not available: combo not completed yet.", LogUtil.Color.Info);\n            return;\n        }\n        if (!state.canLaunchFinisher)\n        {\n            state.currentActiveChain?.DebugPrintHits();\n            log?.Invoke("Finisher blocked: not all hits landed.", LogUtil.Color.Info);\n            return;\n        }\n        if (state.currentActiveChain == null) return;\n\n        var chain = state.currentActiveChain.chain;\n\n        var finalStep = state.currentActiveChain.currentStep;\n        var trigger = finalStep.attackData?.outcomeTrigger;\n        if (string.IsNullOrEmpty(trigger)) return;\n\n        log?.Invoke($"Finisher triggered: {trigger}", LogUtil.Color.Input);\n        animator.SetTrigger(trigger);\n    }\n}\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"The table below summarizes its key points:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Responsibility"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Trigger animation"})}),(0,s.jsxs)(n.td,{children:["Plays the ",(0,s.jsx)(n.code,{children:"outcomeTrigger"})," from the final ",(0,s.jsx)(n.code,{children:"AttackData"})," when a combo completes."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"No timing logic"})}),(0,s.jsxs)(n.td,{children:["Called by ",(0,s.jsx)(n.code,{children:"ComboManager"})," only when the combo can no longer continue."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Optional validation"})}),(0,s.jsxs)(n.td,{children:["Can check for hit confirmation (",(0,s.jsx)(n.code,{children:"AllStepsHit()"}),") or chain completion before firing."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Data-driven"})}),(0,s.jsxs)(n.td,{children:["Finisher type and animation are defined entirely in ",(0,s.jsx)(n.code,{children:"AttackData"}),"."]})]})]})]}),"\n",(0,s.jsxs)(n.h2,{id:"runtime-layer-the-orchestrator-combomanager",children:["Runtime Layer: The Orchestrator ",(0,s.jsx)(n.code,{children:"ComboManager"})]}),"\n",(0,s.jsxs)(n.p,{children:["In this architecture, the ",(0,s.jsx)(n.code,{children:"ComboManager"})," is the ",(0,s.jsx)("span",{class:"orange-bold",children:"orchestrator"})," and state machine that governs the rhythm of combat."]}),"\n",(0,s.jsxs)(n.p,{children:["It controls ",(0,s.jsx)(n.em,{children:"when"})," the player can act, ",(0,s.jsx)(n.em,{children:"when"})," a combo window opens or closes, ",(0,s.jsx)(n.em,{children:"when"})," animations start or finish, and ",(0,s.jsx)(n.em,{children:"when"})," finishers are evaluated."]}),"\n",(0,s.jsxs)(n.p,{children:["We can think of it as the conductor of a live orchestra: every subsystem (resolver, executor, evaluator, etc.) is an instrument, but the ",(0,s.jsx)(n.code,{children:"ComboManager"})," cues them at the right moment."]}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TD\n  A["ComboManager"] --\x3e B["ComboResolver"]\n  A --\x3e C["ComboExecutor"]\n  A --\x3e D["FinisherEvaluator"]\n  A --\x3e E["CooldownManager"]\n  A --\x3e F["ComboTiming"]\n  A --\x3e G["ComboState"]\n  A --\x3e H["PlayerStats"]\n  A --\x3e I["PlayerRuntimeStats"]'}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.admonition,{title:"Philosophy",type:"note",children:[(0,s.jsxs)(n.p,{children:["The key insight is that the manager never \u201cknows\u201d what combo it\u2019s executing. It in an ",(0,s.jsx)(n.em,{children:"orchestrator"}),".\nIt simply interprets a pattern of inputs against a table of data and lets the data dictate the result."]}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ComboManager"})," also doesn\u2019t contain gameplay logic, ",(0,s.jsx)(n.em,{children:"it coordinates it"}),"."]}),(0,s.jsxs)(n.p,{children:["It ",(0,s.jsx)("span",{class:"orange-bold",children:"delegates"})," to the ",(0,s.jsx)(n.code,{children:"Resolver"}),", ",(0,s.jsx)(n.code,{children:"Executor"}),", ",(0,s.jsx)(n.code,{children:"CooldownManager"})," and ",(0,s.jsx)(n.code,{children:"FinisherEvaluator"})," subsystems while holding no hardcoded knowledge about what specific combo or animation is being played."]}),(0,s.jsx)(n.p,{children:"This separation makes it compositional and testable and ensures designers can balance timing, stamina, or even entire combo trees without writing a single line of code."})]}),"\n",(0,s.jsx)(n.h4,{id:"combomanagercs",children:(0,s.jsx)(n.code,{children:"ComboManager.cs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",metastring:'title="ComboManager.cs"',children:'using UnityEngine;\nusing UnityEngine.InputSystem;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Data.Common;\n\n/// <summary>\n/// Handles input pattern matching, stamina usage, cooldowns, and combo timing.\n/// Works with PlayerContext, PlayerRuntimeStats, ComboChain, and AttackDataSO.\n/// Branch-aware sequential architecture: each ComboChain is ordered steps,\n/// and multiple active combos may coexist when prefixes overlap.\n/// </summary>\n[RequireComponent(typeof(Animator))]\n[RequireComponent(typeof(PlayerContext))]\npublic class ComboManager : MonoBehaviour\n{\n    //=====================================================================\n    // CONFIGURATION\n    //=====================================================================\n\n    [Header("Combo Data")]\n    public List<ComboChain> comboChains;\n\n    [Header("Runtime References")]\n    public Animator animator;\n    public int AnimatorAttackLayerIndex = 1;\n\n    [Header("Debug Settings")]\n    public bool enableDebugLogs = true;\n\n\n    //=====================================================================\n    // RUNTIME CONTEXT & COMPONENT REFERENCES\n    //=====================================================================\n\n    private PlayerContext context;\n    private PlayerRuntimeStats runtimeStats;\n    private CombatConfig combatConfig;\n\n\n    //=====================================================================\n    // STATE TRACKING\n    //=====================================================================\n\n    private ComboState comboState = new();\n    private CooldownManager cooldownManager = new();\n    private ComboTiming timing;\n\n\n    //=====================================================================\n    // LOGIC COMPONENTS\n    //=====================================================================\n\n    private ComboResolver resolver;\n    private ComboExecutor executor;\n    private FinisherEvaluator finisher;\n    //=====================================================================\n    // METHODS\n    //=====================================================================\n\n\n    #region Setup & Lifecycle\n\n    void Awake()\n    {\n        context = GetComponent<PlayerContext>();\n        runtimeStats = context.runtimeStats;\n        combatConfig = context.combatConfig;\n        resolver = new ComboResolver(comboChains, LogCombo);\n        executor = new ComboExecutor(animator, runtimeStats, combatConfig, cooldownManager, AnimatorAttackLayerIndex, LogCombo);\n        finisher = new FinisherEvaluator(animator, LogCombo);\n        LogCombo("Initialized ComboManager", LogUtil.Color.Debug);\n    }\n\n    void Start()\n    {\n        foreach (var chain in comboChains)\n        {\n            LogCombo($"[Init] Chain \'{chain.chainName}\' has {chain.steps.Count} steps:", LogUtil.Color.Info);\n            for (int i = 0; i < chain.steps.Count; i++)\n            {\n                var step = chain.steps[i];\n                string trigger = step.attackData != null ? step.attackData.animTrigger : "<null>";\n                string patternSoFar = string.Join(", ", chain.steps\n                    .Take(i + 1)\n                    .Select(s => s.attackType.ToString()));\n\n                LogCombo($"    Step {i + 1}: [{patternSoFar}] \u2192 {trigger}", LogUtil.Color.Info);\n            }\n        }\n    }\n\n    void Update()\n    {\n        runtimeStats.TickRegen(Time.deltaTime);\n        cooldownManager.Tick(Time.deltaTime);\n        HandleComboWindowTiming();\n        LaunchQueuedAttack();\n    }\n\n    bool IsCurrentClipSameAs(Animator animator, AnimationClip targetClip)\n    {\n        if (targetClip == null)\n            return false;\n\n\n        var clips = animator.GetCurrentAnimatorClipInfo(AnimatorAttackLayerIndex);\n        if (clips.Length > 0)\n        {\n            // Debug.Log($"Clip {clips[0].clip}");\n            if (clips[0].clip == targetClip)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    private void LaunchQueuedAttack()\n    {\n        if (timing.attackInProgress && comboState.currentActiveChain != null)\n        {\n            if (IsCurrentClipSameAs(animator, comboState.currentActiveChain.currentStep.attackData.clip))\n            {\n                var state = animator.GetCurrentAnimatorStateInfo(1);\n                // Debug.Log($"Current state normalised time: {state.normalizedTime}");\n                if (state.normalizedTime >= 0.975f)\n                {\n                    // mark early finish flag at 97.5% to account for slight delay\n                    OnAttackFinished();\n                }\n            }\n        }\n    }\n\n    private void HandleComboWindowTiming()\n    {\n        if (!timing.manualTimingControlActive) return;\n        float now = Time.time;\n        if (timing.ShouldOpenWindow(now))\n        {\n            OpenComboWindow();\n        }\n        else if (timing.ShouldCloseWindow(now))\n        {\n            CloseComboWindow();\n            timing.ClearWindow();\n        }\n    }\n\n\n    #endregion\n\n    #region Input Handling\n\n    private bool CanAttack(AttackType attackType)\n    {\n        if (!runtimeStats.HasEnoughStamina(1f))\n        {\n            LogCombo("Not enough stamina to attack", LogUtil.Color.Error);\n            return false;\n        }\n\n        if (cooldownManager.IsOnCooldown(attackType, out float remaining))\n        {\n            LogCombo($"[{attackType}] is still on cooldown: {remaining:F2}s remaining", LogUtil.Color.Error);\n            LogCombo("Combo cancelled due to cooldown", LogUtil.Color.Info);\n            SoftClearComboTracking(); // soft clear tracking, keep current chain\n            return false;\n        }\n\n        return true;\n    }\n\n    public void HandleAttackInput(AttackType attackType)\n    {\n        LogCombo($"Input received: <b>{attackType}</b> while attack in progress: {timing.attackInProgress}", LogUtil.Color.Input);\n        // early termination\n        if (!CanAttack(attackType)) return;\n\n        // If no attack in progress then resolve and execute immediately\n        if (!timing.attackInProgress)\n        {\n            comboState.inputHistory.Add(attackType);\n            comboState.activeCombos = resolver.Resolve(comboState.activeCombos, attackType);\n            var best = resolver.SelectBest(comboState.activeCombos);\n\n            if (best == null)\n            {\n                // if nothing advanced or started -> trigger pending finisher once this combo closes\n                LogCombo($"Input {attackType} did not advance any chain; will finish pending finisher if any: {comboState.pendingFinisher.chain.chainName}", LogUtil.Color.Warning);\n                return;\n            }\n            ;\n\n            // check if this best is a new chain, if yes, trigger finisher now\n            if (best.currentIndex == 0 && comboState.pendingFinisher != null)\n            {\n                finisher.TryFinishForChain(comboState.pendingFinisher);\n            }\n\n            // if not, it means something advanced, clear the pending finisher\n            comboState.ClearPendingFinisher();\n\n            var step = best.currentStep;\n            LogCombo(\n                $"{(best.hasCompletedAllSteps ? "Will complete" : "Will continue")} combo: " +\n                $"<b>{best.chain.chainName}</b> | Step {best.currentIndex + 1}/{best.chain.steps.Count} | " +\n                $"Attack: <b>{step.attackType}</b>",\n                best.hasCompletedAllSteps ? LogUtil.Color.Success : LogUtil.Color.Highlight\n            );\n\n            ExecuteStep(best);\n            return;\n        }\n\n        // otherwise add to queue\n        // check if there\'s space\n        if (timing.queuedAttackType == null)\n        {\n            LogCombo($"ADD queued attack: <b>{attackType}</b>", LogUtil.Color.Highlight);\n            timing.queuedAttackType = attackType;\n            // check if combo window is open\n            if (timing.comboWindowOpen)\n            {\n                // we do nothing\n                return;\n            }\n            LogCombo($"Window already closed, will reset combo state");\n        }\n\n        LogCombo($"REPLACE queued attack: <b>{attackType}</b>", LogUtil.Color.Highlight);\n        // queue already full, we just replace it\n        timing.queuedAttackType = attackType;\n        SoftClearComboTracking(); // removes input history and activecombos but keeps currentActiveCombo\n\n\n    }\n\n\n\n    #endregion\n\n\n    #region Execution\n    private void ExecuteStep(ActiveCombo combo)\n    {\n        timing.ClearWindow();\n        bool usesAnimEvents = executor.Execute(combo, ref timing);\n        comboState.currentActiveChain = combo;\n        OnAttackStarted();\n\n        if (combo.hasCompletedAllSteps)\n        {\n            LogCombo($"[Pending Finisher loaded] {combo.chain.chainName} marked as finisher candidate", LogUtil.Color.Highlight);\n            comboState.SetPendingFinisher(combo);\n        }\n\n        // if manual timing is used, executor already set windowStart/End inside timing\n        if (!usesAnimEvents)\n        {\n            timing.manualTimingControlActive = true; //  explicitly re-arm timing\n        }\n    }\n\n\n    #endregion\n\n\n\n    #region Finisher Logic\n\n    public void ConfirmHit()\n    {\n        if (comboState.currentActiveChain == null)\n        {\n            LogCombo("Hit confirmed, but no active attack step: ignored", LogUtil.Color.Warning);\n            return;\n        }\n\n        LogCombo($"Hit confirmed during attack: {comboState.currentActiveChain.currentStep.attackData.name}", LogUtil.Color.Success);\n\n        foreach (var combo in comboState.activeCombos)\n        {\n            if (combo.currentIndex < 0 || combo.currentIndex >= combo.chain.steps.Count)\n                continue;\n\n\n            combo.RegisterHit();\n            combo.DebugPrintHits();\n        }\n    }\n    public void OpenComboWindow()\n    {\n        timing.comboWindowOpen = true;\n        LogCombo($"Window OPEN at {Time.time:F2}", LogUtil.Color.Highlight);\n    }\n\n    public void CloseComboWindow(bool fromComboFinish = false)\n    {\n        timing.comboWindowOpen = false;\n        LogCombo($"Window CLOSE at {Time.time:F2}", LogUtil.Color.Highlight);\n\n        // Don\u2019t finish if something is queued\n        if (timing.queuedAttackType != null)\n        {\n            LogCombo("Queued attack exists; delaying finisher", LogUtil.Color.Info);\n            return;\n        }\n\n        // The right condition to fire here: no queue + pending finisher\n        if (comboState.pendingFinisher != null)\n        {\n            LogCombo($"Triggering finisher: {comboState.pendingFinisher.chain.chainName}", LogUtil.Color.Success);\n            finisher.TryFinishForChain(comboState.pendingFinisher);\n            comboState.ClearPendingFinisher();\n        }\n\n        SoftClearComboTracking();\n    }\n\n    #endregion\n\n\n\n    #region Reset & State Management\n    // Clears lists but keeps current chain and current timing state (your old ResetComboState behavior)\n    private void SoftClearComboTracking()\n    {\n        LogCombo("SoftClearComboTracking");\n        comboState.ClearTracking();\n    }\n\n\n    public void OnAttackStarted()\n    {\n        timing.attackInProgress = true;\n        timing.comboWindowOpen = false;\n        LogCombo($"Attack Animation STARTED at {Time.time:F2} <color=#7FFFD4><b>ComboTiming @ {context}</b></color>\\n{timing}", LogUtil.Color.Info);\n    }\n\n    public void OnAttackFinished()\n    {\n        if (!timing.attackInProgress) return;\n        timing.attackInProgress = false;\n        LogCombo($"Attack Animation FINISHED at at {Time.time:F2}");\n        // Check for queued attack\n        if (timing.queuedAttackType != null)\n        {\n            LogCombo($"Executing queued attack {timing.queuedAttackType}", LogUtil.Color.Success);\n            HandleAttackInput(timing.queuedAttackType.Value);\n            timing.queuedAttackType = null;\n        }\n        else\n        {\n            LogCombo("No queued attack found", LogUtil.Color.Info);\n        }\n    }\n\n    #endregion\n\n    #region Debug & Logging\n    private void LogCombo(string message, string color = "#FFFFFF")\n    {\n        if (!enableDebugLogs) return;\n        LogUtil.LogDebug(message, color, "ComboManager");\n    }\n    #endregion\n}\n\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"unpacking-the-manager",children:"Unpacking the Manager"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Composition over inheritance"}),": as mentioned, ",(0,s.jsx)(n.code,{children:"ComboManager"})," wires small, single-purpose modules and coordinates timing. It never hardcodes \u201cwhat\u201d a move does but ",(0,s.jsx)("span",{class:"orange-bold",children:"only"})," \u201cwhen\u201d to advance, finish, or reset."]}),"\n",(0,s.jsx)(n.h4,{id:"collaborators-composition",children:"Collaborators (composition)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data:"})," ",(0,s.jsx)(n.code,{children:"ComboChain"})," (list), ",(0,s.jsx)(n.code,{children:"CombatConfig"})," (via ",(0,s.jsx)(n.code,{children:"PlayerContext"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State:"})," ",(0,s.jsx)(n.code,{children:"ComboState"}),", ",(0,s.jsx)(n.code,{children:"ComboTiming"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logic:"})," ",(0,s.jsx)(n.code,{children:"ComboResolver"}),", ",(0,s.jsx)(n.code,{children:"ComboExecutor"}),", ",(0,s.jsx)(n.code,{children:"FinisherEvaluator"}),", ",(0,s.jsx)(n.code,{children:"CooldownManager"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Engine:"})," ",(0,s.jsx)(n.code,{children:"Animator"})," (attack layer index configurable)"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"lifecycle--wiring",children:"Lifecycle & wiring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"void Awake() {\n  context = GetComponent<PlayerContext>();\n  runtimeStats = context.runtimeStats;\n  combatConfig = context.combatConfig;\n\n  resolver  = new ComboResolver(comboChains, LogCombo);\n  executor  = new ComboExecutor(animator, runtimeStats, combatConfig, cooldownManager, AnimatorAttackLayerIndex, LogCombo);\n  finisher  = new FinisherEvaluator(animator, LogCombo);\n\n  timing    = new ComboTiming();\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Start()"})}),": logs each chain & step (great for authoring/debug)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Update()"})}),": ticks stamina & cooldowns, polls timing, and checks clip completion (via ",(0,s.jsx)(n.code,{children:"LaunchQueuedAttack()"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"input-path-no-attack-in-progress",children:"Input path (no attack in progress)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public void HandleAttackInput(AttackType atk) {\n  if (!CanAttack(atk)) return;\n  if (!timing.attackInProgress) {\n    comboState.inputHistory.Add(atk);\n    comboState.activeCombos = resolver.Resolve(comboState.activeCombos, atk);\n    var best = resolver.SelectBest(comboState.activeCombos);\n    if (best == null) { LogCombo($"no advance; pending finisher?"); return; }\n\n    // \u2705 finisher rule: starting a new chain while one just completed\n    if (best.currentIndex == 0 && comboState.pendingFinisher != null)\n      finisher.TryFinishForChain(comboState.pendingFinisher);\n\n    comboState.ClearPendingFinisher();\n    ExecuteStep(best);\n    return;\n  }\n  // else, queue/replace input while an attack is in progress\n  ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this gives you"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Branch-aware resolution (multiple active chains) with a single \u201cbest\u201d selection as determined by the ",(0,s.jsx)(n.code,{children:"Resolver"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deferred finisher"}),": if a short chain completed and the next input starts a brand-new chain, play the old finisher ",(0,s.jsx)(n.em,{children:"then"})," begin the new opener."]}),"\n",(0,s.jsxs)(n.li,{children:["One-slot ",(0,s.jsx)(n.strong,{children:"input buffer"})," while a clip is playing."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"execution-path",children:"Execution path"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"private void ExecuteStep(ActiveCombo combo) {\n  timing.ClearWindow();\n  bool usesAnimEvents = executor.Execute(combo, ref timing);\n  comboState.currentActiveChain = combo;\n  OnAttackStarted();\n\n  if (combo.hasCompletedAllSteps) comboState.SetPendingFinisher(combo);\n  if (!usesAnimEvents) timing.manualTimingControlActive = true;\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ComboExecutor"})," handles: animator trigger, stamina spend, cooldown start, window times."]}),"\n",(0,s.jsxs)(n.li,{children:["If input completes the chain, ",(0,s.jsx)(n.strong,{children:"mark"})," as pending finisher (don\u2019t fire yet)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"timing-loop-combo-window-openclose",children:"Timing loop (combo window open/close)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"private void HandleComboWindowTiming() {\n  if (!timing.manualTimingControlActive) return;\n  var now = Time.time;\n  if (timing.ShouldOpenWindow(now)) OpenComboWindow();\n  else if (timing.ShouldCloseWindow(now)) { CloseComboWindow(); timing.ClearWindow(); }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Windows are ",(0,s.jsx)(n.strong,{children:"data-driven"})," (from ",(0,s.jsx)(n.code,{children:"AttackData"}),") and only ",(0,s.jsx)(n.strong,{children:"polled"})," here."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"finisher-gate",children:"Finisher gate"}),"\n",(0,s.jsx)(n.p,{children:"In almost every modern real-time action game (God of War, Devil May Cry, Bayonetta, etc.):"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Design Element"}),(0,s.jsx)(n.th,{children:"Typical Behaviour"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Single Finisher"})}),(0,s.jsxs)(n.td,{children:["Only ",(0,s.jsx)(n.strong,{children:"one finisher animation"})," plays at the end of a chain, even if shorter combos are also complete internally."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Completion Priority"})}),(0,s.jsxs)(n.td,{children:["The ",(0,s.jsx)(n.strong,{children:"longest valid chain"})," takes precedence; shorter chains that share the same prefix are suppressed once the longer chain continues."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Event Timing"})}),(0,s.jsxs)(n.td,{children:["The finisher is evaluated only ",(0,s.jsx)(n.strong,{children:"after"})," the player fails to input within the final window, or when the last step\u2019s animation naturally ends."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Purpose"})}),(0,s.jsxs)(n.td,{children:["Finishers mark the ",(0,s.jsx)(n.em,{children:"intentional"})," end of a chain \u2014 a big payoff move, often resetting the state, giving recovery frames, or returning to idle."]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ComboManager"})," simply determines ",(0,s.jsx)("span",{class:"orange-bold",children:"when"})," a finisher may fire: that is, when no valid continuation exists or a new chain begins. The actual animation and any special effects (e.g., cinematic slash) are handled by the ",(0,s.jsx)(n.code,{children:"FinisherEvaluator"}),", keeping the manager purely focused on flow control."]}),"\n",(0,s.jsx)(n.p,{children:"Finisher can be launched by two methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public void CloseComboWindow(bool fromComboFinish = false) {\n  timing.comboWindowOpen = false;\n  // defer if a queued input exists\n  if (timing.queuedAttackType != null) return;\n\n  // if a chain had completed earlier, fire now\n  if (comboState.pendingFinisher != null) {\n    finisher.TryFinishForChain(comboState.pendingFinisher);\n    comboState.ClearPendingFinisher();\n  }\n  SoftClearComboTracking();\n}\n\npublic void HandleAttackInput(AttackType attackType)\n{\n    LogCombo($"Input received: <b>{attackType}</b> while attack in progress: {timing.attackInProgress}", LogUtil.Color.Input);\n    // early termination\n    if (!CanAttack(attackType)) return;\n\n    // If no attack in progress then resolve and execute immediately\n    if (!timing.attackInProgress)\n    {\n        // find best ActiveCombo\n\n        // check if this best is a new chain, if yes, trigger finisher now\n        if (best.currentIndex == 0 && comboState.pendingFinisher != null)\n        {\n            finisher.TryFinishForChain(comboState.pendingFinisher);\n        }\n\n        // if not, it means something advanced, clear the pending finisher\n        comboState.ClearPendingFinisher();\n\n        // logic continues\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"When:"})," only when the current combo can no longer continue (window closed and no queued input)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Also works for"}),": the \u201cnew chain\u201d case, as we already trigger finisher ",(0,s.jsx)(n.em,{children:"before"})," executing the new opener in ",(0,s.jsx)(n.code,{children:"HandleAttackInput()"})," when ",(0,s.jsx)(n.code,{children:"best.currentIndex==0"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"clip-completion--queued-input",children:"Clip completion & queued input"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"private void LaunchQueuedAttack() {\n  if (!timing.attackInProgress || comboState.currentActiveChain == null) return;\n  if (IsCurrentClipSameAs(animator, comboState.currentActiveChain.currentStep.attackData.clip)) {\n    var st = animator.GetCurrentAnimatorStateInfo(AnimatorAttackLayerIndex);\n    if (st.normalizedTime >= 0.975f) OnAttackFinished();\n  }\n}\npublic void OnAttackFinished() {\n  timing.attackInProgress = false;\n  if (timing.queuedAttackType != null) {\n    HandleAttackInput(timing.queuedAttackType.Value);\n    timing.queuedAttackType = null;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ends an attack a touch early (97.5%) to guarantee deterministic follow-ups."}),"\n",(0,s.jsxs)(n.li,{children:["Consumes the ",(0,s.jsx)(n.strong,{children:"queued"})," input immediately after finish."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"hit-confirmation-optional",children:"Hit confirmation (optional)"}),"\n",(0,s.jsxs)(n.p,{children:["Not all finisher requires hit conformation. Some finisher will still play regardless of whether you hit an enemy in the previous combo steps. The following method Lets chains gate finishers on ",(0,s.jsx)(n.strong,{children:"requiresAllHits"})," without welding logic into the manager."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public void ConfirmHit() {\n  if (comboState.currentActiveChain == null) return;\n  foreach (var ac in comboState.activeCombos) { ac.RegisterHit(); ac.DebugPrintHits(); }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"cooldowns--stamina-gates",children:"Cooldowns & stamina gates"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CanAttack(...)"})," blocks on low stamina or active cooldowns; logs and ",(0,s.jsx)(n.strong,{children:"soft-clears"})," tracking if on cooldown (keeping current clip flow intact)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"reset-utilities",children:"Reset utilities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SoftClearComboTracking()"})}),": clears history & active lists; preserves current clip state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ResetAll(keepQueued)"})}),": clears everything and timing; optional queue retention."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"runtime-responsibilities",children:"Runtime Responsibilities"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Category"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Key Methods / Fields"}),(0,s.jsx)(n.th,{children:"Collaborators"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Initialization & Setup"})}),(0,s.jsx)(n.td,{children:"Loads all dependencies (context, animator, config, chains) and instantiates core logic components. Logs chain structures for debugging."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Awake()"}),", ",(0,s.jsx)(n.code,{children:"Start()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"PlayerContext"}),", ",(0,s.jsx)(n.code,{children:"ComboResolver"}),", ",(0,s.jsx)(n.code,{children:"ComboExecutor"}),", ",(0,s.jsx)(n.code,{children:"FinisherEvaluator"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Frame Loop"})}),(0,s.jsx)(n.td,{children:"Handles stamina regen, cooldown ticking, combo window polling, and queued attack launch."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Update()"}),", ",(0,s.jsx)(n.code,{children:"HandleComboWindowTiming()"}),", ",(0,s.jsx)(n.code,{children:"LaunchQueuedAttack()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"PlayerRuntimeStats"}),", ",(0,s.jsx)(n.code,{children:"CooldownManager"}),", ",(0,s.jsx)(n.code,{children:"ComboTiming"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Input Handling"})}),(0,s.jsx)(n.td,{children:"Reads attack inputs, validates stamina and cooldowns, performs combo resolution, queues inputs during animations."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"HandleAttackInput()"}),", ",(0,s.jsx)(n.code,{children:"CanAttack()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboResolver"}),", ",(0,s.jsx)(n.code,{children:"ComboState"}),", ",(0,s.jsx)(n.code,{children:"CooldownManager"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Combo Resolution"})}),(0,s.jsxs)(n.td,{children:["Matches new inputs to active or new chains; selects the ",(0,s.jsx)(n.em,{children:"best"})," chain to execute; fires finisher if previous chain completed."]}),(0,s.jsxs)(n.td,{children:["Within ",(0,s.jsx)(n.code,{children:"HandleAttackInput()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboResolver"}),", ",(0,s.jsx)(n.code,{children:"FinisherEvaluator"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Execution & Animation"})}),(0,s.jsx)(n.td,{children:"Plays the animation, applies resource costs, starts cooldowns, sets timing, and flags attack-in-progress."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ExecuteStep()"}),", ",(0,s.jsx)(n.code,{children:"OnAttackStarted()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboExecutor"}),", ",(0,s.jsx)(n.code,{children:"Animator"}),", ",(0,s.jsx)(n.code,{children:"ComboTiming"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Timing Control"})}),(0,s.jsx)(n.td,{children:"Polls for window open/close and reacts accordingly \u2014 opens chaining window or closes it, possibly firing finisher."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"HandleComboWindowTiming()"}),", ",(0,s.jsx)(n.code,{children:"OpenComboWindow()"}),", ",(0,s.jsx)(n.code,{children:"CloseComboWindow()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboTiming"}),", ",(0,s.jsx)(n.code,{children:"FinisherEvaluator"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Finisher Handling"})}),(0,s.jsx)(n.td,{children:"Defers or triggers finishers depending on whether combo continues or ends; supports new-chain-before-finisher case."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"CloseComboWindow()"}),", ",(0,s.jsx)(n.code,{children:"HandleAttackInput()"})," (early check)"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"FinisherEvaluator"}),", ",(0,s.jsx)(n.code,{children:"ComboState"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Hit Confirmation"})}),(0,s.jsx)(n.td,{children:"Marks successful hits for all active combos to allow hit-gated finishers (e.g., \u201crequires all hits\u201d)."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ConfirmHit()"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ActiveCombo"}),", ",(0,s.jsx)(n.code,{children:"ComboState"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Cooldown & Stamina"})}),(0,s.jsx)(n.td,{children:"Prevents execution when stamina or cooldown is insufficient; clears tracking on invalid actions."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"CanAttack()"}),", ",(0,s.jsx)(n.code,{children:"SoftClearComboTracking()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"PlayerRuntimeStats"}),", ",(0,s.jsx)(n.code,{children:"CooldownManager"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Attack Completion"})}),(0,s.jsx)(n.td,{children:"Detects end of animation (via normalized time) and immediately executes any queued attack."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"LaunchQueuedAttack()"}),", ",(0,s.jsx)(n.code,{children:"OnAttackFinished()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Animator"}),", ",(0,s.jsx)(n.code,{children:"ComboTiming"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Reset Management"})}),(0,s.jsx)(n.td,{children:"Provides fine-grained clearing behavior for partial or full resets, preserving queued inputs if needed."}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"SoftClearComboTracking()"}),", ",(0,s.jsx)(n.code,{children:"ResetAll()"})]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ComboState"}),", ",(0,s.jsx)(n.code,{children:"ComboTiming"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Debugging & Logs"})}),(0,s.jsx)(n.td,{children:"Rich color-coded logging for every system event; logs each chain and its trigger pattern on start."}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LogCombo()"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"LogUtil"}),", ",(0,s.jsx)(n.code,{children:"Console"})]})]})]})]}),"\n",(0,s.jsxs)(n.h2,{id:"using-combomanager",children:["Using ",(0,s.jsx)(n.code,{children:"ComboManager"})]}),"\n",(0,s.jsx)(n.h3,{id:"public-interface",children:"Public Interface"}),"\n",(0,s.jsxs)(n.p,{children:["In gameplay, the ",(0,s.jsx)(n.code,{children:"ComboManager"})," exposes only ",(0,s.jsx)(n.strong,{children:"two callable entry points"}),".\nEverything else: timing, window checks, finisher triggers is self-managed internally within ",(0,s.jsx)(n.code,{children:"Update()"}),"."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Public Method"}),(0,s.jsx)(n.th,{children:"Called By"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Typical Source"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"HandleAttackInput(AttackType type)"})})}),(0,s.jsx)(n.td,{children:"Player input controller / input reader"}),(0,s.jsxs)(n.td,{children:["Main entry point for player attack commands. Parses button presses (",(0,s.jsx)(n.code,{children:"Light1"}),", ",(0,s.jsx)(n.code,{children:"Heavy"}),", etc.), performs stamina/cooldown gating, and routes to ",(0,s.jsx)(n.code,{children:"ComboResolver"}),"."]}),(0,s.jsxs)(n.td,{children:["Input event in ",(0,s.jsx)(n.code,{children:"PlayerContext"})," or ",(0,s.jsx)(n.code,{children:"InputReader"})," (Unity Input System callback)."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ConfirmHit()"})})}),(0,s.jsx)(n.td,{children:"Weapon hitbox, animation event, or collision callback"}),(0,s.jsx)(n.td,{children:"Signals that the player\u2019s current attack successfully connected with a target. Used to validate \u201crequiresAllHits\u201d or unlock finisher eligibility."}),(0,s.jsxs)(n.td,{children:["Triggered via ",(0,s.jsx)(n.code,{children:"OnTriggerEnter"}),", animation event, or damage system callback."]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Everything else is private orchestration:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Internal Lifecycle"}),(0,s.jsx)(n.th,{children:"Triggered From"}),(0,s.jsx)(n.th,{children:"Responsibility"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Update()"})}),(0,s.jsx)(n.td,{children:"Unity frame loop"}),(0,s.jsx)(n.td,{children:"Polls stamina regen, cooldown tick, timing, queued attacks."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"HandleComboWindowTiming()"})}),(0,s.jsxs)(n.td,{children:["called by ",(0,s.jsx)(n.code,{children:"Update()"})]}),(0,s.jsx)(n.td,{children:"Opens/closes combo window; triggers finisher when window closes with no queue."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LaunchQueuedAttack()"})}),(0,s.jsxs)(n.td,{children:["called by ",(0,s.jsx)(n.code,{children:"Update()"})]}),(0,s.jsx)(n.td,{children:"Checks animator progress; launches queued input once clip nearly ends."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"OnAttackStarted()"})," / ",(0,s.jsx)(n.code,{children:"OnAttackFinished()"})]}),(0,s.jsxs)(n.td,{children:["internal from ",(0,s.jsx)(n.code,{children:"ExecuteStep()"})," and ",(0,s.jsx)(n.code,{children:"LaunchQueuedAttack()"})]}),(0,s.jsx)(n.td,{children:"Tracks animation boundaries; flushes queued inputs after animation ends."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["In practice, ",(0,s.jsx)("span",{class:"orange-bold",children:"the player input layer only calls two functions"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Input callback\ncomboManager.HandleAttackInput(AttackType.Light1);\n\n// When weapon or animation event confirms a hit\ncomboManager.ConfirmHit();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sequence-diagram-player-input-to-finisher",children:"Sequence Diagram: Player Input to Finisher"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Player\n    participant InputReader\n    participant ComboManager\n    participant ComboResolver\n    participant ComboExecutor\n    participant Animator\n    participant ComboTiming\n    participant FinisherEvaluator\n\n    %% INPUT FLOW\n    Player->>InputReader: Press Attack (e.g. Light1)\n    InputReader->>ComboManager: HandleAttackInput(AttackType)\n\n    ComboManager->>ComboResolver: Resolve(activeCombos, input)\n    ComboResolver--\x3e>ComboManager: Matching ActiveCombos\n    ComboManager->>ComboResolver: SelectBest()\n    ComboResolver--\x3e>ComboManager: Best ActiveCombo\n\n    alt New chain (index == 0) and pending finisher exists\n        ComboManager->>FinisherEvaluator: TryFinishForChain(previous)\n    end\n\n    %% EXECUTION START\n    ComboManager->>ComboExecutor: Execute(best, ref timing)\n    ComboExecutor->>Animator: SetTrigger(animTrigger)\n    ComboExecutor->>ComboTiming: Configure open/close timestamps\n    ComboExecutor--\x3e>ComboManager: returns (usesAnimEvents)\n\n    ComboManager->>ComboManager: OnAttackStarted()\n    Note over ComboManager,Animator: attackInProgress = true<br/>comboWindowOpen = false\n\n    %% TIMING LOOP\n    loop Frame Update\n        ComboManager->>ComboTiming: ShouldOpenWindow()/ShouldCloseWindow()\n        alt Window opens\n            ComboManager->>ComboManager: OpenComboWindow()\n            Note over ComboManager: comboWindowOpen = true\n        else Window closes\n            ComboManager->>ComboManager: CloseComboWindow()\n            Note over ComboManager: comboWindowOpen = false\n            alt Queued input exists\n                ComboManager--\x3e>ComboManager: Delay finisher<br/>keep queued attack\n                Note over ComboManager: Do NOT reset state\n            else Pending finisher exists\n                ComboManager->>FinisherEvaluator: TryFinishForChain(pending)\n                ComboManager->>ComboState: ClearPendingFinisher()\n                ComboManager->>ComboManager: SoftClearComboTracking()\n                Note over ComboManager: Reset only when no queue\n            end\n        end\n    end\n\n    %% ANIMATION END\n    Animator--\x3e>ComboManager: normalizedTime \u2265 0.975\n    ComboManager->>ComboManager: OnAttackFinished()\n    Note over ComboManager: attackInProgress = false\n\n    alt queued input exists\n        ComboManager->>ComboManager: HandleAttackInput(queued)\n        ComboManager->>ComboTiming: queuedAttackType = null\n    else No input queued\n        ComboManager--\x3e>Animator: Return to idle\n    end\n"}),"\n",(0,s.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Only two public entry points"}),": ",(0,s.jsx)(n.code,{children:"HandleAttackInput()"})," and ",(0,s.jsx)(n.code,{children:"ConfirmHit()"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Everything else"})," (finisher, combo window, recovery, queued input) is internal and time-driven."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"sequence"})," ensures:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Finishers play only when continuation is impossible;"}),"\n",(0,s.jsx)(n.li,{children:"Queued attacks execute seamlessly;"}),"\n",(0,s.jsx)(n.li,{children:"Branching chains (shared prefixes) are handled automatically."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"runtime-examples",children:"Runtime Examples"}),"\n",(0,s.jsx)(n.p,{children:"Lets use this example again:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Clip Name"}),(0,s.jsx)(n.th,{children:"Attack Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light1"})}),(0,s.jsx)(n.td,{children:"First fast horizontal slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light2"})}),(0,s.jsx)(n.td,{children:"Second faster returning slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light3"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light3"})}),(0,s.jsx)(n.td,{children:"Third downward secondary slash"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Light3_Ice"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Light3"})}),(0,s.jsx)(n.td,{children:"Downward secondary slash with Ice effect"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Sword_Heavy1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Heavy"})}),(0,s.jsx)(n.td,{children:"A slower, stamina-heavy overhead strike"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Combo chains (the clips played are the basic ones unless otherwise stated):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FireSlash"}),": ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"})," (has finisher)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IceSlash"}),": ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light3"})," (no finisher), ",(0,s.jsx)(n.code,{children:"Light3"})," triggers ",(0,s.jsx)(n.code,{children:"Sword_Light3_Ice"})," clip (no finisher)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GroundSlam"}),": ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light1"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light2"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light3"})," \u2192 ",(0,s.jsx)(n.code,{children:"Light1"})," (has finisher)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single tap"}),": Any one-step opener (e.g., just ",(0,s.jsx)(n.code,{children:"Light1"}),") should also perform a valid attack."]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"runtime-timeline-a-iceslash-cancelled-fireslash-finisher-triggered",children:["Runtime Timeline A: ",(0,s.jsx)(n.em,{children:"\u201cIceSlash Cancelled, FireSlash Finisher Triggered\u201d"})]}),"\n",(0,s.jsx)(n.h4,{id:"scenario",children:"Scenario"}),"\n",(0,s.jsxs)(n.p,{children:["The player begins with inputs meant for ",(0,s.jsx)(n.strong,{children:"IceSlash"})," (",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2 \u2192 Light3"}),"), but instead of pressing ",(0,s.jsx)(n.code,{children:"Light3"}),", they press ",(0,s.jsx)(n.code,{children:"HeavyAttack"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["At that moment, the ",(0,s.jsx)(n.code,{children:"ComboManager"})," detects that IceSlash ",(0,s.jsx)(n.strong,{children:"can no longer continue"})," and triggers\n",(0,s.jsx)(n.strong,{children:"FireSlash\u2019s finisher"})," immediately before executing the HeavyAttack\u2019s single animation."]}),"\n",(0,s.jsx)(n.p,{children:"Thus, IceSlash is cancelled mid-chain, FireSlash\u2019s finisher plays as a payoff, and then the HeavyAttack animation follows naturally."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Time (s)   0.00    0.45    0.80    1.20    1.60    2.00\n           |-------|-------|-------|-------|-------|-------|----------------------------------------------------------------------------------------------|\n            \u2b95 Input: Light1 accepted, queue empty, process immediate\n            \u2b95 FireSlash, GroundSlam, IceSlash, Single tap Light1 started\n            \u2b95 Best: Single tap Light 1 EXEC\nLight1 \u25b6   [Anim Sword_Light1]\n            [\u23f2 Combo Window]\n                     \u2b95 Input: Light2 accepted, queued\n                            \u2b95 Combo window ends, inp queue exist: continue\n                                \u2b95 Anim ends, process input queue: Light2\n                                \u2b95 GroundSlam, Fireslash, Iceslash still valid: advanced\n                                \u2b95 Single tap Light2 started\n                                \u2b95 FireSlash COMPLETED: pending finisher\n                                \u2b95 Best: FireSlash Step 2 EXEC\nLight2 \u25b6                              [Anim Sword_Light2]\n                                        [\u23f2 Combo Window]\n                                                  \u2b95 Input: HeavyAttack accepted, queued\n                                                        \u2b95 Combo window ends, inp queue exist: continue\n                                                            \u2b95 Anim ends, process input queue: HeavyAttack\n                                                            \u2b95 Single tap HeavyAttack started\n                                                            \u2b95 Best: Single tap HeavyAttack\n                                                            \u2b95 FireSlash finisher check hits & TRIGGER\n                                                            \u2b95 Best Combo Step EXEC\nFireSlash Finisher \u25b6                                        [Anim Fireslash  Finisher]\nHeavy \u25b6                                                                               [Anim HeavyAttack]\n                                                                                        [\u23f2 Combo Window]\n                                                                                                         \u2b95 Combo window closes, no input in queue\n                                                                                                         \u2b95 No finisher detected\n                                                                                                         \u2b95 Combo system resets (clear history, active combos)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When an input invalidates an existing chain but belongs to another valid one,\nthe system promotes the new chain and ",(0,s.jsx)(n.strong,{children:"plays its finisher immediately"})," to mark the transition.\nIceSlash is safely cancelled; FireSlash\u2019s finisher gives visual closure before resuming normal attacks."]}),"\n",(0,s.jsxs)(n.h3,{id:"runtime-timeline-b-iceslash-completed-groundslam-finisher-triggered-fireslash-finisher-cancelled",children:["Runtime Timeline B: ",(0,s.jsx)(n.em,{children:"\u201cIceSlash Completed, GroundSlam Finisher Triggered, FireSlash Finisher Cancelled\u201d"})]}),"\n",(0,s.jsx)(n.h4,{id:"scenario-1",children:"Scenario"}),"\n",(0,s.jsxs)(n.p,{children:["The player performs a long sequence:\n",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light1 \u2192 Light2 \u2192 Light3 \u2192 Light1"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.strong,{children:"FireSlash"})," (",(0,s.jsx)(n.code,{children:"Light1\u2192Light2"}),") completes cleanly at ",(0,s.jsx)(n.code,{children:"Light2"})," and ",(0,s.jsx)(n.strong,{children:"IceSlash"})," (",(0,s.jsx)(n.code,{children:"Light1\u2192Light2\u2192Light3"}),") completes cleanly at ",(0,s.jsx)(n.code,{children:"Light3"}),", but since further inputs continue into ",(0,s.jsx)(n.strong,{children:"GroundSlam"})," (",(0,s.jsx)(n.code,{children:"Light1\u21921\u21922\u21923\u21921\u2192Heavy"}),"), the finisher for FireSlash is ",(0,s.jsx)(n.strong,{children:"suppressed"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["It\u2019s recognized as part of a longer valid chain still in progress. Only once the final Light3 ",(0,s.jsx)(n.code,{children:"finishes"}),", and the combo window closes with no queued input, does the ",(0,s.jsx)(n.strong,{children:"GroundSlam finisher"})," trigger."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Time (s)   0.00    0.45    0.80    1.20    1.60    2.00    2.40    2.80    3.20\n           |-------|-------|-------|-------|-------|-------|-------|-------|-------|----------------------------------------------------------------------------------------------------------------------------|\n            \u2b95 Input: Light1 accepted, queue empty, process immediate\n            \u2b95 FireSlash, GroundSlam, IceSlash, Single tap Light1 started\n            \u2b95 Best: Single tap Light 1 EXEC\nLight1 \u25b6   [Anim Sword_Light1]\n            [\u23f2 Combo Window]\n                     \u2b95 Input: Light1 accepted, queued\n                            \u2b95 Combo window ends, inp queue exist: continue\n                              \u2b95 Anim ends, process input queue\n                              \u2b95 FireSlash, GroundSlam, IceSlash, Single tap Light1 started\n                              \u2b95 Single tap Light 1 completed\n                              \u2b95 Best: Single tap Light 1 EXEC\nLight1 \u25b6                        [Anim Sword_Light1]\n                                  [\u23f2 Combo Window]\n                                      \u2b95 Input: Light2 accepted, queued\n                                                  \u2b95 Combo window ends, inp queue exist: continue\n                                                    \u2b95 Anim ends, process input queue\n                                                    \u2b95 GroundSlam, Fireslash, Iceslash still valid: advanced\n                                                    \u2b95 Single tap Light2 started\n                                                    \u2b95 FireSlash COMPLETED: pending finisher\n                                                    \u2b95 Best: FireSlash Step 2 EXEC\nLight2 \u25b6                                           [Anim Sword_Light2]\n                                                    [\u23f2 Combo Window]\n                                                        \u2b95 Input: Light3 accepted, queued\n                                                                    \u2b95 Combo window ends, inp queue exist: continue\n                                                                        \u2b95 Anim ends, process input queue\n                                                                        \u2b95 GroundSlam, IceSlash still valid \u2192 advanced\n                                                                        \u2b95 Single tap Light3 started\n                                                                        \u2b95 Iceslash COMPLETED: pending finisher\n                                                                        \u2b95 Best: IceSlash Step 3 EXEC\n                                                                        \u2b95 Cancelled: Fireslash Finisher\nLight3 \u25b6                                                                [Anim Sword_Light3_Ice]\n                                                                            [\u23f2 Combo Window]\n                                                                                        \u2b95 Input: Light1 accepted\n                                                                                            \u2b95 Combo window ends, inp queue exist: continue\n                                                                                                \u2b95 Anim ends, proceress input queue\n                                                                                                \u2b95 Combo window ends, inp queue exist: continue\n                                                                                                \u2b95 GroundSlam still valid \u2192 advanced\n                                                                                                \u2b95 FireSlash, IceSlash, Single tap Light1 started\n                                                                                                \u2b95 Single tap Light 1 completed\n                                                                                                \u2b95 GroundSlam COMPLETED: pending finisher\n                                                                                                \u2b95 Best: GroundSlam Step 5 EXEC\n                                                                                                \u2b95 Cancelled: IceSlash Finisher\nLight1 \u25b6                                                                                        [Anim Sword_Light1]\n                                                                                                 [\u23f2 Combo Window]\n                                                                                                                 \u2b95 Combo window closes, no input in queue\n                                                                                                                 \u2b95 GroundSlam Finisher check hit & TRIGGER\n                                                                                                                 \u2b95 Combo system resets (clear history, active combos)\nGroundSlam Finisher \u25b6                                                                                           [Anim GroundSlam  Finisher]\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Design Reflection",type:"note",children:[(0,s.jsxs)(n.p,{children:["These two cases show the subtle difference between ",(0,s.jsx)(n.strong,{children:"interruption"})," and ",(0,s.jsx)(n.strong,{children:"extension"}),". In Runtime A, a new input cuts off the current chain: the system finalizes what\u2019s ending before starting what\u2019s new.\nIn Runtime B, a new input extends the chain \u2014 the system defers finishers to maintain flow."]}),(0,s.jsxs)(n.p,{children:["This is the essence of our resolver\u2019s design: ",(0,s.jsx)(n.strong,{children:"canceling \u2260 finishing"}),", and ",(0,s.jsx)(n.strong,{children:"continuing \u2260 interrupting"}),". Those fine distinctions are what make the system feel intelligent, responsive, and alive."]})]}),"\n",(0,s.jsx)(n.h2,{id:"preparing-the-animation-clip-and-setting-up-the-animator-fsm",children:"Preparing the Animation Clip and Setting up the Animator FSM"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-create-clips-for-all-combat-movement-step-and-special-finisher-animation",children:"Step 1: Create clips for all combat movement step and special finisher animation"}),"\n",(0,s.jsxs)(n.p,{children:["Create a clip for each possible movement animation, e.g: ",(0,s.jsx)(n.code,{children:"Light1, Light2, Light3, HeavyAttack1, FireSlashFinisher, GroundSlamFinisher"}),", etc."]}),"\n",(0,s.jsx)(a.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/combo/set-clips.mov",widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-animator-fsm",children:"Step 2: Create Animator FSM"}),"\n",(0,s.jsx)(n.p,{children:"Each clip (combat move) should be able to be triggered from some IDLE COMBAT state. There's no need to incorporate combo logic in the Animator FSM."}),"\n",(0,s.jsx)(r.A,{path:i(39515).A,widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h4,{id:"trigger",children:"Trigger"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"transition"})," from IDLE COMBAT to any combat move state should ",(0,s.jsx)(n.strong,{children:"not"})," have any exit time so that the transition is immediate. You should add the appropriate ",(0,s.jsx)("span",{class:"orange-bold",children:"trigger"})," parameter as defined in your ",(0,s.jsxs)(n.a,{href:"#attackdatacs",children:[(0,s.jsx)(n.code,{children:"AttackData"})," earlier"]}),":"]}),"\n",(0,s.jsx)(r.A,{path:i(53480).A,widthPercentage:"100%"}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsxs)(n.p,{children:["The trigger parameter for each combat move state ",(0,s.jsx)("span",{class:"orange-bold",children:"must"})," match the ",(0,s.jsx)(n.code,{children:"Anim Trigger"})," or ",(0,s.jsx)(n.code,{children:"Outcome Trigger"})," field in ",(0,s.jsx)(n.code,{children:"AttackData"})," SO, otherwise the system fails."]}),(0,s.jsx)(r.A,{path:i(92431).A,widthPercentage:"100%"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"transition"})," from any combat move state to IDLE COMBAT should ",(0,s.jsx)(n.strong,{children:"have"})," its exit time checked so that the combat move clip plays fully without condition:"]}),"\n",(0,s.jsx)(r.A,{path:i(86495).A,widthPercentage:"100%"}),"\n",(0,s.jsxs)(n.p,{children:['Any "cancels" logic can be implemented inside ',(0,s.jsx)(n.code,{children:"ComboResolver"})," instead. The Animator FSM should be made as simple as possible."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["You can optionally ",(0,s.jsx)(n.strong,{children:"add layers"})," to your animator if you have another moveset for walking, running, jumping etc (eg: locomotive layer). Just ensure that you have assigned proper layer priority (combat > locomotive) and make the IDLE COMBAT state play a clip with no markers."]}),(0,s.jsx)(r.A,{path:i(2656).A,widthPercentage:"100%"})]}),"\n",(0,s.jsx)(n.h2,{id:"demo",children:"Demo"}),"\n",(0,s.jsx)(n.h3,{id:"basic-single-tap-no-combo",children:"Basic Single Tap (no combo)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Light1"}),", ",(0,s.jsx)(n.code,{children:"Light2"}),", ",(0,s.jsx)(n.code,{children:"Light3"}),", ",(0,s.jsx)(n.code,{children:"Heavy"}),", slow tapped without invoking combos."]}),"\n",(0,s.jsx)(a.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/combo/basic-single-tap.mov",widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"fireslash",children:"FireSlash"}),"\n",(0,s.jsxs)(n.p,{children:["FireSlash succeeds (",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2"}),")."]}),"\n",(0,s.jsx)(a.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/combo/fireSlash.mov",widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"iceslash",children:"IceSlash"}),"\n",(0,s.jsxs)(n.p,{children:["IceSlash succeeds (",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2 \u2192 Light3"}),"). FireSlash finisher ",(0,s.jsx)(n.strong,{children:"cancelled"})," due to longer-chain IceSlash."]}),"\n",(0,s.jsx)(a.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/combo/iceSlash.mov",widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"failed-iceslash",children:"Failed IceSlash"}),"\n",(0,s.jsxs)(n.p,{children:["IceSlash failed (",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light2 \u2192 late Light3"}),"). FireSlash finisher ",(0,s.jsx)(n.strong,{children:"fires"})," due to Single Tap Light3 being the best step here as IceSlash failed."]}),"\n",(0,s.jsx)(a.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/combo/IceSlash-late-FireSlash-finish.mov",widthPercentage:"100%"}),"\n",(0,s.jsx)(n.h3,{id:"groundslam",children:"GroundSlam"}),"\n",(0,s.jsxs)(n.p,{children:["GroundSlam succeeds (",(0,s.jsx)(n.code,{children:"Light1 \u2192 Light1 \u2192 Light2 \u2192 Light3 \u2192 Light1"}),"). FireSlash finisher ",(0,s.jsx)(n.strong,{children:"cancelled"})," due to longer-chain progression GroundSlam. IceSlash special clip (not finisher) after ",(0,s.jsx)(n.code,{children:"Light3"})," key pressed still plays as it is completed (seen as best, as opposed to ongoing GroundSlam). In the end, GroundSlam finisher plays."]}),"\n",(0,s.jsx)(a.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/combo/GroundSlam-finisher-Iceslash-complete-Fireslash-compete-finisher-canceled.mov",widthPercentage:"100%"})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},84618:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-09-16-42-07-7b857bc16a9a3e52303a865a1844e2e2.png"},17824:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-09-16-42-49-36659484b747e6ca20d4e41e06cc6768.png"},61658:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-09-16-47-53-0d1b6fa9ede1622d6cb6eaef4b283ab9.png"},39515:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-10-09-36-14-c962e9fa462fa0856d6e4244673c454d.png"},2656:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-10-09-38-06-eb5b473478f8ec16116ac5b554f1e44f.png"},53480:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-10-09-39-12-9cae4d187748d63f09425be31b4277fb.png"},86495:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-10-09-40-11-f0125427d1619f064161df4bb79b053d.png"},8858:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-10-10-08-05-3e31f15795c535fbd3aa9f12e40abe6c.png"},75427:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/2025-10-10-10-08-22-075fa62f9560d66cdfdf1ea32286795e.png"},92431:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/Screenshot 2025-10-10 at 10.12.53\u202fAM-58e96b6e1f7a7f7460ef6a32dca5b8df.png"}}]);