"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[6069],{60198:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>p,contentTitle:()=>u,default:()=>v,frontMatter:()=>h,metadata:()=>i,toc:()=>g});const i=JSON.parse('{"id":"general/bootstrap","title":"Bootstrapping","description":"This module is a natural extension of the Hybrid Service\u2013Adapter pattern: it keeps SOs as Services/Adapters and adds a clean boot sequence (one Bootstrapper + Config) so Save, Audio, and Scene systems are initialized, subscribed, and traceable from frame zero.","source":"@site/resources/general/bootstrap.md","sourceDirName":"general","slug":"/general/bootstrap","permalink":"/50033/resources/general/bootstrap","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Hybrid Service-Adapter Architecture with ScriptableObjects","permalink":"/50033/resources/general/hybrid-arch"}}');var a=s(74848),t=s(28453),r=s(72206),o=s(82223),l=(s(53398),s(19894)),d=s(88761),c=(s(89166),s(384));const h={sidebar_position:11},u="Bootstrapping",p={},g=[{value:"Basic Idea",id:"basic-idea",level:3},{value:"Relationship with SOGA (Lab 5)",id:"relationship-with-soga-lab-5",level:3},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"The Bootstrap Protocol",id:"the-bootstrap-protocol",level:2},{value:"Demo Subsystems",id:"demo-subsystems",level:3},{value:"Folder Setup",id:"folder-setup",level:3},{value:"Bootstrapper (Config SO + Runner MB)",id:"bootstrapper-config-so--runner-mb",level:3},{value:"GameBootstrap (Monobehavior Script)",id:"gamebootstrap-monobehavior-script",level:3},{value:"Save system (Channel + Bridge + Registry + ISaveable)",id:"save-system-channel--bridge--registry--isaveable",level:3},{value:"Audio system (Channel + Bridge)",id:"audio-system-channel--bridge",level:3},{value:"Scene System (Channel + Bridge)",id:"scene-system-channel--bridge",level:3},{value:"Minimal UI Triggers (for demo)",id:"minimal-ui-triggers-for-demo",level:3},{value:"Minimal <code>ISaveable</code> demo component",id:"minimal-isaveable-demo-component",level:3},{value:"Auto Register <code>ISaveable</code> Helper demo component",id:"auto-register-isaveable-helper-demo-component",level:3},{value:"The Demo",id:"the-demo",level:2},{value:"Create SO Bridges, Channels, and BootstrapConfig",id:"create-so-bridges-channels-and-bootstrapconfig",level:3},{value:"Create Scenes",id:"create-scenes",level:3},{value:"Running the Demo",id:"running-the-demo",level:3},{value:"Epilogue",id:"epilogue",level:2},{value:"Demo 1: Explicitly drop refs and unload",id:"demo-1-explicitly-drop-refs-and-unload",level:4},{value:"Demo 2: Reproduce the \u201cunsubscribed on scene change\u201d case",id:"demo-2-reproduce-the-unsubscribed-on-scene-change-case",level:4},{value:"So when do Bridge SOs actually <code>OnDisable()</code> naturally?",id:"so-when-do-bridge-sos-actually-ondisable-naturally",level:3},{value:"Example: A simple \u201cscene-scoped bridge\u201d pattern",id:"example-a-simple-scene-scoped-bridge-pattern",level:3},{value:"When should bridges be persistent?",id:"when-should-bridges-be-persistent",level:4},{value:"When should bridges be unloadable?",id:"when-should-bridges-be-unloadable",level:4}];function b(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"bootstrapping",children:"Bootstrapping"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["This module is a ",(0,a.jsx)("span",{class:"orange-bold",children:"natural"})," extension of the ",(0,a.jsx)(n.a,{href:"https://natalieagus.github.io/50033/resources/general/hybrid-arch",children:"Hybrid Service\u2013Adapter pattern"}),": it keeps SOs as Services/Adapters and ",(0,a.jsx)("span",{class:"orange-bold",children:"adds a clean boot sequence"})," (one Bootstrapper + Config) so Save, Audio, and Scene systems are initialized, subscribed, and traceable from frame zero."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Scene/UI (buttons, controllers)\n        \u2502     (raise events)\n        \u25bc\n[ Event Channels (SO) ]  \u2014 decoupled broadcast\n        \u2502     (subscribe at enable)\n        \u25bc\n[ Bridges (SO) = Services/Adapters ]\n        \u2502     (do work: save, audio, scene)\n        \u25b2\n        \u2502  (explicit init)\n[ Bootstrapper Mono ] \u2192 [ BootstrapConfigSO ]\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"With a bootstrapper, we get deterministic startup (no \u201csome SO didn\u2019t enable yet\u201d flakiness), uniform protocol reusable for new systems (Input, Localization, Analytics) and traceable logs from boot \u2192 event \u2192 bridge action."}),"\n",(0,a.jsx)(n.h3,{id:"basic-idea",children:"Basic Idea"}),"\n",(0,a.jsxs)(n.p,{children:["One ",(0,a.jsx)(n.code,{children:"Bootstrapper"})," runs at startup, reads a single ",(0,a.jsx)(n.code,{children:"BootstrapConfigSO"}),", and brings ",(0,a.jsx)("span",{class:"orange-bold",children:"every"})," global system online using the same protocol:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Channel (broadcast requests) \u2192 Bridge (listen and do work) \u2192 Config (wires them all up)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Instead of scattered \u201cmanagers\u201d or hidden statics, each subsystem (Save, Audio, Scene) exposes an event channel and a ScriptableObject bridge that subscribes on enable and performs the action, with clear debug logs the whole way."}),"\n",(0,a.jsx)(n.p,{children:"By the end, you\u2019ll have a one-click boot sequence you can copy to new projects: add a channel, add a bridge, reference both in the config, and the system is live from frame zero."}),"\n",(0,a.jsx)(n.h3,{id:"relationship-with-soga-lab-5",children:"Relationship with SOGA (Lab 5)"}),"\n",(0,a.jsxs)(n.p,{children:["The Bootstrap pattern slashes repetitive wiring ",(0,a.jsx)("span",{class:"orange-bold",children:"for cross-cutting"})," systems (Save, Audio, Sceneloading, etc): instead of sprinkling hundreds of ",(0,a.jsx)(n.code,{children:"GameEventListeners"}),", you raise a channel and a single Bridge SO does the work (Save/Audio/Scene, etc.), giving you ",(0,a.jsx)("span",{class:"orange-bold",children:"deterministic"})," startup and decoupled comms without per-scene listeners."]}),"\n",(0,a.jsx)(n.p,{children:"For the rest, we keep it lean: use code-first subscriptions in controllers for core gameplay (subscribe/unsubscribe in OnEnable/OnDisable), and handle wide fan-out visuals with 1\u20133 routers (scene or prefab-level) that listen to a few topic events (e.g., OnPlayerJump, OnAttack) and fan out to multiple effects."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Prefabize wiring where it\u2019s designer-tuned,"}),"\n",(0,a.jsx)(n.li,{children:"Keep typed C# for logic, and"}),"\n",(0,a.jsx)(n.li,{children:"Reserve inspector hooks for presentation"}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"Rule of thumb",type:"note",children:(0,a.jsx)(n.p,{children:"Global services \u2192 Channel/Bridge, core gameplay \u2192 code subscriptions, broad VFX/UI \u2192 small routers, not a thousand listeners."})}),"\n",(0,a.jsx)(n.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"[GameBootstrap (MonoBehaviour)]\n        \u2502\n        \u25bc\n[BootstrapConfigSO (ScriptableObject asset)]\n        \u2502 initializes (forces deserialize + OnEnable)\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                                                                 \u2502\n        \u25bc                                                                 \u25bc\n [SaveBridgeSO]  listens to  [SaveEventChannelSO]         [AudioBridgeSO] listens to [AudioEventChannelSO]\n        \u2502                     \u25b2                                   \u2502                       \u25b2\n        \u2502 calls               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 UI/Game code raises \u2518                       \u2514\u2500\u2500 UI/Game code raises\n        \u25bc\n  SaveRegistry (static)\n        \u25b2\n   ISaveable implementers\n\n        \u25bc\n [SceneBridgeSO] listens to [SceneEventChannelSO] \u2500\u2500\u25ba uses SceneManager (LoadSceneAsync/UnloadSceneAsync)\n\nDebug logs trace: Bootstrap \u2192 Channel subscriptions \u2192 Button raises \u2192 Bridge actions.\n\n"})}),"\n",(0,a.jsx)(n.h2,{id:"the-bootstrap-protocol",children:"The Bootstrap Protocol"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Event Channel ScriptableObject (per subsystem)"}),": public, typed API that broadcasts requests. UI or gameplay code calls channel methods; ",(0,a.jsx)(n.em,{children:"nothing"})," talks directly to the bridges."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Bridge/Manager ScriptableObject (per subsystem)"}),": subscribes to its channel in ",(0,a.jsx)(n.code,{children:"OnEnable"}),", performs actions when events fire, and unsubscribes in ",(0,a.jsx)(n.code,{children:"OnDisable"}),". This keeps runtime logic centralized and scene-agnostic."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Bootstrap Config SO"}),": holds references to all Bridges and Channels. ",(0,a.jsx)(n.code,{children:"InitializeAll()"})," touches ",(0,a.jsx)(n.em,{children:"each"})," reference to force Unity to deserialize the assets and trigger their ",(0,a.jsx)(n.code,{children:"OnEnable"})," so subscriptions are active before play."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"GameBootstrap MonoBehaviour"}),": a ",(0,a.jsx)("span",{class:"orange-bold",children:"single"})," scene entry point that invokes the config\u2019s ",(0,a.jsx)(n.code,{children:"InitializeAll()"})," in ",(0,a.jsx)(n.code,{children:"Awake()"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["This protocol is the point of \u201cbootstrapping\u201d: one place to ",(0,a.jsx)(n.em,{children:"initialize everything"}),"; no direct cross-references from UI/gameplay to bridges; all calls go through ",(0,a.jsx)("span",{class:"orange-bold",children:"channels"}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"demo-subsystems",children:"Demo Subsystems"}),"\n",(0,a.jsxs)(n.p,{children:["To see the protocol in action, we include ",(0,a.jsx)(n.strong,{children:"three"})," global subsystems:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Save"}),": Demonstrates global state capture/restore with a static ",(0,a.jsx)(n.code,{children:"SaveRegistry"})," and ",(0,a.jsx)(n.code,{children:"ISaveable"}),". Buttons raise save/load on the ",(0,a.jsx)(n.code,{children:"SaveEventChannel"}),", ",(0,a.jsx)(n.code,{children:"SaveBridge"})," invokes ",(0,a.jsx)(n.code,{children:"SaveRegistry"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Audio"}),": Demonstrates a persistent audio root with two ",(0,a.jsx)(n.code,{children:"AudioSources"})," (SFX/BGM). Buttons raise SFX/BGM/Stop on ",(0,a.jsx)(n.code,{children:"AudioEventChannel"}),", ",(0,a.jsx)(n.code,{children:"AudioBridge"})," plays/stops clips. ",(0,a.jsx)(n.code,{children:"DontDestroyOnLoad"})," ensures continuity across scenes."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Scene"}),": Demonstrates scene transitions. Buttons raise ",(0,a.jsx)(n.code,{children:"load"}),"/",(0,a.jsx)(n.code,{children:"unload"})," on ",(0,a.jsx)(n.code,{children:"SceneEventChannel"}),", ",(0,a.jsx)(n.code,{children:"SceneBridge"})," calls ",(0,a.jsx)(n.code,{children:"SceneManager.*"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"folder-setup",children:"Folder Setup"}),"\n",(0,a.jsx)(n.p,{children:"Here's a minimal folder setup for this demo to work:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Assets/\n \u251c\u2500\u2500 Scripts/\n \u2502   \u251c\u2500\u2500 Bootstrap/\n \u2502   \u2502   \u251c\u2500\u2500 GameBootstrap.cs\n \u2502   \u2502   \u2514\u2500\u2500 BootstrapConfigSO.cs\n \u2502   \u251c\u2500\u2500 Systems/\n \u2502   \u2502   \u251c\u2500\u2500 Save/\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 SaveEventChannelSO.cs\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 SaveBridgeSO.cs\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 SaveRegistry.cs\n \u2502   \u2502   \u251c\u2500\u2500 Audio/\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 AudioEventChannelSO.cs\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 AudioBridgeSO.cs\n \u2502   \u2502   \u2514\u2500\u2500 Scene/\n \u2502   \u2502       \u251c\u2500\u2500 SceneEventChannelSO.cs\n \u2502   \u2502       \u2514\u2500\u2500 SceneBridgeSO.cs\n \u251c\u2500\u2500 Game/\n \u2502   \u2514\u2500\u2500 BootstrapConfig.asset\n \u251c\u2500\u2500 Events/\n \u2502   \u251c\u2500\u2500 SaveEventChannel.asset\n \u2502   \u251c\u2500\u2500 AudioEventChannel.asset\n \u2502   \u2514\u2500\u2500 SceneEventChannel.asset\n \u251c\u2500\u2500 Scenes/\n \u2502   \u251c\u2500\u2500 Scene_Main.unity\n \u2502   \u2514\u2500\u2500 Scene_Level1.unity\n \u2514\u2500\u2500 UI/\n     \u251c\u2500\u2500 SaveButtonUI.cs\n     \u251c\u2500\u2500 AudioButtonUI.cs\n     \u2514\u2500\u2500 SceneButtonUI.cs\n"})}),"\n",(0,a.jsx)(n.h3,{id:"bootstrapper-config-so--runner-mb",children:"Bootstrapper (Config SO + Runner MB)"}),"\n",(0,a.jsx)(n.p,{children:"This is a single ScriptableObject that holds references to all Bridges and Event Channels."}),"\n",(0,a.jsxs)(n.p,{children:["It acts as the one source of truth for global subsystems. The scene-level ",(0,a.jsx)(n.code,{children:"GameBootstrap"})," (MonoBehaviour) calls ",(0,a.jsx)(n.code,{children:"bootstrapConfig.InitializeAll()"})," in ",(0,a.jsx)(n.code,{children:"Awake()"})," to:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Force asset deserialization (so Bridges/Channels are \u201calive\u201d and ",(0,a.jsx)(n.code,{children:"OnEnable()"})," subscriptions attach),","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Assigning SOs in the Inspector only stores references. It doesn\u2019t guarantee when they\u2019re \u201clive\u201d for this play session, nor that any runtime-only setup has happened in the right order."}),"\n",(0,a.jsxs)(n.li,{children:["This ",(0,a.jsx)(n.code,{children:"BootstrapConfigSO.InitializeAll()"})," call gives us a deterministic, one-shot kickoff at runtime."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Invoke any runtime-only initialization for systems that need it (e.g., Audio creating an ",(0,a.jsx)(n.code,{children:"AudioSource"})," GameObject)."]}),"\n"]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(o.A,{value:"1",label:"BootstrapConfigSO.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'// Assets/Scripts/Bootstrap/BootstrapConfigSO.cs\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Bootstrap Config")]\npublic class BootstrapConfigSO : ScriptableObject\n{\n    [Header("Subsystem Bridges")]\n    [SerializeField] private SaveBridgeSO saveBridge;\n    [SerializeField] private AudioBridgeSO audioBridge;\n    [SerializeField] private SceneBridgeSO sceneBridge;\n\n    [Header("Event Channels")]\n    [SerializeField] private SaveEventChannelSO saveChannel;\n    [SerializeField] private AudioEventChannelSO audioChannel;\n    [SerializeField] private SceneEventChannelSO sceneChannel;\n\npublic void InitializeAll()\n{\n    // force deserialize\n    _ = saveBridge; _ = audioBridge; _ = sceneBridge;\n    _ = saveChannel; _ = audioChannel; _ = sceneChannel;\n\n    // runtime inits for bridges that need it\n    if (audioBridge is IRuntimeInitializable r1) r1.RuntimeInit();\n    if (saveBridge  is IRuntimeInitializable r2) r2.RuntimeInit();   // currently no-op (not implemented)\n    if (sceneBridge is IRuntimeInitializable r3) r3.RuntimeInit();   // currently no-op (not implemented)\n\n    Debug.Log("[BootstrapConfigSO] Initialized Save, Audio, and Scene systems");\n}\n\n}\n'})})}),(0,a.jsx)(o.A,{value:"2",label:"IRuntimeInitializable.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public interface IRuntimeInitializable\n{\n    void RuntimeInit();\n}\n"})})})]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["AudioBridgeSO implements ",(0,a.jsx)(n.code,{children:"IRuntimeInitializable"})," (spawns its ",(0,a.jsx)(n.code,{children:"[AudioBridge] GO"}),").\n",(0,a.jsx)(n.code,{children:"SaveBridgeSO"})," and ",(0,a.jsx)(n.code,{children:"SceneBridgeSO"})," don\u2019t implement it (no runtime objects needed)."]})}),"\n",(0,a.jsx)(n.h3,{id:"gamebootstrap-monobehavior-script",children:"GameBootstrap (Monobehavior Script)"}),"\n",(0,a.jsxs)(n.p,{children:["Place a ",(0,a.jsx)(n.code,{children:"GameBootstrap"})," in ",(0,a.jsx)(n.code,{children:"Scene_Main"})," and assign ",(0,a.jsx)(n.code,{children:"BootstrapConfig.asset"}),". The purpose of this script is simply to initialize the bridges and channels in the project."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="GameBootstrap.cs"',children:'using UnityEngine;\n\npublic class GameBootstrap : MonoBehaviour\n{\n    [SerializeField] private BootstrapConfigSO bootstrapConfig;\n\n    private void Awake()\n    {\n        Debug.Log("[GameBootstrap] Starting initialization");\n        bootstrapConfig.InitializeAll();\n        Debug.Log("[GameBootstrap] Bootstrap complete");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"save-system-channel--bridge--registry--isaveable",children:"Save system (Channel + Bridge + Registry + ISaveable)"}),"\n",(0,a.jsxs)(n.p,{children:["This system is a ",(0,a.jsx)("span",{class:"orange-bold",children:"centralized"})," capture/restore surface area for all saveable objects. Objects opt in by implementing ",(0,a.jsx)(n.code,{children:"ISaveable"})," and calling ",(0,a.jsx)(n.code,{children:"SaveRegistry.Register/Unregister"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.em,{children:"Bridge"})," wires the channel to registry calls."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(o.A,{value:"1",label:"SaveEventChannelSO.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System;\n\n[CreateAssetMenu(menuName = "Events/Save Event Channel")]\npublic class SaveEventChannelSO : ScriptableObject\n{\npublic event Action OnSaveRequested;\npublic event Action OnLoadRequested;\n\n    public void RaiseSave()\n    {\n        Debug.Log("[SaveEventChannelSO] Save requested");\n        OnSaveRequested?.Invoke();\n    }\n\n    public void RaiseLoad()\n    {\n        Debug.Log("[SaveEventChannelSO] Load requested");\n        OnLoadRequested?.Invoke();\n    }\n\n}\n\n'})})}),(0,a.jsx)(o.A,{value:"2",label:"SaveBridgeSO.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'// SaveBridgeSO.cs\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Save Bridge")]\npublic class SaveBridgeSO : ScriptableObject\n{\n    [SerializeField] private SaveEventChannelSO saveChannel;\n\n    private void OnEnable()\n    {\n        saveChannel.OnSaveRequested += OnSaveRequested;  // instance methods\n        saveChannel.OnLoadRequested += OnLoadRequested;\n        Debug.Log("[SaveBridgeSO] Subscribed to save/load events");\n    }\n\n    private void OnDisable()\n    {\n        saveChannel.OnSaveRequested -= OnSaveRequested;\n        saveChannel.OnLoadRequested -= OnLoadRequested;\n        Debug.Log("[SaveBridgeSO] Unsubscribed");\n    }\n\n    // we subscribe with instance methods (from this SO) and not static method from SaveRegistry directly\n    private void OnSaveRequested() => SaveRegistry.SaveAll();\n    private void OnLoadRequested() => SaveRegistry.LoadAll();\n}\n\n'})})}),(0,a.jsx)(o.A,{value:"3",label:"SaveRegistry.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System.Collections.Generic;\nusing System.IO;\n\npublic static class SaveRegistry\n{\n    private static readonly HashSet<ISaveable> saveables = new();\n    private static string PathName => Path.Combine(Application.persistentDataPath, "save.json");\n\n    public static void Register(ISaveable s)\n    {\n        saveables.Add(s);\n        Debug.Log($"[SaveRegistry] Registered {s.GetUniqueID()}");\n    }\n\n    public static void Unregister(ISaveable s)\n    {\n        saveables.Remove(s);\n        Debug.Log($"[SaveRegistry] Unregistered {s.GetUniqueID()}");\n    }\n\n    public static void SaveAll()\n    {\n        var state = new Dictionary<string, object>();\n        foreach (var s in saveables)\n        {\n            state[s.GetUniqueID()] = s.CaptureState();\n            Debug.Log($"[SaveRegistry] Captured {s.GetUniqueID()}");\n        }\n        File.WriteAllText(PathName, JsonUtility.ToJson(new Wrapper(state)));\n        Debug.Log($"[SaveRegistry] Wrote file to {PathName}");\n    }\n\n    public static void LoadAll()\n    {\n        if (!File.Exists(PathName))\n        {\n            Debug.Log("[SaveRegistry] No save file found");\n            return;\n        }\n        var wrapper = JsonUtility.FromJson<Wrapper>(File.ReadAllText(PathName));\n        foreach (var s in saveables)\n        {\n            if (wrapper.data.TryGetValue(s.GetUniqueID(), out var d))\n            {\n                s.RestoreState(d);\n                Debug.Log($"[SaveRegistry] Restored {s.GetUniqueID()}");\n            }\n        }\n    }\n\n    [System.Serializable]\n    private class Wrapper { public Dictionary<string, object> data; public Wrapper(Dictionary<string, object> d){data=d;} }\n}\n'})})}),(0,a.jsx)(o.A,{value:"4",label:"ISaveable.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="ISaveable.cs"',children:"public interface ISaveable\n{\n    string GetUniqueID();\n    object CaptureState();\n    void RestoreState(object state);\n}\n"})})})]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsxs)(l.A,{title:"Deep Dive: Instance vs Static Subscription to SO Events (What to Use, and Why)",children:[(0,a.jsxs)(n.p,{children:["With ScriptableObject (SO) event channels, prefer instance-method subscriptions from your Bridges/Managers, ",(0,a.jsx)("span",{class:"red-bold",children:"not"})," static method groups."]}),(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)("span",{class:"orange-bold",children:"instance subscription"})," gives the event delegate a real target object, which keeps the Bridge asset \u201calive\u201d across scene changes. Static subscriptions have no target; if nothing else holds a strong reference to the SO, ",(0,a.jsx)(n.em,{children:"Unity may unload it when you load a new scene"}),", and your callbacks ",(0,a.jsx)("span",{class:"orange-bold",children:"quietly stop firing"}),"."]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"In practice"}),": subscribe inside the SO\u2019s OnEnable() with instance methods, and unsubscribe in OnDisable(). Keep any heavy, scene-object work in a separate RuntimeInit() that runs only during play."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="Bad example"',children:"// Inside a Bridge SO's OnEnable()\nchannel.OnSomething += SomeStaticService.DoIt;   // static => no target = fragile lifetime\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="Good example"',children:'using UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Bridge")]\npublic class BridgeSO : ScriptableObject\n{\n    [SerializeField] private EventChannelSO channel;\n\n    private void OnEnable()\n    {\n        channel.OnSomething += OnSomething;   // instance method\n        Debug.Log("[BridgeSO] Subscribed");\n    }\n\n    private void OnDisable()\n    {\n        channel.OnSomething -= OnSomething;\n        Debug.Log("[BridgeSO] Unsubscribed");\n    }\n\n    private void OnSomething() => SomeService.DoIt(); // forward to your service/registry\n}\n'})}),(0,a.jsxs)(n.p,{children:["If you ",(0,a.jsx)(n.em,{children:"truly"})," need static subscriptions (e.g., calling a static registry directly), then also keep a ",(0,a.jsx)("span",{class:"orange-bold",children:"strong"})," reference to the Bridge/Channel assets for the whole run\u2014otherwise Unity can unload them on scene transitions. One tidy way is a tiny persistent holder created at bootstrap:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="CoreRefsHolder.cs"',children:"// CoreRefsHolder.cs\nusing UnityEngine;\n\npublic class CoreRefsHolder : MonoBehaviour\n{\n    public ScriptableObject[] keepAlive; // assign bridges/channels at runtime\n}\n"})}),(0,a.jsxs)(n.p,{children:["Then in the ",(0,a.jsx)(n.code,{children:"BootstrapConfigSO.InitializeAll()"}),":"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="BootstrapConfigSO.InitializeAll"',children:'\nif (Application.isPlaying)\n{\n    var core = GameObject.Find("[CoreRoot]") ?? new GameObject("[CoreRoot]");\n    Object.DontDestroyOnLoad(core);\n    var holder = core.GetComponent<CoreRefsHolder>() ?? core.AddComponent<CoreRefsHolder>();\n    holder.keepAlive = new ScriptableObject[] { bridgeA, bridgeB, channelA, channelB }; // etc.\n}\n'})}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The rule of thumb:"})," subscribe with instance methods for predictable lifetime. Use static only when you also ensure those assets are strongly referenced (e.g., via a persistent holder). This keeps your SO event system stable across scene loads while preserving clean separation between UI (raises events), channels (broadcast), and bridges (handle)."]})]}),"\n",(0,a.jsx)(n.h3,{id:"audio-system-channel--bridge",children:"Audio system (Channel + Bridge)"}),"\n",(0,a.jsxs)(n.p,{children:["This audio system is a persistent, scene-independent audio management. We always have SFX/BGM ready, no matter ",(0,a.jsx)(n.em,{children:"which"})," scene is active."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"AudioBridgeSO"})," ",(0,a.jsx)(n.strong,{children:"must"})," own AudioSources, which exist on GameObjects and needs a small runtime root. So we should generalise this with an interface: ",(0,a.jsx)(n.code,{children:"IRuntimeInitializable"}),"."]})}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(o.A,{value:"1",label:"AudioEventChannelSO.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System;\n\n[CreateAssetMenu(menuName = "Events/Audio Event Channel")]\npublic class AudioEventChannelSO : ScriptableObject, IRuntimeInitializable\n{\n    public event Action<AudioClip> OnSFXRequested;\n    public event Action<AudioClip> OnBGMRequested;\n    public event Action OnStopBGMRequested;\n\n    public void RaiseSFX(AudioClip clip)\n    {\n        Debug.Log($"[AudioEventChannelSO] Play SFX: {clip?.name}");\n        OnSFXRequested?.Invoke(clip);\n    }\n\n    public void RaiseBGM(AudioClip clip)\n    {\n        Debug.Log($"[AudioEventChannelSO] Play BGM: {clip?.name}");\n        OnBGMRequested?.Invoke(clip);\n    }\n\n    public void RaiseStopBGM()\n    {\n        Debug.Log("[AudioEventChannelSO] Stop BGM");\n        OnStopBGMRequested?.Invoke();\n    }\n}\n'})})}),(0,a.jsx)(o.A,{value:"2",label:"AudioBridgeSO.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'// Assets/Scripts/Systems/Audio/AudioBridgeSO.cs\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Audio Bridge")]\npublic class AudioBridgeSO : ScriptableObject\n{\n    [SerializeField] private AudioEventChannelSO audioChannel;\n\n    // runtime-only fields\n    private GameObject audioRoot;\n    private AudioSource sfxSource;\n    private AudioSource bgmSource;\n\n    private void OnEnable()\n    {\n        // Safe in edit mode: subscribing to SO events doesn\u2019t touch the scene\n        audioChannel.OnSFXRequested += PlaySFX;\n        audioChannel.OnBGMRequested += PlayBGM;\n        audioChannel.OnStopBGMRequested += StopBGM;\n        Debug.Log("[AudioBridgeSO] Subscribed to audio events");\n    }\n\n    private void OnDisable()\n    {\n        audioChannel.OnSFXRequested -= PlaySFX;\n        audioChannel.OnBGMRequested -= PlayBGM;\n        audioChannel.OnStopBGMRequested -= StopBGM;\n        Debug.Log("[AudioBridgeSO] Unsubscribed");\n    }\n\n    // Call this from the bootstrapper during play\n    public void RuntimeInit()\n    {\n        if (!Application.isPlaying) return;        // guard edit mode\n        if (audioRoot != null) return;             // already created\n\n        audioRoot = new GameObject("[AudioBridge]");\n        Object.DontDestroyOnLoad(audioRoot);\n        sfxSource = audioRoot.AddComponent<AudioSource>();\n        bgmSource = audioRoot.AddComponent<AudioSource>();\n        bgmSource.loop = true;\n\n        Debug.Log("[AudioBridgeSO] Runtime audio root created");\n    }\n\n    private void PlaySFX(AudioClip clip)\n    {\n        if (clip == null || sfxSource == null) return;\n        sfxSource.PlayOneShot(clip);\n        Debug.Log($"[AudioBridgeSO] Playing SFX: {clip.name}");\n    }\n\n    private void PlayBGM(AudioClip clip)\n    {\n        if (clip == null || bgmSource == null) return;\n        bgmSource.clip = clip;\n        bgmSource.Play();\n        Debug.Log($"[AudioBridgeSO] Playing BGM: {clip.name}");\n    }\n\n    private void StopBGM()\n    {\n        if (bgmSource == null) return;\n        bgmSource.Stop();\n        Debug.Log("[AudioBridgeSO] Stopped BGM");\n    }\n}\n\n'})})})]}),"\n",(0,a.jsx)(n.h3,{id:"scene-system-channel--bridge",children:"Scene System (Channel + Bridge)"}),"\n",(0,a.jsxs)(n.p,{children:["This scene system is a centralized scene transitions so gameplay/UI simply request ",(0,a.jsx)(n.code,{children:"loads"}),"/",(0,a.jsx)(n.code,{children:"unloads"})," ",(0,a.jsx)(n.em,{children:"without"})," knowing how scenes are managed."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(o.A,{value:"1",label:"SceneEventChannelSO.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System;\n\n[CreateAssetMenu(menuName = "Events/Scene Event Channel")]\npublic class SceneEventChannelSO : ScriptableObject\n{\n    public event Action<string> OnSceneLoadRequested;\n    public event Action<string> OnSceneUnloadRequested;\n\n    public void RaiseLoad(string sceneName)\n    {\n        Debug.Log($"[SceneEventChannelSO] Load requested: {sceneName}");\n        OnSceneLoadRequested?.Invoke(sceneName);\n    }\n\n    public void RaiseUnload(string sceneName)\n    {\n        Debug.Log($"[SceneEventChannelSO] Unload requested: {sceneName}");\n        OnSceneUnloadRequested?.Invoke(sceneName);\n    }\n}\n\n'})})}),(0,a.jsx)(o.A,{value:"2",label:"SceneBridgeSO.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing UnityEngine.SceneManagement;\n\n[CreateAssetMenu(menuName = "Game/Scene Bridge")]\npublic class SceneBridgeSO : ScriptableObject\n{\n    [SerializeField] private SceneEventChannelSO sceneChannel;\n\n    private void OnEnable()\n    {\n        sceneChannel.OnSceneLoadRequested += LoadScene;\n        sceneChannel.OnSceneUnloadRequested += UnloadScene;\n        Debug.Log("[SceneBridgeSO] Subscribed to scene events");\n    }\n\n    private void OnDisable()\n    {\n        sceneChannel.OnSceneLoadRequested -= LoadScene;\n        sceneChannel.OnSceneUnloadRequested -= UnloadScene;\n        Debug.Log("[SceneBridgeSO] Unsubscribed");\n    }\n\n    private void LoadScene(string sceneName)\n    {\n        Debug.Log($"[SceneBridgeSO] Begin loading scene \'{sceneName}\'");\n        SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Single); // edit this accordingly if you are doing Additive\n    }\n\n    private void UnloadScene(string sceneName)\n    {\n        Debug.Log($"[SceneBridgeSO] Begin unloading scene \'{sceneName}\'");\n        SceneManager.UnloadSceneAsync(sceneName);\n    }\n}\n\n\n'})})})]}),"\n",(0,a.jsx)(n.h3,{id:"minimal-ui-triggers-for-demo",children:"Minimal UI Triggers (for demo)"}),"\n",(0,a.jsxs)(n.p,{children:["These are lightweight ",(0,a.jsx)(n.code,{children:"MonoBehaviours"})," to wire to Unity UI Buttons and call the channels only."]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(o.A,{value:"1",label:"SaveButtonUI.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"using UnityEngine;\n\npublic class SaveButtonUI : MonoBehaviour\n{\n    [SerializeField] private SaveEventChannelSO saveChannel;\n\n    public void DoSave() => saveChannel.RaiseSave();\n    public void DoLoad() => saveChannel.RaiseLoad();\n}\n\n"})})}),(0,a.jsx)(o.A,{value:"2",label:"AudioButtonUI.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"using UnityEngine;\n\npublic class AudioButtonUI : MonoBehaviour\n{\n    [SerializeField] private AudioEventChannelSO audioChannel;\n    [SerializeField] private AudioClip sfxClip;\n    [SerializeField] private AudioClip bgmClip;\n\n    public void PlaySFX() => audioChannel.RaiseSFX(sfxClip);\n    public void PlayBGM() => audioChannel.RaiseBGM(bgmClip);\n    public void StopBGM() => audioChannel.RaiseStopBGM();\n}\n\n"})})}),(0,a.jsx)(o.A,{value:"empty",label:"SceneButtonUI.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\n\npublic class SceneButtonUI : MonoBehaviour\n{\n    [SerializeField] private SceneEventChannelSO sceneChannel;\n    [SerializeField] private string sceneToLoad = "Scene_Level1";\n    [SerializeField] private string sceneToUnload = "Scene_Level1";\n\n    public void LoadLevel() => sceneChannel.RaiseLoad(sceneToLoad);\n    public void UnloadLevel() => sceneChannel.RaiseUnload(sceneToUnload);\n}\n'})})})]}),"\n",(0,a.jsxs)(n.h3,{id:"minimal-isaveable-demo-component",children:["Minimal ",(0,a.jsx)(n.code,{children:"ISaveable"})," demo component"]}),"\n",(0,a.jsxs)(n.p,{children:["The purpose of this component is to show a concrete object participating in the global Save subsystem. It self-registers so ",(0,a.jsx)(n.code,{children:"SaveRegistry.SaveAll/LoadAll"})," actually captures and restores something visible."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="PlayerHealthSaveable.cs"',children:'// Assets/Scripts/Systems/Save/Demo/PlayerHealthSaveable.cs\nusing UnityEngine;\n\npublic class PlayerHealthSaveable : MonoBehaviour, ISaveable\n{\n    [SerializeField] private string uniqueId = "Player01"; // ensure uniqueness if you have multiple\n    [SerializeField] private int maxHealth = 100;\n    [SerializeField] private int currentHealth = 100;\n\n    private void OnEnable()\n    {\n        SaveRegistry.Register(this);\n        Debug.Log($"[PlayerHealthSaveable] Registered {uniqueId} ({currentHealth}/{maxHealth})");\n    }\n\n    private void OnDisable()\n    {\n        SaveRegistry.Unregister(this);\n        Debug.Log($"[PlayerHealthSaveable] Unregistered {uniqueId}");\n    }\n\n    public string GetUniqueID() => uniqueId;\n\n    public object CaptureState()\n    {\n        var state = new State { max = maxHealth, cur = currentHealth, x = transform.position.x, y = transform.position.y, z = transform.position.z };\n        Debug.Log($"[PlayerHealthSaveable] Capture {uniqueId}: {currentHealth}/{maxHealth} @ {transform.position}");\n        return state;\n    }\n\n    public void RestoreState(object state)\n    {\n        if (state is State s)\n        {\n            maxHealth = s.max;\n            currentHealth = s.cur;\n            transform.position = new Vector3(s.x, s.y, s.z);\n            Debug.Log($"[PlayerHealthSaveable] Restore {uniqueId}: {currentHealth}/{maxHealth} @ {transform.position}");\n        }\n        else\n        {\n            Debug.LogWarning($"[PlayerHealthSaveable] Bad state for {uniqueId}");\n        }\n    }\n\n    [System.Serializable]\n    private struct State { public int max; public int cur; public float x, y, z; }\n\n    // quick demo helpers so you can change state in play mode:\n    [ContextMenu("Damage 10")] private void Damage10() { currentHealth = Mathf.Max(0, currentHealth - 10); Debug.Log($"[PlayerHealthSaveable] {uniqueId} took 10 \u2192 {currentHealth}"); }\n    [ContextMenu("Heal 10")]   private void Heal10()   { currentHealth = Mathf.Min(maxHealth, currentHealth + 10); Debug.Log($"[PlayerHealthSaveable] {uniqueId} healed 10 \u2192 {currentHealth}"); }\n    [ContextMenu("Nudge +1x")] private void Nudge()    { transform.position += Vector3.right; Debug.Log($"[PlayerHealthSaveable] {uniqueId} moved \u2192 {transform.position}"); }\n}\n\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Add this component to a GameObject in ",(0,a.jsx)(n.code,{children:"Scene_Main"})," and/or ",(0,a.jsx)(n.code,{children:"Scene_Level1"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Use the component\u2019s ",(0,a.jsx)(n.em,{children:"context menu items"})," during Play (or expose real gameplay changes)."]}),"\n",(0,a.jsx)(n.li,{children:"Click your Save/Load UI buttons to see capture/restore logs and effects."}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"auto-register-isaveable-helper-demo-component",children:["Auto Register ",(0,a.jsx)(n.code,{children:"ISaveable"})," Helper demo component"]}),"\n",(0,a.jsxs)(n.p,{children:["If you prefer to keep your domain components clean and centralize registration, use a tiny helper that auto-registers any ",(0,a.jsx)(n.code,{children:"ISaveable"})," on the same GameObject as such:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="SaveableAutoRegister.cs"',children:'\nusing UnityEngine;\n\npublic class SaveableAutoRegister : MonoBehaviour, ISaveable\n{\n    [SerializeField] private MonoBehaviour targetComponent; // must implement ISaveable\n    private ISaveable target;\n\n    private void Awake()\n    {\n        if (targetComponent is ISaveable s) target = s;\n        else\n        {\n            // fall back to first ISaveable on this GameObject (optional convenience)\n            target = GetComponent<ISaveable>();\n            if (target == (ISaveable) this) target = null; // avoid self if only this component exists\n        }\n\n        if (target == null)\n            Debug.LogError("[SaveableAutoRegister] No valid ISaveable target found on this GameObject.");\n    }\n\n    private void OnEnable()\n    {\n        if (target != null) SaveRegistry.Register(this);\n    }\n\n    private void OnDisable()\n    {\n        if (target != null) SaveRegistry.Unregister(this);\n    }\n\n    public string GetUniqueID() => target?.GetUniqueID() ?? "[null]";\n    public object CaptureState() => target?.CaptureState();\n    public void RestoreState(object state) => target?.RestoreState(state);\n}\n\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"Usage:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Put your domain logic in a plain component that implements ",(0,a.jsx)(n.code,{children:"ISaveable"})," (e.g., ",(0,a.jsx)(n.code,{children:"ChestSaveable"}),", ",(0,a.jsx)(n.code,{children:"QuestFlagSaveable"}),", ",(0,a.jsx)(n.code,{children:"PlayerHeathSaveable"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:["Add ",(0,a.jsx)(n.code,{children:"SaveableAutoRegister"})," to the same GameObject and ",(0,a.jsx)(n.strong,{children:"assign"})," targetComponent to that domain component."]}),"\n",(0,a.jsxs)(n.li,{children:["This ",(0,a.jsx)(n.strong,{children:"standardizes"})," registration/unregistration without repeating boilerplate in every saveable script."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For instance, we have this code with no registration inside:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="ChestSaveable.cs"',children:'// Assets/Scripts/Systems/Save/Demo/ChestSaveable.cs\nusing UnityEngine;\n\npublic class ChestSaveable : MonoBehaviour, ISaveable\n{\n    [SerializeField] private string uniqueId = "Chest_A";\n    [SerializeField] private bool isOpen;\n    [SerializeField] private Vector3 closedOffset = Vector3.zero;\n    [SerializeField] private Vector3 openOffset = new Vector3(0, 0.5f, 0);\n\n    public string GetUniqueID() => uniqueId;\n\n    public object CaptureState()\n    {\n        return new State { open = isOpen, x = transform.position.x, y = transform.position.y, z = transform.position.z };\n    }\n\n    public void RestoreState(object state)\n    {\n        if (state is State s)\n        {\n            isOpen = s.open;\n            transform.position = new Vector3(s.x, s.y, s.z);\n        }\n    }\n\n    [ContextMenu("Toggle Open/Close")]\n    private void Toggle()\n    {\n        isOpen = !isOpen;\n        transform.position += isOpen ? openOffset : -openOffset;\n    }\n\n    [System.Serializable]\n    private struct State { public bool open; public float x, y, z; }\n}\n\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In ",(0,a.jsx)(n.code,{children:"SaveableAutoRegister"}),", set ",(0,a.jsx)(n.code,{children:"targetComponent"})," to be that ",(0,a.jsx)(n.code,{children:"ChestSaveable"})," instance (or leave blank to auto-pick the first ISaveable on the GameObject)."]}),"\n",(0,a.jsx)(n.h2,{id:"the-demo",children:"The Demo"}),"\n",(0,a.jsx)(n.h3,{id:"create-so-bridges-channels-and-bootstrapconfig",children:"Create SO Bridges, Channels, and BootstrapConfig"}),"\n",(0,a.jsx)(n.p,{children:"Create three Event Channel assets in Assets/Events:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"SaveEventChannel.asset"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"AudioEventChannel.asset"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"SceneEventChannel.asset"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Create three Bridge assets:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SaveBridge.asset"})," and assign ",(0,a.jsx)(n.code,{children:"SaveEventChannel"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"AudioBridge.asset"})," and assign ",(0,a.jsx)(n.code,{children:"AudioEventChannel"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SceneBridge.asset"})," and assign ",(0,a.jsx)(n.code,{children:"SceneEventChannel"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Create ",(0,a.jsx)(n.code,{children:"Assets/Game/BootstrapConfig.asset"})," and assign:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Bridges"}),": SaveBridge, AudioBridge, SceneBridge"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Channels"}),": SaveEventChannel, AudioEventChannel, SceneEventChannel"]}),"\n"]}),"\n",(0,a.jsx)(d.A,{path:s(43524).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.h3,{id:"create-scenes",children:"Create Scenes"}),"\n",(0,a.jsx)(n.p,{children:"Create at least two scenes, e.g: Main and Level 1. Here's one ugly but functional setup:"}),"\n",(0,a.jsx)(d.A,{path:s(77397).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(d.A,{path:s(66866).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.p,{children:"We made the button groups a prefab (this is like a HUD in the game), and both scenes have the same Player and Chest prefab."}),"\n",(0,a.jsx)(n.p,{children:"Attach the GameBoostrap script to GameBoostrap empty gameobject. This will initialize the config upon run."}),"\n",(0,a.jsx)(n.p,{children:"Then for each UI group, attach the corresponding Button UI script:"}),"\n",(0,a.jsx)(d.A,{path:s(73534).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.p,{children:"And set the callbacks accordingly:"}),"\n",(0,a.jsx)(d.A,{path:s(36322).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.p,{children:"Do the same for scene load button, audio-related buttons, as well as load."}),"\n",(0,a.jsx)(n.p,{children:"For the Player, attach the PlayerHealtSaveable component:"}),"\n",(0,a.jsx)(d.A,{path:s(36748).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.p,{children:'Whereas for the "chest", try using the AutoRegister component:'}),"\n",(0,a.jsx)(d.A,{path:s(98383).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.p,{children:"Finally, dont forget to add both scenes until the Build Profiles, otherwise scene transition wont work:"}),"\n",(0,a.jsx)(d.A,{path:s(21664).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.h3,{id:"running-the-demo",children:"Running the Demo"}),"\n",(0,a.jsxs)(n.p,{children:["Upon ",(0,a.jsx)(n.code,{children:"Play"}),", you should see the bootstrap system works: all bridges subscribe to the events, player and chest registered to SaveRegistry, AudioBridge is initialized and runtime AudioRoot is created."]}),"\n",(0,a.jsx)(d.A,{path:s(14048).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.p,{children:"When you load the another level, the save registry is updated based on which object is present at this level:"}),"\n",(0,a.jsx)(d.A,{path:s(98052).A,widthPercentage:"100%"}),"\n",(0,a.jsx)(n.admonition,{title:"test",type:"note",children:(0,a.jsx)(n.p,{children:"You can try adding other chests like Chest_B, etc and see how the save system handles this"})}),"\n",(0,a.jsx)(n.p,{children:"All systems are live in the second scene. There's no need to set them up. There's only one Bootstrapper needed, which is in the main scene."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Apart from AudioSystem (which requires AudioSource), none of the system requires persistent object under ",(0,a.jsx)(n.code,{children:"DontDestroyOnLoad"})]}),"\n",(0,a.jsx)(n.li,{children:"Each is handled dynamically via the BridgeSOs"}),"\n",(0,a.jsxs)(n.li,{children:["The SO will be disabled ",(0,a.jsx)(n.em,{children:"if there's no more reference to it"})," anymore in the following scene."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Here's a full demo recording of the Bootstrap system in action:"}),"\n",(0,a.jsx)(c.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/bootstrap.mov",widthPercentage:"100%"}),"\n",(0,a.jsx)(n.h2,{id:"epilogue",children:"Epilogue"}),"\n",(0,a.jsxs)(n.p,{children:["In this demo, we never really see ",(0,a.jsx)(n.code,{children:"OnDisable"})," being called on the bridges."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"OnDisable()"})," on a ScriptableObject runs whenever Unity ",(0,a.jsx)(n.em,{children:"unloads"})," that SO instance: exiting Play Mode (domain reload on), assembly reload/recompile, asset unload (because no strong references), addressable/references released, or an explicit unload call. In our current setup, we keep Bridges referenced for the ",(0,a.jsx)("span",{class:"orange-bold",children:"whole"})," session (instance-event subscriptions + optional keep-alive holder), so they rarely unload mid-game\u2014hence you don\u2019t see ",(0,a.jsx)(n.code,{children:"OnDisable()"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Below are two small, controlled demos we can add to ",(0,a.jsx)(n.strong,{children:"force"})," an SO to unload and watch ",(0,a.jsx)(n.code,{children:"OnDisable()"})," fire."]}),"\n",(0,a.jsx)(n.h4,{id:"demo-1-explicitly-drop-refs-and-unload",children:"Demo 1: Explicitly drop refs and unload"}),"\n",(0,a.jsxs)(n.p,{children:["This creates a tiny dev tool that clears the persistent references and calls ",(0,a.jsx)(n.code,{children:"Resources.UnloadUnusedAssets()"}),". With no strong refs left, Unity unloads the Bridge and you\u2019ll see its ",(0,a.jsx)(n.code,{children:"OnDisable()"})," log."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Assets/Scripts/Dev/DemoUnloadSO.cs\nusing UnityEngine;\nusing System.Collections;\n\npublic class DemoUnloadSO : MonoBehaviour\n{\n    [SerializeField] private ScriptableObject[] refs; // assign the Bridges/Channels you want to unload\n    [SerializeField] private CoreRefsHolder holder;   // the keep-alive component you created at bootstrap (optional)\n\n    [ContextMenu("Drop Refs And Unload")]\n    private void DropRefsAndUnload()\n    {\n        // 1) sever your own references\n        refs = null;\n\n        // 2) sever the keep-alive references, if you use CoreRefsHolder\n        if (holder != null) holder.keepAlive = null;\n\n        // 3) kick the GC and unload unused assets (SO OnDisable() should fire now)\n        StartCoroutine(UnloadSoon());\n    }\n\n    private IEnumerator UnloadSoon()\n    {\n        System.GC.Collect();\n        yield return null; // let a frame pass so references truly go dead\n        var op = Resources.UnloadUnusedAssets();\n        yield return op;\n        Debug.Log("[DemoUnloadSO] UnloadUnusedAssets completed");\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Put this on an empty GameObject in your scene. Assign the ",(0,a.jsx)(n.code,{children:"SaveBridgeSO"})," (and/or others) into ",(0,a.jsx)(n.code,{children:"refs"}),", and assign your ",(0,a.jsx)(n.code,{children:"[CoreRoot]"}),"\u2019s ",(0,a.jsx)(n.code,{children:"CoreRefsHolder"})," if you\u2019re using it. Enter Play, run ",(0,a.jsx)(n.strong,{children:"Drop Refs And Unload"})," from the component\u2019s context menu, and watch the Console: the Bridge\u2019s ",(0,a.jsx)(n.code,{children:"OnDisable()"})," should print."]}),"\n",(0,a.jsx)(n.h4,{id:"demo-2-reproduce-the-unsubscribed-on-scene-change-case",children:"Demo 2: Reproduce the \u201cunsubscribed on scene change\u201d case"}),"\n",(0,a.jsxs)(n.p,{children:["This shows the difference between static vs instance subscriptions. Flip the SaveBridge back to ",(0,a.jsx)(n.strong,{children:"static method group"})," subscriptions, remove the keep-alive holder, start in ",(0,a.jsx)(n.code,{children:"Scene_Main"}),", then load another scene. Because nothing anchors the Bridge, Unity unloads it during the scene swap and you\u2019ll see ",(0,a.jsx)(n.code,{children:"OnDisable()"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// SaveBridgeSO.cs (temporary for demo only)\nprivate void OnEnable()\n{\n    saveChannel.OnSaveRequested += SaveRegistry.SaveAll;   // static (no target)\n    saveChannel.OnLoadRequested += SaveRegistry.LoadAll;   // static\n    Debug.Log("[SaveBridgeSO] Subscribed (STATIC demo)");\n}\n\nprivate void OnDisable()\n{\n    saveChannel.OnSaveRequested -= SaveRegistry.SaveAll;\n    saveChannel.OnLoadRequested -= SaveRegistry.LoadAll;\n    Debug.Log("[SaveBridgeSO] Unsubscribed (STATIC demo)");\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Load ",(0,a.jsx)(n.code,{children:"Scene_Level1"})," with ",(0,a.jsx)(n.code,{children:"LoadSceneMode.Single"})," and observe ",(0,a.jsx)(n.code,{children:"[SaveBridgeSO] Unsubscribed (STATIC demo)"}),". Then restore the ",(0,a.jsx)(n.strong,{children:"instance"})," handler version to keep it alive."]}),"\n",(0,a.jsxs)(n.h3,{id:"so-when-do-bridge-sos-actually-ondisable-naturally",children:["So when do Bridge SOs actually ",(0,a.jsx)(n.code,{children:"OnDisable()"})," naturally?"]}),"\n",(0,a.jsxs)(n.p,{children:["Bridges are ",(0,a.jsx)(n.code,{children:"ScriptableObjects"}),". They disable when Unity ",(0,a.jsx)(n.em,{children:"unloads"})," them. In many game architecture they often persist \u201cforever\u201d because we keep strong references (",(0,a.jsx)(n.code,{children:"BootstrapConfig"}),", instance-event subscriptions, or optional keep-alive holder)."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Not every Bridge needs to live for the whole app."})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Think in scopes:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Global bridges"})," are the ones your game always needs (Audio, Save, global Scene control). They ",(0,a.jsx)("span",{class:"orange-bold",children:"should"})," stay alive from startup to quit. Keep them referenced (",(0,a.jsx)(n.code,{children:"BootstrapConfig"}),", optional keep-alive holder) and subscribe with ",(0,a.jsx)(n.strong,{children:"instance"})," methods so they persist across scene loads."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Scoped/temporary bridges"})," are tied to a particular feature, level pack, or debug tool. These are good candidates to unload when that scope ends. Examples:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A level-specific ",(0,a.jsx)(n.code,{children:"SpawnSystem"})," that only exists in \u201cDungeonPack\u201d."]}),"\n",(0,a.jsx)(n.li,{children:"A minigame\u2019s Input remapper that shouldn\u2019t affect the main game."}),"\n",(0,a.jsx)(n.li,{children:"A tutorial tips dispatcher used only in the first two scenes."}),"\n",(0,a.jsxs)(n.li,{children:["A seasonal/limited-time event system loaded from an ",(0,a.jsx)(n.code,{children:"Addressable"})," bundle."]}),"\n",(0,a.jsx)(n.li,{children:"A profiling/QA bridge you load in dev builds but unload in retail."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A Bridge subscribed with instance methods won\u2019t disable ",(0,a.jsx)(n.strong,{children:"as long as the channel and the bridge both remain referenced"}),". If you unload the ",(0,a.jsx)(n.strong,{children:"channel"})," or you drop all strong references (including a keep-alive holder), Unity can unload the Bridge and its ",(0,a.jsx)(n.code,{children:"OnDisable()"})," will run. Instance subscriptions do not make objects immortal; they just keep the subscriber alive ",(0,a.jsx)(n.strong,{children:"through the event"})," as long as the publisher (channel) is alive."]}),"\n",(0,a.jsx)(n.h3,{id:"example-a-simple-scene-scoped-bridge-pattern",children:"Example: A simple \u201cscene-scoped bridge\u201d pattern"}),"\n",(0,a.jsx)(n.p,{children:"This keeps a Bridge alive only while a specific additive scene (or feature) is loaded."}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"You might want to read up about Addressables first."}),(0,a.jsx)(n.p,{children:"Addressables is Unity\u2019s built-in system for loading content on demand by a string \u201caddress,\u201d instead of bundling everything into every scene. You mark assets (prefabs, textures, ScriptableObjects, scenes, audio, etc.) as \u201cAddressable,\u201d give them an address or label, and then load/unload them at runtime asynchronously. Under the hood it manages AssetBundles for you, but you mostly work with a simple API: Addressables.Load... and Addressables.Release(...). This allows faster startup scenes and lower memory usage. It is a little bit overkill for 50.033 project though."})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// SceneScopedBootstrap.cs \u2014 lives in your additive scene (e.g., DungeonPack)\n// Loads the bridge via Addressables and releases it when the scene unloads.\nusing UnityEngine;\nusing UnityEngine.AddressableAssets;\nusing UnityEngine.ResourceManagement.AsyncOperations;\n\npublic class SceneScopedBootstrap : MonoBehaviour\n{\n    [SerializeField] private string bridgeAddress = "DungeonSpawnBridge"; // Addressables address\n    private AsyncOperationHandle<DungeonSpawnBridgeSO> handle;\n    private DungeonSpawnBridgeSO bridge;\n\n    private void OnEnable()\n    {\n        handle = Addressables.LoadAssetAsync<DungeonSpawnBridgeSO>(bridgeAddress);\n        handle.Completed += op =>\n        {\n            if (op.Status != AsyncOperationStatus.Succeeded) { Debug.LogError("Load failed"); return; }\n            bridge = op.Result;\n            // Touch to ensure OnEnable subscriptions are active this session.\n            bridge.RuntimeInit(); // optional if it needs a runner GO\n            Debug.Log("[SceneScopedBootstrap] Bridge ready");\n        };\n    }\n\n    private void OnDisable()\n    {\n        if (handle.IsValid()) Addressables.Release(handle);\n        bridge = null; // After release and no other refs, OnDisable() on the SO will fire.\n        Debug.Log("[SceneScopedBootstrap] Bridge released");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// DungeonSpawnBridgeSO.cs \u2014 the feature-specific bridge.\n// Subscribes with instance methods; unsubscribes on disable.\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Dungeon/Spawn Bridge")]\npublic class DungeonSpawnBridgeSO : ScriptableObject\n{\n    [SerializeField] private DungeonEventChannelSO channel; // this channel also lives in the pack\n\n    private void OnEnable()\n    {\n        if (channel == null) return;\n        channel.OnWaveRequested += OnWaveRequested;   // instance methods\n        channel.OnClearRequested += OnClearRequested;\n        Debug.Log("[DungeonSpawnBridgeSO] Subscribed");\n    }\n\n    private void OnDisable()\n    {\n        if (channel == null) return;\n        channel.OnWaveRequested -= OnWaveRequested;\n        channel.OnClearRequested -= OnClearRequested;\n        Debug.Log("[DungeonSpawnBridgeSO] Unsubscribed");\n    }\n\n    public void RuntimeInit() { /* optional: spawn runners, pools, etc. */ }\n\n    private void OnWaveRequested(int wave) { /* spawn logic */ }\n    private void OnClearRequested() { /* cleanup logic */ }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["When you unload the additive scene or call ",(0,a.jsx)(n.code,{children:"Addressables.Release"}),", there are no more strong references to the Bridge or its Channel; Unity unloads them and ",(0,a.jsx)(n.code,{children:"OnDisable()"})," runs. That\u2019s exactly when you ",(0,a.jsx)(n.em,{children:"want"})," a temporary subsystem to tear down."]}),"\n",(0,a.jsx)(n.h4,{id:"when-should-bridges-be-persistent",children:"When should bridges be persistent?"}),"\n",(0,a.jsx)(n.p,{children:"Keep them global if they represent core, reusable services that any scene may need at any time, and they don\u2019t waste memory sitting around. Audio, Save, global Scene control, Localization, Analytics dispatchers are typical \u201calways on\u201d bridges."}),"\n",(0,a.jsx)(n.h4,{id:"when-should-bridges-be-unloadable",children:"When should bridges be unloadable?"}),"\n",(0,a.jsx)(n.p,{children:"Make them scoped if they bind to content that isn\u2019t always loaded, if they carry notable memory/runtime cost (pools, large data tables), or if keeping them around risks interfering with other modes of play. In those cases, load them alongside their content (Addressables or additive scene), and release them when the content goes away."}),"\n",(0,a.jsx)(n.admonition,{title:"final note",type:"note",children:(0,a.jsxs)(n.p,{children:["Instance subscriptions make lifetime ",(0,a.jsx)(n.strong,{children:"predictable"})," while the publisher (channel) and a strong reference exist; they don\u2019t make the object permanent. If you want a Bridge to disappear naturally, drop the strong references (e.g., release Addressables handle, clear keep-alive holder, unload the additive scene and its channel). If you want it to stay, keep a reference in your Bootstrap (and optionally a keep-alive holder) and you\u2019ll get a stable, global subsystem."]})})]})}function v(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}},43524:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-10-58-39-4b2305f2457204a560f7afd3607d94f7.png"},77397:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-00-30-42f9b9fe6c157bf2a6ba6376d302062f.png"},66866:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-01-34-55f9aeea1064a90ffa291d4b38a10671.png"},73534:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-22-46-012708c7dcc10e2254c154112c25bc77.png"},36322:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-23-01-163ce5de60278eabdd2f5fb3cebfca05.png"},36748:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-23-43-b5ce96e56925c12131659ea19b5c0cc5.png"},98383:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-24-16-007e33fe7d5a162e5fa720157104b8fe.png"},21664:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-25-38-3bb575343973abecff0c8400b3687c97.png"},14048:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-27-36-c59e5831169ef8904126c6a12b0c9d6e.png"},98052:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-28-19-891592876b674c6a86eba33d273fbe59.png"}}]);