"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[6069],{60198:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>p,contentTitle:()=>u,default:()=>m,frontMatter:()=>h,metadata:()=>i,toc:()=>g});const i=JSON.parse('{"id":"general/bootstrap","title":"Bootstrapping","description":"This module is a natural extension of the Hybrid Service\u2013Adapter pattern: it keeps SOs as Services/Adapters and adds a clean boot sequence (one Bootstrapper + Config) so Save, Audio, and Scene systems are initialized, subscribed, and traceable from frame zero.","source":"@site/resources/general/bootstrap.md","sourceDirName":"general","slug":"/general/bootstrap","permalink":"/50033/resources/general/bootstrap","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Hybrid Service-Adapter Architecture with ScriptableObjects","permalink":"/50033/resources/general/hybrid-arch"}}');var t=s(74848),a=s(28453),r=s(72206),o=s(82223),l=(s(53398),s(19894)),d=s(88761),c=(s(89166),s(384));const h={sidebar_position:11},u="Bootstrapping",p={},g=[{value:"Basic Idea",id:"basic-idea",level:3},{value:"Relationship with SOGA (Lab 5)",id:"relationship-with-soga-lab-5",level:3},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"The Bootstrap Protocol",id:"the-bootstrap-protocol",level:2},{value:"Demo Subsystems",id:"demo-subsystems",level:3},{value:"Folder Setup",id:"folder-setup",level:3},{value:"Bootstrapper (Config SO + Runner MonoBehavior + Static Registry)",id:"bootstrapper-config-so--runner-monobehavior--static-registry",level:3},{value:"The Bootstrap Class",id:"the-bootstrap-class",level:4},{value:"The Bridge abstract class",id:"the-bridge-abstract-class",level:4},{value:"BootstrapConfigSO",id:"bootstrapconfigso",level:4},{value:"GameBootstrap (Monobehavior Script)",id:"gamebootstrap-monobehavior-script",level:3},{value:"Save system (Channel + Bridge + Registry + ISaveable)",id:"save-system-channel--bridge--registry--isaveable",level:3},{value:"Audio system (Channel + Bridge)",id:"audio-system-channel--bridge",level:3},{value:"Scene System (Channel + Bridge)",id:"scene-system-channel--bridge",level:3},{value:"Minimal UI Triggers (for demo)",id:"minimal-ui-triggers-for-demo",level:3},{value:"Minimal <code>ISaveable</code> demo component",id:"minimal-isaveable-demo-component",level:3},{value:"Auto Register <code>ISaveable</code> Helper demo component",id:"auto-register-isaveable-helper-demo-component",level:3},{value:"The Demo",id:"the-demo",level:2},{value:"Create SO Bridges, Channels, and BootstrapConfig",id:"create-so-bridges-channels-and-bootstrapconfig",level:3},{value:"Create Scenes",id:"create-scenes",level:3},{value:"The Bootstrap Scene",id:"the-bootstrap-scene",level:4},{value:"UI",id:"ui",level:4},{value:"Running the Demo",id:"running-the-demo",level:3},{value:"Using Bootstrap in the Hybrid Architecture",id:"using-bootstrap-in-the-hybrid-architecture",level:2},{value:"Unifying the Systems",id:"unifying-the-systems",level:3},{value:"Epilogue",id:"epilogue",level:2},{value:"Demo 1: Explicitly drop refs and unload",id:"demo-1-explicitly-drop-refs-and-unload",level:4},{value:"Demo 2: Reproduce the \u201cunsubscribed on scene change\u201d case",id:"demo-2-reproduce-the-unsubscribed-on-scene-change-case",level:4},{value:"So when do Bridge SOs actually <code>OnDisable()</code> naturally?",id:"so-when-do-bridge-sos-actually-ondisable-naturally",level:3},{value:"Example: A simple \u201cscene-scoped bridge\u201d pattern",id:"example-a-simple-scene-scoped-bridge-pattern",level:3},{value:"When should bridges be persistent?",id:"when-should-bridges-be-persistent",level:4},{value:"When should bridges be unloadable?",id:"when-should-bridges-be-unloadable",level:4}];function b(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"bootstrapping",children:"Bootstrapping"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["This module is a ",(0,t.jsx)("span",{class:"orange-bold",children:"natural"})," extension of the ",(0,t.jsx)(n.a,{href:"https://natalieagus.github.io/50033/resources/general/hybrid-arch",children:"Hybrid Service\u2013Adapter pattern"}),": it keeps SOs as Services/Adapters and ",(0,t.jsx)("span",{class:"orange-bold",children:"adds a clean boot sequence"})," (one Bootstrapper + Config) so Save, Audio, and Scene systems are initialized, subscribed, and traceable from frame zero."]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Scene/UI (buttons, controllers)\n        \u2502     (raise events)\n        \u25bc\n[ Event Channels (SO) ]  \u2014 decoupled broadcast\n        \u2502     (subscribe at enable)\n        \u25bc\n[ Bridges (SO) = Services/Adapters ]\n        \u2502     (do work: save, audio, scene)\n        \u25b2\n        \u2502  (explicit init)\n[ Bootstrapper Mono ] \u2192 [ BootstrapConfigSO ]\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"With a bootstrapper, we get deterministic startup (no \u201csome SO didn\u2019t enable yet\u201d flakiness), uniform protocol reusable for new systems (Input, Localization, Analytics) and traceable logs from boot \u2192 event \u2192 bridge action."}),"\n",(0,t.jsx)(n.h3,{id:"basic-idea",children:"Basic Idea"}),"\n",(0,t.jsxs)(n.p,{children:["One ",(0,t.jsx)(n.code,{children:"Bootstrapper"})," runs at startup, reads a single ",(0,t.jsx)(n.code,{children:"BootstrapConfigSO"}),", and brings ",(0,t.jsx)("span",{class:"orange-bold",children:"every"})," global system online using the same protocol:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Channel (broadcast requests) \u2192 Bridge (listen and do work) \u2192 Config (wires them all up)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Instead of scattered \u201cmanagers\u201d or hidden statics, each subsystem (Save, Audio, Scene) exposes an event channel and a ScriptableObject bridge that subscribes on enable and performs the action, with clear debug logs the whole way."}),"\n",(0,t.jsx)(n.p,{children:"By the end, you\u2019ll have a one-click boot sequence you can copy to new projects: add a channel, add a bridge, reference both in the config, and the system is live from frame zero."}),"\n",(0,t.jsx)(n.h3,{id:"relationship-with-soga-lab-5",children:"Relationship with SOGA (Lab 5)"}),"\n",(0,t.jsxs)(n.p,{children:["The Bootstrap pattern slashes repetitive wiring ",(0,t.jsx)("span",{class:"orange-bold",children:"for cross-cutting"})," systems (Save, Audio, Sceneloading, etc): instead of sprinkling hundreds of ",(0,t.jsx)(n.code,{children:"GameEventListeners"}),", you raise a channel and a single Bridge SO does the work (Save/Audio/Scene, etc.), giving you ",(0,t.jsx)("span",{class:"orange-bold",children:"deterministic"})," startup and decoupled comms without per-scene listeners."]}),"\n",(0,t.jsx)(n.p,{children:"For the rest, we keep it lean: use code-first subscriptions in controllers for core gameplay (subscribe/unsubscribe in OnEnable/OnDisable), and handle wide fan-out visuals with 1\u20133 routers (scene or prefab-level) that listen to a few topic events (e.g., OnPlayerJump, OnAttack) and fan out to multiple effects."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Prefabize wiring where it\u2019s designer-tuned,"}),"\n",(0,t.jsx)(n.li,{children:"Keep typed C# for logic, and"}),"\n",(0,t.jsx)(n.li,{children:"Reserve inspector hooks for presentation"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Rule of thumb",type:"note",children:(0,t.jsx)(n.p,{children:"Global services \u2192 Channel/Bridge, core gameplay \u2192 code subscriptions, broad VFX/UI \u2192 small routers, not a thousand listeners."})}),"\n",(0,t.jsx)(n.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[GameBootstrap (MonoBehaviour)]\n        \u2502\n        \u25bc\n[BootstrapConfigSO (ScriptableObject asset)]\n        \u2502 initializes (forces deserialize + OnEnable)\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                                                                 \u2502\n        \u25bc                                                                 \u25bc\n [SaveBridgeSO]  listens to  [SaveEventChannelSO]         [AudioBridgeSO] listens to [AudioEventChannelSO]\n        \u2502                     \u25b2                                   \u2502                       \u25b2\n        \u2502 calls               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 UI/Game code raises \u2518                       \u2514\u2500\u2500 UI/Game code raises\n        \u25bc\n  SaveRegistry (static)\n        \u25b2\n   ISaveable implementers\n\n        \u25bc\n [SceneBridgeSO] listens to [SceneEventChannelSO] \u2500\u2500\u25ba uses SceneManager (LoadSceneAsync/UnloadSceneAsync)\n\nDebug logs trace: Bootstrap \u2192 Channel subscriptions \u2192 Button raises \u2192 Bridge actions.\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"the-bootstrap-protocol",children:"The Bootstrap Protocol"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Event Channel ScriptableObject (per subsystem)"}),": public, typed API that broadcasts requests. UI or gameplay code calls channel methods; ",(0,t.jsx)(n.em,{children:"nothing"})," talks directly to the bridges."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bridge/Manager ScriptableObject (per subsystem)"}),": subscribes to its channel in ",(0,t.jsx)(n.code,{children:"OnEnable"}),", performs actions when events fire, and unsubscribes in ",(0,t.jsx)(n.code,{children:"OnDisable"}),". This keeps runtime logic centralized and scene-agnostic."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bootstrap class"}),": provides a single, global registry that remembers every important ScriptableObject at runtime."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bootstrap Config SO"}),": registers references to all Bridges and Channels into ",(0,t.jsx)(n.code,{children:"Bootstrap"}),". ",(0,t.jsx)(n.code,{children:"InitializeAll()"})," touches ",(0,t.jsx)(n.em,{children:"each"})," reference to force Unity to deserialize the assets and trigger their ",(0,t.jsx)(n.code,{children:"OnEnable"})," so subscriptions are active before play."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"GameBootstrap MonoBehaviour"}),": a ",(0,t.jsx)("span",{class:"orange-bold",children:"single"})," scene entry point that invokes the config\u2019s ",(0,t.jsx)(n.code,{children:"InitializeAll()"})," in ",(0,t.jsx)(n.code,{children:"Awake()"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This protocol is the point of \u201cbootstrapping\u201d: one place to ",(0,t.jsx)(n.em,{children:"initialize everything"}),"; no direct cross-references from UI/gameplay to bridges; all calls go through ",(0,t.jsx)("span",{class:"orange-bold",children:"channels"}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"demo-subsystems",children:"Demo Subsystems"}),"\n",(0,t.jsxs)(n.p,{children:["To see the protocol in action, we include ",(0,t.jsx)(n.strong,{children:"three"})," global subsystems:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Save"}),": Demonstrates global state capture/restore with a static ",(0,t.jsx)(n.code,{children:"SaveRegistry"})," and ",(0,t.jsx)(n.code,{children:"ISaveable"}),". Buttons raise save/load on the ",(0,t.jsx)(n.code,{children:"SaveEventChannel"}),", ",(0,t.jsx)(n.code,{children:"SaveBridge"})," invokes ",(0,t.jsx)(n.code,{children:"SaveRegistry"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Audio"}),": Demonstrates a persistent audio root with two ",(0,t.jsx)(n.code,{children:"AudioSources"})," (SFX/BGM). Buttons raise SFX/BGM/Stop on ",(0,t.jsx)(n.code,{children:"AudioEventChannel"}),", ",(0,t.jsx)(n.code,{children:"AudioBridge"})," plays/stops clips. ",(0,t.jsx)(n.code,{children:"DontDestroyOnLoad"})," ensures continuity across scenes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scene"}),": Demonstrates scene transitions. Buttons raise ",(0,t.jsx)(n.code,{children:"load"}),"/",(0,t.jsx)(n.code,{children:"unload"})," on ",(0,t.jsx)(n.code,{children:"SceneEventChannel"}),", ",(0,t.jsx)(n.code,{children:"SceneBridge"})," calls ",(0,t.jsx)(n.code,{children:"SceneManager.*"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"folder-setup",children:"Folder Setup"}),"\n",(0,t.jsx)(n.p,{children:"Here's a minimal folder setup for this demo to work:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Assets/\n \u251c\u2500\u2500 Scripts/\n \u2502   \u251c\u2500\u2500 Bootstrap/\n \u2502   \u2502   \u251c\u2500\u2500 GameBootstrap.cs\n \u2502   \u2502   \u251c\u2500\u2500 Bootstrap.cs\n \u2502   \u2502   \u2514\u2500\u2500 BootstrapConfigSO.cs\n \u2502   \u251c\u2500\u2500 Systems/\n \u2502   \u2502   \u251c\u2500\u2500 Save/\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 SaveEventChannelSO.cs\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 SaveBridgeSO.cs\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 SaveRegistry.cs\n \u2502   \u2502   \u251c\u2500\u2500 Audio/\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 AudioEventChannelSO.cs\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 AudioBridgeSO.cs\n \u2502   \u2502   \u2514\u2500\u2500 Scene/\n \u2502   \u2502       \u251c\u2500\u2500 SceneEventChannelSO.cs\n \u2502   \u2502       \u2514\u2500\u2500 SceneBridgeSO.cs\n \u251c\u2500\u2500 Game/\n \u2502   \u2514\u2500\u2500 BootstrapConfig.asset\n \u251c\u2500\u2500 Events/\n \u2502   \u251c\u2500\u2500 SaveEventChannel.asset\n \u2502   \u251c\u2500\u2500 AudioEventChannel.asset\n \u2502   \u2514\u2500\u2500 SceneEventChannel.asset\n \u251c\u2500\u2500 Scenes/\n \u2502   \u251c\u2500\u2500 Scene_Main.unity\n \u2502   \u2514\u2500\u2500 Scene_Level1.unity\n \u2514\u2500\u2500 UI/\n     \u251c\u2500\u2500 SaveButtonUI.cs\n     \u251c\u2500\u2500 AudioButtonUI.cs\n     \u2514\u2500\u2500 SceneButtonUI.cs\n"})}),"\n",(0,t.jsx)(n.h3,{id:"bootstrapper-config-so--runner-monobehavior--static-registry",children:"Bootstrapper (Config SO + Runner MonoBehavior + Static Registry)"}),"\n",(0,t.jsx)(n.p,{children:"This is a system that resets, initializes, and holds references to all Bridges and Event Channels. Unity only keeps ScriptableObjects in memory if something in a scene or prefab references them. Otherwise, they remain serialized data on disk\u2014essentially text describing field values."}),"\n",(0,t.jsxs)(n.p,{children:["When the game starts, Unity \u201cdeserializes\u201d referenced assets: ",(0,t.jsx)(n.em,{children:"it reads that serialized data and recreates the ScriptableObject in memory"}),". Anything not referenced ",(0,t.jsx)("span",{class:"orange-bold",children:"stays unloaded"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["In small projects this is fine, but in larger systems we often need global ScriptableObjects\u2014such as ",(0,t.jsx)(n.code,{children:"GameStateSO"}),", ",(0,t.jsx)(n.code,{children:"InputReader"}),", or event channels\u2014to exist ",(0,t.jsx)(n.em,{children:"even when no scene directly references them"}),". Without a mechanism to keep track of these, developers end up manually dragging the same assets into every prefab, which quickly becomes tedious and fragile."]}),"\n",(0,t.jsx)(n.h4,{id:"the-bootstrap-class",children:"The Bootstrap Class"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="Bootstrap.cs"',children:'using System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic static class Bootstrap\n{\n    private static readonly Dictionary<Type, ScriptableObject> registry = new();\n\n    public static void Register(ScriptableObject instance)\n    {\n        if (instance == null) return;\n        var type = instance.GetType();\n        registry[type] = instance;\n        Debug.Log($"[Bootstrap] Registered {type.Name}");\n    }\n\n    // a simple runtime lookup that returns the globally registered instance of a ScriptableObject type T.\n    public static T Resolve<T>() where T : ScriptableObject\n    {\n        if (registry.TryGetValue(typeof(T), out var so))\n            return so as T;\n\n        Debug.LogWarning($"[Bootstrap] {typeof(T).Name} not registered");\n        return null;\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Bootstrap.cs"})," solves this by providing a single, global registry that remembers every important ScriptableObject at runtime."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["It contains a static dictionary mapping a ",(0,t.jsx)(n.strong,{children:"type"})," to a ",(0,t.jsx)(n.strong,{children:"ScriptableObject instance"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["When the game starts, a separate setup script (",(0,t.jsx)(n.code,{children:"BootstrapConfigSO"}),") loads and registers all systems by calling ",(0,t.jsx)(n.code,{children:"Bootstrap.Register(instance)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Any other script can later call ",(0,t.jsx)(n.code,{children:"Bootstrap.Resolve<T>()"})," to ",(0,t.jsx)("span",{class:"orange-bold",children:"retrieve"})," that instance without an inspector reference."]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{title:"Register and Resolve",type:"note",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Register()"})," simply stores the object in the dictionary and logs its name."]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Resolve<T>()"})," looks up the type key and returns the corresponding instance; if none was registered, it prints a warning."]}),(0,t.jsxs)(n.p,{children:["Together they form a lightweight ",(0,t.jsx)("span",{class:"orange-bold",children:"service locator"})," for global ",(0,t.jsx)(n.code,{children:"ScriptableObjects"}),"."]})]}),"\n",(0,t.jsxs)(n.p,{children:["This also ",(0,t.jsx)("span",{class:"red-bold",children:"removes the need for repeated drag-and-drop linking"}),", ensures all shared systems refer to the same instance, and makes dependencies explicit in code rather than hidden in the editor. The registry lives across scene loads, so every system registered once at startup can be accessed anywhere during the game."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"It acts as the one source of truth for global subsystems."})}),"\n",(0,t.jsx)(n.h4,{id:"the-bridge-abstract-class",children:"The Bridge abstract class"}),"\n",(0,t.jsx)(n.p,{children:"The base class BridgeSO provides a common foundation for all bridges."}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(o.A,{value:"1",label:"BridgeSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="BridgeSO.cs"',children:'using UnityEngine;\n\n// Bridges are the active connectors that:\n// listen to Event Channels,\n// perform actions,\n// or coordinate between systems (e.g., save, audio, scene, UI).\n// They always implement IRuntimeInitializable, because they must subscribe to events or systems at startup.\npublic abstract class BridgeSO : ScriptableObject, IRuntimeInitializable\n{\n    // Optional to override\n    public virtual void RuntimeInit()\n    {\n        // Default no-op\n        Debug.Log($"[BridgeSO] {name} has no RuntimeInit override (skipped).");\n    }\n}\n'})})}),(0,t.jsx)(o.A,{value:"2",label:"IRuntimeInitializable.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'public interface IRuntimeInitializable\n{\n    // Set up live connections or subscriptions: prepare it to interact with other systems.\n    // Example: connect to other systems or events\n    //     public void RuntimeInit()\n    // {\n    //     var input = Bootstrap.Resolve<InputReader>();\n    //     input.pauseEvent += OnPause;\n    //     Debug.Log("[GameStateSO] Initialized and listening for pause events");\n    // }\n    void RuntimeInit();\n}\n\n'})})})]}),"\n",(0,t.jsx)(n.h4,{id:"bootstrapconfigso",children:"BootstrapConfigSO"}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"BootstrapConfigSO is the manifest and initializer for the game\u2019s core systems. It controls deserialization, registration, and startup order, ensuring consistent behavior across all scenes without manual drag-and-drop references."})}),"\n",(0,t.jsxs)(n.p,{children:["When the game first launches, Unity hasn\u2019t yet deserialized or initialized most of the global ScriptableObjects, only the ones referenced directly by a scene are alive. ",(0,t.jsx)(n.code,{children:"BootstrapConfigSO"})," fixes that by ",(0,t.jsx)(n.em,{children:"keeping a serialized list of bridges"})," (and optionally shared states or event channels) that must always be ",(0,t.jsx)("span",{class:"orange-bold",children:"active"}),"."]}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(o.A,{value:"1",label:"BootstrapConfigSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System.Collections.Generic;\nusing System.Reflection;\n\n[CreateAssetMenu(menuName = "Game/Bootstrap Config")]\npublic class BootstrapConfigSO : ScriptableObject\n{\n    [Header("Active Systems (Bridges)")]\n\n    // only serialize bridges\n    // channels have no side effects when loaded, no onEnable and no runtime code unless someone calls the methods like RaiseEventX()\n    [SerializeField] private List<BridgeSO> bridges = new();\n\n    [Header("Shared States (Data)")]\n    [SerializeField] private List<ScriptableObject> sharedStates = new();\n\n    /// <summary>\n    /// Initializes all runtime systems that implement IRuntimeInitializable.\n    /// </summary>\n    public void InitializeAll()\n    {\n        // this forces unity to deserialize\n        // meaning: \u201cmake Unity actually load this ScriptableObject\u2019s data into memory right now,\u201d not just have a file reference to it.\n        foreach (var bridge in bridges)\n        {\n            if (bridge == null) continue;\n\n            Bootstrap.Register(bridge);\n\n            AutoRegisterSOFields(bridge);\n\n            if (bridge is IRuntimeResettable reset)\n            {\n                reset.RuntimeReset();\n                Debug.Log($"[BootstrapConfigSO] Reset {bridge.name}");\n            }\n\n            if (bridge is IRuntimeInitializable init)\n            {\n                init.RuntimeInit();\n                Debug.Log($"[BootstrapConfigSO] Initialized {bridge.name}");\n            }\n        }\n        Debug.Log($"[BootstrapConfigSO] Bootstrap complete for {bridges.Count} bridge systems");\n\n        // this registers state objects and reset them before start\n        foreach (var so in sharedStates)\n        {\n            Bootstrap.Register(so);\n            if (so is IRuntimeResettable reset)\n            {\n                reset.RuntimeReset();\n                Debug.Log($"[BootstrapConfigSO] Reset {so.name}");\n            }\n        }\n        Debug.Log($"[BootstrapConfigSO] Bootstrap complete for {sharedStates.Count} state systems");\n\n    }\n\n    private void AutoRegisterSOFields(ScriptableObject parent)\n    {\n        var fields = parent.GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);\n\n        foreach (var f in fields)\n        {\n            if (typeof(ScriptableObject).IsAssignableFrom(f.FieldType))\n            {\n                var value = f.GetValue(parent) as ScriptableObject;\n                if (value != null)\n                {\n                    Bootstrap.Register(value);\n                    Debug.Log($"[BootstrapConfigSO] Auto-registered {value.name} (from {parent.name})");\n                }\n            }\n        }\n    }\n}\n\n'})})}),(0,t.jsx)(o.A,{value:"3",label:"IRuntimeResettable.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"public interface IRuntimeResettable\n{\n    // Clear any leftover data: bring the ScriptableObject back to a neutral \u201cblank slate.\u201d\n    // Example: clear transient values from the last play session or scene\n    //     public void RuntimeReset()\n    // {\n    //     isDialogueActive = false;\n    //     isPaused = false;\n    // }\n\n    void RuntimeReset();\n}\n\n"})})})]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The interfaces should be used whenever applicable. For example, ",(0,t.jsx)(n.code,{children:"AudioBridgeSO"})," implements ",(0,t.jsx)(n.code,{children:"IRuntimeInitializable"})," (spawns its ",(0,t.jsx)(n.code,{children:"[AudioBridge] GO"}),").\n",(0,t.jsx)(n.code,{children:"SaveBridgeSO"})," and ",(0,t.jsx)(n.code,{children:"SceneBridgeSO"})," don\u2019t implement it (no runtime objects needed)."]})}),"\n",(0,t.jsxs)(n.p,{children:["When its ",(0,t.jsx)(n.code,{children:"InitializeAll() "}),"method runs, it iterates through those listed systems and does three things in order:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Register each ",(0,t.jsx)(n.code,{children:"ScriptableObject"})," with the ",(0,t.jsx)("span",{class:"orange-bold",children:"global"})," registry (",(0,t.jsx)(n.code,{children:"Bootstrap.Register(so)"}),"), so other scripts can later retrieve it using ",(0,t.jsx)(n.code,{children:"Bootstrap.Resolve<T>()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Reset any system that implements ",(0,t.jsx)(n.code,{children:"IRuntimeResettable"}),", clearing leftover or \u201cghost\u201d values from previous runs."]}),"\n",(0,t.jsx)(n.li,{children:"Initialize any system that implements IRuntimeInitializable, allowing bridges to subscribe to event channels or set up internal references."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"gamebootstrap-monobehavior-script",children:"GameBootstrap (Monobehavior Script)"}),"\n",(0,t.jsxs)(n.p,{children:["The scene-level ",(0,t.jsx)(n.code,{children:"GameBootstrap"})," (MonoBehaviour) calls ",(0,t.jsx)(n.code,{children:"bootstrapConfig.InitializeAll()"})," in ",(0,t.jsx)(n.code,{children:"Awake()"})," to:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Force asset deserialization (so Bridges/Channels are \u201calive\u201d and ",(0,t.jsx)(n.code,{children:"OnEnable()"})," subscriptions attach),","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Assigning SOs in the Inspector only stores references. It doesn\u2019t guarantee when they\u2019re \u201clive\u201d for this play session, nor that any runtime-only setup has happened in the right order."}),"\n",(0,t.jsxs)(n.li,{children:["This ",(0,t.jsx)(n.code,{children:"BootstrapConfigSO.InitializeAll()"})," call gives us a deterministic, one-shot kickoff at runtime."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Invoke any runtime-only initialization for systems that need it (e.g., Audio creating an ",(0,t.jsx)(n.code,{children:"AudioSource"})," GameObject)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Place a ",(0,t.jsx)(n.code,{children:"GameBootstrap"})," in ",(0,t.jsx)(n.code,{children:"Scene_Bootstrap"})," and assign ",(0,t.jsx)(n.code,{children:"BootstrapConfig.asset"})," to an empty gameobject. The purpose of this script is simply to initialize the bridges and channels in the project, ",(0,t.jsx)("span",{class:"orange-bold",children:"before we load"})," the first scene in our project. This is to ensure everything is ready before any scripts tried to access any SOs, etc."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="GameBootstrap.cs"',children:'using UnityEngine;\nusing UnityEngine.SceneManagement;\n\npublic class GameBootstrap : MonoBehaviour\n{\n    [SerializeField] private BootstrapConfigSO bootstrapConfig;\n    [SerializeField] private string nextSceneName = "BootstrapDemo_Main";\n\n    private void Awake()\n    {\n        Debug.Log("[GameBootstrap] Starting initialization");\n        bootstrapConfig.InitializeAll();\n        Debug.Log("[GameBootstrap] Bootstrap complete");\n\n        SceneManager.LoadSceneAsync(nextSceneName);\n    }\n}\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"save-system-channel--bridge--registry--isaveable",children:"Save system (Channel + Bridge + Registry + ISaveable)"}),"\n",(0,t.jsxs)(n.p,{children:["This system is a ",(0,t.jsx)("span",{class:"orange-bold",children:"centralized"})," capture/restore surface area for all saveable objects. Objects opt in by implementing ",(0,t.jsx)(n.code,{children:"ISaveable"})," and calling ",(0,t.jsx)(n.code,{children:"SaveRegistry.Register/Unregister"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:"Bridge"})," wires the channel to registry calls."]}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(o.A,{value:"2",label:"SaveBridgeSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'// SaveBridgeSO.cs\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Save Bridge")]\npublic class SaveBridgeSO : BridgeSO\n{\n    [SerializeField] private SaveEventChannelSO saveChannel;\n\n    private void OnEnable()\n    {\n        saveChannel.OnSaveRequested += OnSaveRequested;  // instance methods\n        saveChannel.OnLoadRequested += OnLoadRequested;\n        Debug.Log("[SaveBridgeSO] Subscribed to save/load events");\n    }\n\n    private void OnDisable()\n    {\n        saveChannel.OnSaveRequested -= OnSaveRequested;\n        saveChannel.OnLoadRequested -= OnLoadRequested;\n        Debug.Log("[SaveBridgeSO] Unsubscribed");\n    }\n\n    // we subscribe with instance methods (from this SO) and not static method from SaveRegistry directly\n    private void OnSaveRequested() => SaveRegistry.SaveAll();\n    private void OnLoadRequested() => SaveRegistry.LoadAll();\n}\n\n'})})}),(0,t.jsx)(o.A,{value:"1",label:"SaveEventChannelSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System;\n\n[CreateAssetMenu(menuName = "Events/Save Event Channel")]\npublic class SaveEventChannelSO : ScriptableObject\n{\npublic event Action OnSaveRequested;\npublic event Action OnLoadRequested;\n\n    public void RaiseSave()\n    {\n        Debug.Log("[SaveEventChannelSO] Save requested");\n        OnSaveRequested?.Invoke();\n    }\n\n    public void RaiseLoad()\n    {\n        Debug.Log("[SaveEventChannelSO] Load requested");\n        OnLoadRequested?.Invoke();\n    }\n\n}\n\n'})})}),(0,t.jsx)(o.A,{value:"3",label:"SaveRegistry.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System.Collections.Generic;\nusing System.IO;\n\npublic static class SaveRegistry\n{\n    private static readonly HashSet<ISaveable> saveables = new();\n    private static string PathName => Path.Combine(Application.persistentDataPath, "save.json");\n\n    public static void Register(ISaveable s)\n    {\n        saveables.Add(s);\n        Debug.Log($"[SaveRegistry] Registered {s.GetUniqueID()}");\n    }\n\n    public static void Unregister(ISaveable s)\n    {\n        saveables.Remove(s);\n        Debug.Log($"[SaveRegistry] Unregistered {s.GetUniqueID()}");\n    }\n\n    public static void SaveAll()\n    {\n        var state = new Dictionary<string, object>();\n        foreach (var s in saveables)\n        {\n            state[s.GetUniqueID()] = s.CaptureState();\n            Debug.Log($"[SaveRegistry] Captured {s.GetUniqueID()}");\n        }\n        File.WriteAllText(PathName, JsonUtility.ToJson(new Wrapper(state)));\n        Debug.Log($"[SaveRegistry] Wrote file to {PathName}");\n    }\n\n    public static void LoadAll()\n    {\n        if (!File.Exists(PathName))\n        {\n            Debug.Log("[SaveRegistry] No save file found");\n            return;\n        }\n        var wrapper = JsonUtility.FromJson<Wrapper>(File.ReadAllText(PathName));\n        foreach (var s in saveables)\n        {\n            if (wrapper.data.TryGetValue(s.GetUniqueID(), out var d))\n            {\n                s.RestoreState(d);\n                Debug.Log($"[SaveRegistry] Restored {s.GetUniqueID()}");\n            }\n        }\n    }\n\n    [System.Serializable]\n    private class Wrapper { public Dictionary<string, object> data; public Wrapper(Dictionary<string, object> d){data=d;} }\n}\n'})})}),(0,t.jsx)(o.A,{value:"4",label:"ISaveable.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="ISaveable.cs"',children:"public interface ISaveable\n{\n    string GetUniqueID();\n    object CaptureState();\n    void RestoreState(object state);\n}\n"})})})]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)(l.A,{title:"Deep Dive: Instance vs Static Subscription to SO Events (What to Use, and Why)",children:[(0,t.jsxs)(n.p,{children:["With ScriptableObject (SO) event channels, prefer instance-method subscriptions from your Bridges/Managers, ",(0,t.jsx)("span",{class:"red-bold",children:"not"})," static method groups."]}),(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)("span",{class:"orange-bold",children:"instance subscription"})," gives the event delegate a real target object, which keeps the Bridge asset \u201calive\u201d across scene changes. Static subscriptions have no target; if nothing else holds a strong reference to the SO, ",(0,t.jsx)(n.em,{children:"Unity may unload it when you load a new scene"}),", and your callbacks ",(0,t.jsx)("span",{class:"orange-bold",children:"quietly stop firing"}),"."]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"In practice"}),": subscribe inside the SO\u2019s OnEnable() with instance methods, and unsubscribe in OnDisable(). Keep any heavy, scene-object work in a separate RuntimeInit() that runs only during play."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="Bad example"',children:"// Inside a Bridge SO's OnEnable()\nchannel.OnSomething += SomeStaticService.DoIt;   // static => no target = fragile lifetime\n"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="Good example"',children:'using UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Bridge")]\npublic class BridgeSO : ScriptableObject\n{\n    [SerializeField] private EventChannelSO channel;\n\n    private void OnEnable()\n    {\n        channel.OnSomething += OnSomething;   // instance method\n        Debug.Log("[BridgeSO] Subscribed");\n    }\n\n    private void OnDisable()\n    {\n        channel.OnSomething -= OnSomething;\n        Debug.Log("[BridgeSO] Unsubscribed");\n    }\n\n    private void OnSomething() => SomeService.DoIt(); // forward to your service/registry\n}\n'})}),(0,t.jsxs)(n.p,{children:["If you ",(0,t.jsx)(n.em,{children:"truly"})," need static subscriptions (e.g., calling a static registry directly), then also keep a ",(0,t.jsx)("span",{class:"orange-bold",children:"strong"})," reference to the Bridge/Channel assets for the whole run\u2014otherwise Unity can unload them on scene transitions. One tidy way is a tiny persistent holder created at bootstrap:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="CoreRefsHolder.cs"',children:"// CoreRefsHolder.cs\nusing UnityEngine;\n\npublic class CoreRefsHolder : MonoBehaviour\n{\n    public ScriptableObject[] keepAlive; // assign bridges/channels at runtime\n}\n"})}),(0,t.jsxs)(n.p,{children:["Then in the ",(0,t.jsx)(n.code,{children:"BootstrapConfigSO.InitializeAll()"}),":"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="BootstrapConfigSO.InitializeAll"',children:'\nif (Application.isPlaying)\n{\n    var core = GameObject.Find("[CoreRoot]") ?? new GameObject("[CoreRoot]");\n    Object.DontDestroyOnLoad(core);\n    var holder = core.GetComponent<CoreRefsHolder>() ?? core.AddComponent<CoreRefsHolder>();\n    holder.keepAlive = new ScriptableObject[] { bridgeA, bridgeB, channelA, channelB }; // etc.\n}\n'})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The rule of thumb:"})," subscribe with instance methods for predictable lifetime. Use static only when you also ensure those assets are strongly referenced (e.g., via a persistent holder). This keeps your SO event system stable across scene loads while preserving clean separation between UI (raises events), channels (broadcast), and bridges (handle)."]})]}),"\n",(0,t.jsx)(n.h3,{id:"audio-system-channel--bridge",children:"Audio system (Channel + Bridge)"}),"\n",(0,t.jsxs)(n.p,{children:["This audio system is a persistent, scene-independent audio management. We always have SFX/BGM ready, no matter ",(0,t.jsx)(n.em,{children:"which"})," scene is active."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"AudioBridgeSO"})," ",(0,t.jsx)(n.strong,{children:"must"})," own AudioSources, which exist on GameObjects and needs a small runtime root. So we should generalise this with an interface: ",(0,t.jsx)(n.code,{children:"IRuntimeInitializable"}),"."]})}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(o.A,{value:"2",label:"AudioBridgeSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'// Assets/Scripts/Systems/Audio/AudioBridgeSO.cs\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Audio Bridge")]\npublic class AudioBridgeSO : BridgeSO\n{\n    [SerializeField] private AudioEventChannelSO audioChannel;\n\n    // runtime-only fields\n    private GameObject audioRoot;\n    private AudioSource sfxSource;\n    private AudioSource bgmSource;\n\n    private void OnEnable()\n    {\n        // Safe in edit mode: subscribing to SO events doesn\u2019t touch the scene\n        audioChannel.OnSFXRequested += PlaySFX;\n        audioChannel.OnBGMRequested += PlayBGM;\n        audioChannel.OnStopBGMRequested += StopBGM;\n        Debug.Log("[AudioBridgeSO] Subscribed to audio events");\n    }\n\n    private void OnDisable()\n    {\n        audioChannel.OnSFXRequested -= PlaySFX;\n        audioChannel.OnBGMRequested -= PlayBGM;\n        audioChannel.OnStopBGMRequested -= StopBGM;\n        Debug.Log("[AudioBridgeSO] Unsubscribed");\n    }\n\n    // Call this from the bootstrapper during play\n    public void RuntimeInit()\n    {\n        if (!Application.isPlaying) return;        // guard edit mode\n        if (audioRoot != null) return;             // already created\n\n        audioRoot = new GameObject("[AudioBridge]");\n        Object.DontDestroyOnLoad(audioRoot);\n        sfxSource = audioRoot.AddComponent<AudioSource>();\n        bgmSource = audioRoot.AddComponent<AudioSource>();\n        bgmSource.loop = true;\n\n        Debug.Log("[AudioBridgeSO] Runtime audio root created");\n    }\n\n    private void PlaySFX(AudioClip clip)\n    {\n        if (clip == null || sfxSource == null) return;\n        sfxSource.PlayOneShot(clip);\n        Debug.Log($"[AudioBridgeSO] Playing SFX: {clip.name}");\n    }\n\n    private void PlayBGM(AudioClip clip)\n    {\n        if (clip == null || bgmSource == null) return;\n        bgmSource.clip = clip;\n        bgmSource.Play();\n        Debug.Log($"[AudioBridgeSO] Playing BGM: {clip.name}");\n    }\n\n    private void StopBGM()\n    {\n        if (bgmSource == null) return;\n        bgmSource.Stop();\n        Debug.Log("[AudioBridgeSO] Stopped BGM");\n    }\n}\n\n'})})}),(0,t.jsx)(o.A,{value:"1",label:"AudioEventChannelSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System;\n\n[CreateAssetMenu(menuName = "Events/Audio Event Channel")]\npublic class AudioEventChannelSO : ScriptableObject, IRuntimeInitializable\n{\n    public event Action<AudioClip> OnSFXRequested;\n    public event Action<AudioClip> OnBGMRequested;\n    public event Action OnStopBGMRequested;\n\n    public void RaiseSFX(AudioClip clip)\n    {\n        Debug.Log($"[AudioEventChannelSO] Play SFX: {clip?.name}");\n        OnSFXRequested?.Invoke(clip);\n    }\n\n    public void RaiseBGM(AudioClip clip)\n    {\n        Debug.Log($"[AudioEventChannelSO] Play BGM: {clip?.name}");\n        OnBGMRequested?.Invoke(clip);\n    }\n\n    public void RaiseStopBGM()\n    {\n        Debug.Log("[AudioEventChannelSO] Stop BGM");\n        OnStopBGMRequested?.Invoke();\n    }\n}\n'})})})]}),"\n",(0,t.jsx)(n.h3,{id:"scene-system-channel--bridge",children:"Scene System (Channel + Bridge)"}),"\n",(0,t.jsxs)(n.p,{children:["This scene system is a centralized scene transitions so gameplay/UI simply request ",(0,t.jsx)(n.code,{children:"loads"}),"/",(0,t.jsx)(n.code,{children:"unloads"})," ",(0,t.jsx)(n.em,{children:"without"})," knowing how scenes are managed."]}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(o.A,{value:"2",label:"SceneBridgeSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing UnityEngine.SceneManagement;\n\n[CreateAssetMenu(menuName = "Game/Scene Bridge")]\npublic class SceneBridgeSO : BridgeSO\n{\n    [SerializeField] private SceneEventChannelSO sceneChannel;\n\n    private void OnEnable()\n    {\n        sceneChannel.OnSceneLoadRequested += LoadScene;\n        sceneChannel.OnSceneUnloadRequested += UnloadScene;\n        Debug.Log("[SceneBridgeSO] Subscribed to scene events");\n    }\n\n    private void OnDisable()\n    {\n        sceneChannel.OnSceneLoadRequested -= LoadScene;\n        sceneChannel.OnSceneUnloadRequested -= UnloadScene;\n        Debug.Log("[SceneBridgeSO] Unsubscribed");\n    }\n\n    private void LoadScene(string sceneName)\n    {\n        Debug.Log($"[SceneBridgeSO] Begin loading scene \'{sceneName}\'");\n        SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Single); // edit this accordingly if you are doing Additive\n    }\n\n    private void UnloadScene(string sceneName)\n    {\n        Debug.Log($"[SceneBridgeSO] Begin unloading scene \'{sceneName}\'");\n        SceneManager.UnloadSceneAsync(sceneName);\n    }\n}\n\n\n'})})}),(0,t.jsx)(o.A,{value:"1",label:"SceneEventChannelSO.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System;\n\n[CreateAssetMenu(menuName = "Events/Scene Event Channel")]\npublic class SceneEventChannelSO : ScriptableObject\n{\n    public event Action<string> OnSceneLoadRequested;\n    public event Action<string> OnSceneUnloadRequested;\n\n    public void RaiseLoad(string sceneName)\n    {\n        Debug.Log($"[SceneEventChannelSO] Load requested: {sceneName}");\n        OnSceneLoadRequested?.Invoke(sceneName);\n    }\n\n    public void RaiseUnload(string sceneName)\n    {\n        Debug.Log($"[SceneEventChannelSO] Unload requested: {sceneName}");\n        OnSceneUnloadRequested?.Invoke(sceneName);\n    }\n}\n\n'})})})]}),"\n",(0,t.jsx)(n.h3,{id:"minimal-ui-triggers-for-demo",children:"Minimal UI Triggers (for demo)"}),"\n",(0,t.jsxs)(n.p,{children:["These are lightweight ",(0,t.jsx)(n.code,{children:"MonoBehaviours"})," to wire to Unity UI Buttons and call the channels only. There are two ways to do this:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Via ",(0,t.jsx)(n.code,{children:"Bootstrap"})," registry, or"]}),"\n",(0,t.jsx)(n.li,{children:"Reference the channel SO on inspector. Either way works."}),"\n"]}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(o.A,{value:"1",label:"SaveButtonUI.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"using UnityEngine;\n\npublic class SaveButtonUI : MonoBehaviour\n{\n    private SaveEventChannelSO saveChannel;\n\n    private void Awake()\n    {\n        // Automatically gets the globally registered SaveEventChannelSO bridge or channel\n        saveChannel = Bootstrap.Resolve<SaveEventChannelSO>();\n    }\n\n    public void DoSave() => saveChannel.RaiseSave();\n    public void DoLoad() => saveChannel.RaiseLoad();\n}\n\n\n"})})}),(0,t.jsx)(o.A,{value:"2",label:"AudioButtonUI.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"using UnityEngine;\n\npublic class AudioButtonUI : MonoBehaviour\n{\n    // serialize in inspector\n    [SerializeField] private AudioEventChannelSO audioChannel;\n    [SerializeField] private AudioClip sfxClip;\n    [SerializeField] private AudioClip bgmClip;\n\n    public void PlaySFX() => audioChannel.RaiseSFX(sfxClip);\n    public void PlayBGM() => audioChannel.RaiseBGM(bgmClip);\n    public void StopBGM() => audioChannel.RaiseStopBGM();\n}\n\n"})})}),(0,t.jsx)(o.A,{value:"empty",label:"SceneButtonUI.cs",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\n\npublic class SceneButtonUI : MonoBehaviour\n{\n    // serialize in inspector\n    [SerializeField] private SceneEventChannelSO sceneChannel;\n    [SerializeField] private string sceneToLoad = "Scene_Level1";\n    [SerializeField] private string sceneToUnload = "Scene_Level1";\n\n    public void LoadLevel() => sceneChannel.RaiseLoad(sceneToLoad);\n    public void UnloadLevel() => sceneChannel.RaiseUnload(sceneToUnload);\n}\n'})})})]}),"\n",(0,t.jsxs)(n.h3,{id:"minimal-isaveable-demo-component",children:["Minimal ",(0,t.jsx)(n.code,{children:"ISaveable"})," demo component"]}),"\n",(0,t.jsxs)(n.p,{children:["The purpose of this component is to show a concrete object participating in the global Save subsystem. It self-registers so ",(0,t.jsx)(n.code,{children:"SaveRegistry.SaveAll/LoadAll"})," actually captures and restores something visible."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="PlayerHealthSaveable.cs"',children:'// Assets/Scripts/Systems/Save/Demo/PlayerHealthSaveable.cs\nusing UnityEngine;\n\npublic class PlayerHealthSaveable : MonoBehaviour, ISaveable\n{\n    [SerializeField] private string uniqueId = "Player01"; // ensure uniqueness if you have multiple\n    [SerializeField] private int maxHealth = 100;\n    [SerializeField] private int currentHealth = 100;\n\n    private void OnEnable()\n    {\n        SaveRegistry.Register(this);\n        Debug.Log($"[PlayerHealthSaveable] Registered {uniqueId} ({currentHealth}/{maxHealth})");\n    }\n\n    private void OnDisable()\n    {\n        SaveRegistry.Unregister(this);\n        Debug.Log($"[PlayerHealthSaveable] Unregistered {uniqueId}");\n    }\n\n    public string GetUniqueID() => uniqueId;\n\n    public object CaptureState()\n    {\n        var state = new State { max = maxHealth, cur = currentHealth, x = transform.position.x, y = transform.position.y, z = transform.position.z };\n        Debug.Log($"[PlayerHealthSaveable] Capture {uniqueId}: {currentHealth}/{maxHealth} @ {transform.position}");\n        return state;\n    }\n\n    public void RestoreState(object state)\n    {\n        if (state is State s)\n        {\n            maxHealth = s.max;\n            currentHealth = s.cur;\n            transform.position = new Vector3(s.x, s.y, s.z);\n            Debug.Log($"[PlayerHealthSaveable] Restore {uniqueId}: {currentHealth}/{maxHealth} @ {transform.position}");\n        }\n        else\n        {\n            Debug.LogWarning($"[PlayerHealthSaveable] Bad state for {uniqueId}");\n        }\n    }\n\n    [System.Serializable]\n    private struct State { public int max; public int cur; public float x, y, z; }\n\n    // quick demo helpers so you can change state in play mode:\n    [ContextMenu("Damage 10")] private void Damage10() { currentHealth = Mathf.Max(0, currentHealth - 10); Debug.Log($"[PlayerHealthSaveable] {uniqueId} took 10 \u2192 {currentHealth}"); }\n    [ContextMenu("Heal 10")]   private void Heal10()   { currentHealth = Mathf.Min(maxHealth, currentHealth + 10); Debug.Log($"[PlayerHealthSaveable] {uniqueId} healed 10 \u2192 {currentHealth}"); }\n    [ContextMenu("Nudge +1x")] private void Nudge()    { transform.position += Vector3.right; Debug.Log($"[PlayerHealthSaveable] {uniqueId} moved \u2192 {transform.position}"); }\n}\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Add this component to a GameObject in ",(0,t.jsx)(n.code,{children:"Scene_Main"})," and/or ",(0,t.jsx)(n.code,{children:"Scene_Level1"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Use the component\u2019s ",(0,t.jsx)(n.em,{children:"context menu items"})," during Play (or expose real gameplay changes)."]}),"\n",(0,t.jsx)(n.li,{children:"Click your Save/Load UI buttons to see capture/restore logs and effects."}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"auto-register-isaveable-helper-demo-component",children:["Auto Register ",(0,t.jsx)(n.code,{children:"ISaveable"})," Helper demo component"]}),"\n",(0,t.jsxs)(n.p,{children:["If you prefer to keep your domain components clean and centralize registration, use a tiny helper that auto-registers any ",(0,t.jsx)(n.code,{children:"ISaveable"})," on the same GameObject as such:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="SaveableAutoRegister.cs"',children:'\nusing UnityEngine;\n\npublic class SaveableAutoRegister : MonoBehaviour, ISaveable\n{\n    [SerializeField] private MonoBehaviour targetComponent; // must implement ISaveable\n    private ISaveable target;\n\n    private void Awake()\n    {\n        if (targetComponent is ISaveable s) target = s;\n        else\n        {\n            // fall back to first ISaveable on this GameObject (optional convenience)\n            target = GetComponent<ISaveable>();\n            if (target == (ISaveable) this) target = null; // avoid self if only this component exists\n        }\n\n        if (target == null)\n            Debug.LogError("[SaveableAutoRegister] No valid ISaveable target found on this GameObject.");\n    }\n\n    private void OnEnable()\n    {\n        if (target != null) SaveRegistry.Register(this);\n    }\n\n    private void OnDisable()\n    {\n        if (target != null) SaveRegistry.Unregister(this);\n    }\n\n    public string GetUniqueID() => target?.GetUniqueID() ?? "[null]";\n    public object CaptureState() => target?.CaptureState();\n    public void RestoreState(object state) => target?.RestoreState(state);\n}\n\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"Usage:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Put your domain logic in a plain component that implements ",(0,t.jsx)(n.code,{children:"ISaveable"})," (e.g., ",(0,t.jsx)(n.code,{children:"ChestSaveable"}),", ",(0,t.jsx)(n.code,{children:"QuestFlagSaveable"}),", ",(0,t.jsx)(n.code,{children:"PlayerHeathSaveable"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Add ",(0,t.jsx)(n.code,{children:"SaveableAutoRegister"})," to the same GameObject and ",(0,t.jsx)(n.strong,{children:"assign"})," targetComponent to that domain component."]}),"\n",(0,t.jsxs)(n.li,{children:["This ",(0,t.jsx)(n.strong,{children:"standardizes"})," registration/unregistration without repeating boilerplate in every saveable script."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For instance, we have this code with no registration inside:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="ChestSaveable.cs"',children:'// Assets/Scripts/Systems/Save/Demo/ChestSaveable.cs\nusing UnityEngine;\n\npublic class ChestSaveable : MonoBehaviour, ISaveable\n{\n    [SerializeField] private string uniqueId = "Chest_A";\n    [SerializeField] private bool isOpen;\n    [SerializeField] private Vector3 closedOffset = Vector3.zero;\n    [SerializeField] private Vector3 openOffset = new Vector3(0, 0.5f, 0);\n\n    public string GetUniqueID() => uniqueId;\n\n    public object CaptureState()\n    {\n        return new State { open = isOpen, x = transform.position.x, y = transform.position.y, z = transform.position.z };\n    }\n\n    public void RestoreState(object state)\n    {\n        if (state is State s)\n        {\n            isOpen = s.open;\n            transform.position = new Vector3(s.x, s.y, s.z);\n            // add more logic to restore closed/open offset etc\n        }\n    }\n\n    [ContextMenu("Toggle Open/Close")]\n    private void Toggle()\n    {\n        isOpen = !isOpen;\n        transform.position += isOpen ? openOffset : -openOffset;\n    }\n\n     // edit state as needed to store more things\n    [System.Serializable]\n    private struct State { public bool open; public float x, y, z; }\n}\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"SaveableAutoRegister"}),", set ",(0,t.jsx)(n.code,{children:"targetComponent"})," to be that ",(0,t.jsx)(n.code,{children:"ChestSaveable"})," instance (or leave blank to auto-pick the first ISaveable on the GameObject)."]}),"\n",(0,t.jsx)(n.h2,{id:"the-demo",children:"The Demo"}),"\n",(0,t.jsx)(n.h3,{id:"create-so-bridges-channels-and-bootstrapconfig",children:"Create SO Bridges, Channels, and BootstrapConfig"}),"\n",(0,t.jsx)(n.p,{children:"Create three Event Channel assets in Assets/Events:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"SaveEventChannel.asset"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AudioEventChannel.asset"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"SceneEventChannel.asset"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Create three Bridge assets:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SaveBridge.asset"})," and assign ",(0,t.jsx)(n.code,{children:"SaveEventChannel"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AudioBridge.asset"})," and assign ",(0,t.jsx)(n.code,{children:"AudioEventChannel"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SceneBridge.asset"})," and assign ",(0,t.jsx)(n.code,{children:"SceneEventChannel"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Create ",(0,t.jsx)(n.code,{children:"Assets/Game/BootstrapConfig.asset"})," and assign:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bridges"}),": SaveBridge, AudioBridge, SceneBridge"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Channels"}),": SaveEventChannel, AudioEventChannel, SceneEventChannel"]}),"\n"]}),"\n",(0,t.jsx)(d.A,{path:s(15119).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h3,{id:"create-scenes",children:"Create Scenes"}),"\n",(0,t.jsx)(n.p,{children:"Create at least three scenes, e.g: Bootstrap, Main and Level 1. Here's one ugly but functional setup:"}),"\n",(0,t.jsx)(d.A,{path:s(83557).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(d.A,{path:s(92390).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(d.A,{path:s(66866).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h4,{id:"the-bootstrap-scene",children:"The Bootstrap Scene"}),"\n",(0,t.jsxs)(n.p,{children:["Attach the ",(0,t.jsx)(n.code,{children:"GameBoostrap"})," script an empty gameobject in the Bootstrap scene. This will initialize the config upon run, and immediately load the Main scene."]}),"\n",(0,t.jsx)(n.h4,{id:"ui",children:"UI"}),"\n",(0,t.jsx)(n.p,{children:"We made the button groups a prefab (this is like a HUD in the game), and both scenes have the same Player and Chest prefab."}),"\n",(0,t.jsx)(n.p,{children:"Then for each UI group, attach the corresponding Button UI script:"}),"\n",(0,t.jsx)(d.A,{path:s(57004).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.p,{children:"And set the callbacks accordingly:"}),"\n",(0,t.jsx)(d.A,{path:s(577).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.p,{children:"Do the same for scene load button, audio-related buttons, as well as load."}),"\n",(0,t.jsx)(n.p,{children:"For the Player, attach the PlayerHealtSaveable component:"}),"\n",(0,t.jsx)(d.A,{path:s(13626).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.p,{children:'Whereas for the "chest", try using the AutoRegister component:'}),"\n",(0,t.jsx)(d.A,{path:s(44874).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.p,{children:"Finally, dont forget to add all scenes until the Build Profiles, otherwise scene transition wont work:"}),"\n",(0,t.jsx)(d.A,{path:s(69906).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h3,{id:"running-the-demo",children:"Running the Demo"}),"\n",(0,t.jsxs)(n.p,{children:["Upon ",(0,t.jsx)(n.code,{children:"Play"}),", you should see the bootstrap system works: all bridges subscribe to the events, player and chest registered to SaveRegistry, AudioBridge is initialized and runtime AudioRoot is created."]}),"\n",(0,t.jsx)(d.A,{path:s(17285).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.p,{children:"When you load the another level, the save registry is updated based on which object is present at this level:"}),"\n",(0,t.jsx)(d.A,{path:s(74783).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.admonition,{title:"test",type:"note",children:(0,t.jsx)(n.p,{children:"You can try adding other chests like Chest_B, etc and see how the save system handles this"})}),"\n",(0,t.jsx)(n.p,{children:"All systems are live in the second scene. There's no need to set them up. There's only one Bootstrapper needed, which is in the main scene."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Apart from AudioSystem (which requires AudioSource), none of the system requires persistent object under ",(0,t.jsx)(n.code,{children:"DontDestroyOnLoad"})]}),"\n",(0,t.jsx)(n.li,{children:"Each is handled dynamically via the BridgeSOs"}),"\n",(0,t.jsxs)(n.li,{children:["The SO will be disabled ",(0,t.jsx)(n.em,{children:"if there's no more reference to it"})," anymore in the following scene."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here's a full demo recording of the Bootstrap system in action:"}),"\n",(0,t.jsx)(c.A,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/tutorials/bootstrap-demo.mov",widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h2,{id:"using-bootstrap-in-the-hybrid-architecture",children:"Using Bootstrap in the Hybrid Architecture"}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This section explains how we can implement the Bootstrap system into the Hybrid architecture explained ",(0,t.jsx)(n.a,{href:"https://natalieagus.github.io/50033/resources/general/hybrid-arch",children:"here"}),", and greatly reduce inspector-linking."]})}),"\n",(0,t.jsxs)(n.p,{children:["We can now register ",(0,t.jsx)(n.code,{children:"GameStateSO"})," inside ",(0,t.jsx)(n.code,{children:"BootstrapConfigSO"})," ",(0,t.jsx)(n.code,{children:"sharedStates"})," list, so that it enters the ",(0,t.jsx)(n.code,{children:"Bootstrap"})," registry."]}),"\n",(0,t.jsxs)(n.p,{children:["To make things easier, it should also implement the ",(0,t.jsx)(n.code,{children:"IRuntimeResettable"})," and remove any reset gameObject, and remove the use of ",(0,t.jsx)(n.code,{children:"GameStateResetter.cs"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing System;\n\n[CreateAssetMenu(menuName = "Game/Game State")]\npublic class GameStateSO : ScriptableObject, IRuntimeResettable\n{\n    public bool InDialogue { get; private set; }\n    public event Action<bool> OnDialogueChanged;\n\n    public void SetDialogue(bool active)\n    {\n        if (InDialogue == active) return;\n        InDialogue = active;\n        OnDialogueChanged?.Invoke(active);\n        Debug.Log($"[GameStateSO] Dialogue {(active ? "started" : "ended")}");\n    }\n\n    public void RuntimeReset()\n    {\n        InDialogue = false;\n        OnDialogueChanged = null;\n        Debug.Log("[GameStateSO] Reset");\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Then ",(0,t.jsx)(n.code,{children:"DialogueController"})," can utilise the Registry:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\n\npublic class DialogueController : MonoBehaviour\n{\n    [Header("Data (Optional, can be passed at runtime)")]\n    [SerializeField] private DialogueData currentDialogue;\n\n    private InputReader inputReader;\n    private GameStateSO gameState;\n\n    private int currentIndex = 0;\n    private bool isActive = false;\n\n    private void Awake()\n    {\n        // Resolve global systems & state\n        inputReader = Bootstrap.Resolve<InputReader>();\n        gameState   = Bootstrap.Resolve<GameStateSO>();\n\n        if (inputReader == null)\n            Debug.LogError("[DialogueController] Missing InputReader in registry!");\n        if (gameState == null)\n            Debug.LogError("[DialogueController] Missing GameStateSO in registry!");\n    }\n\n     // other methods as usual\n\n}\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"unifying-the-systems",children:"Unifying the Systems"}),"\n",(0,t.jsxs)(n.p,{children:["When the game launches, the ",(0,t.jsx)(n.strong,{children:"BootstrapConfigSO"})," asset executes its initialization sequence. It registers all bridges such as ",(0,t.jsx)(n.code,{children:"AudioBridgeSO"}),", ",(0,t.jsx)(n.code,{children:"SaveBridgeSO"}),", and ",(0,t.jsx)(n.code,{children:"SceneBridgeSO"}),", and through reflection it automatically registers every referenced ScriptableObject found inside them\u2014this includes event channels and shared states like ",(0,t.jsx)(n.code,{children:"GameStateSO"}),". Each system that implements ",(0,t.jsx)(n.code,{children:"IRuntimeResettable"})," is reset first, ensuring a clean startup, and then any class that implements ",(0,t.jsx)(n.code,{children:"IRuntimeInitializable"})," is initialized. By the time the scene loads, every subsystem exists in a unified runtime registry called ",(0,t.jsx)(n.code,{children:"Bootstrap"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Because of this, there is ",(0,t.jsx)("span",{class:"orange-bold",children:"no need"})," to drag ScriptableObjects into individual prefabs or scene objects. Every component can access shared data or channels directly through the same global registry. For instance, a gameplay script such as a ",(0,t.jsx)(n.code,{children:"DialogueController"}),", ",(0,t.jsx)(n.code,{children:"PlayerHealth"}),", or ",(0,t.jsx)(n.code,{children:"SaveButtonUI"})," can simply resolve what it needs during ",(0,t.jsx)(n.code,{children:"Awake()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"private GameStateSO gameState;\nprivate AudioEventChannelSO audioChannel;\n\nprivate void Awake()\n{\n    gameState = Bootstrap.Resolve<GameStateSO>();\n    audioChannel = Bootstrap.Resolve<AudioEventChannelSO>();\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Once resolved, these references behave exactly like serialized ones. You can call any event or update state as usual:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"gameState.SetDialogue(true);\naudioChannel.RaiseSFX(hitClip);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All systems remain decoupled, yet share the same single source of truth.\nThe benefit of this design is that ",(0,t.jsx)(n.strong,{children:"BootstrapConfigSO"})," controls initialization order and lifetime deterministically while every other script relies on the same lightweight API:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"var audio = Bootstrap.Resolve<AudioEventChannelSO>();\naudio.RaiseBGM(musicClip);\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["In practice, this means no dragging, no duplicate references across prefabs, and no confusion about which instance of ",(0,t.jsx)(n.code,{children:"GameStateSO"})," or ",(0,t.jsx)(n.code,{children:"AudioEventChannelSO"})," is active. One bootstrap initializes everything once; every other script simply resolves and uses it."]})}),"\n",(0,t.jsx)(n.h2,{id:"epilogue",children:"Epilogue"}),"\n",(0,t.jsxs)(n.p,{children:["In this demo, we never really see ",(0,t.jsx)(n.code,{children:"OnDisable"})," being called on the bridges."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"OnDisable()"})," on a ScriptableObject runs whenever Unity ",(0,t.jsx)(n.em,{children:"unloads"})," that SO instance: exiting Play Mode (domain reload on), assembly reload/recompile, asset unload (because no strong references), addressable/references released, or an explicit unload call. In our current setup, we keep Bridges referenced for the ",(0,t.jsx)("span",{class:"orange-bold",children:"whole"})," session (instance-event subscriptions + optional keep-alive holder), so they rarely unload mid-game\u2014hence you don\u2019t see ",(0,t.jsx)(n.code,{children:"OnDisable()"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Below are two small, controlled demos we can add to ",(0,t.jsx)(n.strong,{children:"force"})," an SO to unload and watch ",(0,t.jsx)(n.code,{children:"OnDisable()"})," fire."]}),"\n",(0,t.jsx)(n.h4,{id:"demo-1-explicitly-drop-refs-and-unload",children:"Demo 1: Explicitly drop refs and unload"}),"\n",(0,t.jsxs)(n.p,{children:["This creates a tiny dev tool that clears the persistent references and calls ",(0,t.jsx)(n.code,{children:"Resources.UnloadUnusedAssets()"}),". With no strong refs left, Unity unloads the Bridge and you\u2019ll see its ",(0,t.jsx)(n.code,{children:"OnDisable()"})," log."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Assets/Scripts/Dev/DemoUnloadSO.cs\nusing UnityEngine;\nusing System.Collections;\n\npublic class DemoUnloadSO : MonoBehaviour\n{\n    [SerializeField] private ScriptableObject[] refs; // assign the Bridges/Channels you want to unload\n    [SerializeField] private CoreRefsHolder holder;   // the keep-alive component you created at bootstrap (optional)\n\n    [ContextMenu("Drop Refs And Unload")]\n    private void DropRefsAndUnload()\n    {\n        // 1) sever your own references\n        refs = null;\n\n        // 2) sever the keep-alive references, if you use CoreRefsHolder\n        if (holder != null) holder.keepAlive = null;\n\n        // 3) kick the GC and unload unused assets (SO OnDisable() should fire now)\n        StartCoroutine(UnloadSoon());\n    }\n\n    private IEnumerator UnloadSoon()\n    {\n        System.GC.Collect();\n        yield return null; // let a frame pass so references truly go dead\n        var op = Resources.UnloadUnusedAssets();\n        yield return op;\n        Debug.Log("[DemoUnloadSO] UnloadUnusedAssets completed");\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Put this on an empty GameObject in your scene. Assign the ",(0,t.jsx)(n.code,{children:"SaveBridgeSO"})," (and/or others) into ",(0,t.jsx)(n.code,{children:"refs"}),", and assign your ",(0,t.jsx)(n.code,{children:"[CoreRoot]"}),"\u2019s ",(0,t.jsx)(n.code,{children:"CoreRefsHolder"})," if you\u2019re using it. Enter Play, run ",(0,t.jsx)(n.strong,{children:"Drop Refs And Unload"})," from the component\u2019s context menu, and watch the Console: the Bridge\u2019s ",(0,t.jsx)(n.code,{children:"OnDisable()"})," should print."]}),"\n",(0,t.jsx)(n.h4,{id:"demo-2-reproduce-the-unsubscribed-on-scene-change-case",children:"Demo 2: Reproduce the \u201cunsubscribed on scene change\u201d case"}),"\n",(0,t.jsxs)(n.p,{children:["This shows the difference between static vs instance subscriptions. Flip the SaveBridge back to ",(0,t.jsx)(n.strong,{children:"static method group"})," subscriptions, remove the keep-alive holder, start in ",(0,t.jsx)(n.code,{children:"Scene_Main"}),", then load another scene. Because nothing anchors the Bridge, Unity unloads it during the scene swap and you\u2019ll see ",(0,t.jsx)(n.code,{children:"OnDisable()"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// SaveBridgeSO.cs (temporary for demo only)\nprivate void OnEnable()\n{\n    saveChannel.OnSaveRequested += SaveRegistry.SaveAll;   // static (no target)\n    saveChannel.OnLoadRequested += SaveRegistry.LoadAll;   // static\n    Debug.Log("[SaveBridgeSO] Subscribed (STATIC demo)");\n}\n\nprivate void OnDisable()\n{\n    saveChannel.OnSaveRequested -= SaveRegistry.SaveAll;\n    saveChannel.OnLoadRequested -= SaveRegistry.LoadAll;\n    Debug.Log("[SaveBridgeSO] Unsubscribed (STATIC demo)");\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Load ",(0,t.jsx)(n.code,{children:"Scene_Level1"})," with ",(0,t.jsx)(n.code,{children:"LoadSceneMode.Single"})," and observe ",(0,t.jsx)(n.code,{children:"[SaveBridgeSO] Unsubscribed (STATIC demo)"}),". Then restore the ",(0,t.jsx)(n.strong,{children:"instance"})," handler version to keep it alive."]}),"\n",(0,t.jsxs)(n.h3,{id:"so-when-do-bridge-sos-actually-ondisable-naturally",children:["So when do Bridge SOs actually ",(0,t.jsx)(n.code,{children:"OnDisable()"})," naturally?"]}),"\n",(0,t.jsxs)(n.p,{children:["Bridges are ",(0,t.jsx)(n.code,{children:"ScriptableObjects"}),". They disable when Unity ",(0,t.jsx)(n.em,{children:"unloads"})," them. In many game architecture they often persist \u201cforever\u201d because we keep strong references (",(0,t.jsx)(n.code,{children:"BootstrapConfig"}),", instance-event subscriptions, or optional keep-alive holder)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Not every Bridge needs to live for the whole app."})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Think in scopes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Global bridges"})," are the ones your game always needs (Audio, Save, global Scene control). They ",(0,t.jsx)("span",{class:"orange-bold",children:"should"})," stay alive from startup to quit. Keep them referenced (",(0,t.jsx)(n.code,{children:"BootstrapConfig"}),", optional keep-alive holder) and subscribe with ",(0,t.jsx)(n.strong,{children:"instance"})," methods so they persist across scene loads."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Scoped/temporary bridges"})," are tied to a particular feature, level pack, or debug tool. These are good candidates to unload when that scope ends. Examples:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A level-specific ",(0,t.jsx)(n.code,{children:"SpawnSystem"})," that only exists in \u201cDungeonPack\u201d."]}),"\n",(0,t.jsx)(n.li,{children:"A minigame\u2019s Input remapper that shouldn\u2019t affect the main game."}),"\n",(0,t.jsx)(n.li,{children:"A tutorial tips dispatcher used only in the first two scenes."}),"\n",(0,t.jsxs)(n.li,{children:["A seasonal/limited-time event system loaded from an ",(0,t.jsx)(n.code,{children:"Addressable"})," bundle."]}),"\n",(0,t.jsx)(n.li,{children:"A profiling/QA bridge you load in dev builds but unload in retail."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["A Bridge subscribed with instance methods won\u2019t disable ",(0,t.jsx)(n.strong,{children:"as long as the channel and the bridge both remain referenced"}),". If you unload the ",(0,t.jsx)(n.strong,{children:"channel"})," or you drop all strong references (including a keep-alive holder), Unity can unload the Bridge and its ",(0,t.jsx)(n.code,{children:"OnDisable()"})," will run. Instance subscriptions do not make objects immortal; they just keep the subscriber alive ",(0,t.jsx)(n.strong,{children:"through the event"})," as long as the publisher (channel) is alive."]}),"\n",(0,t.jsx)(n.h3,{id:"example-a-simple-scene-scoped-bridge-pattern",children:"Example: A simple \u201cscene-scoped bridge\u201d pattern"}),"\n",(0,t.jsx)(n.p,{children:"This keeps a Bridge alive only while a specific additive scene (or feature) is loaded."}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.p,{children:"You might want to read up about Addressables first."}),(0,t.jsx)(n.p,{children:"Addressables is Unity\u2019s built-in system for loading content on demand by a string \u201caddress,\u201d instead of bundling everything into every scene. You mark assets (prefabs, textures, ScriptableObjects, scenes, audio, etc.) as \u201cAddressable,\u201d give them an address or label, and then load/unload them at runtime asynchronously. Under the hood it manages AssetBundles for you, but you mostly work with a simple API: Addressables.Load... and Addressables.Release(...). This allows faster startup scenes and lower memory usage. It is a little bit overkill for 50.033 project though."})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// SceneScopedBootstrap.cs \u2014 lives in your additive scene (e.g., DungeonPack)\n// Loads the bridge via Addressables and releases it when the scene unloads.\nusing UnityEngine;\nusing UnityEngine.AddressableAssets;\nusing UnityEngine.ResourceManagement.AsyncOperations;\n\npublic class SceneScopedBootstrap : MonoBehaviour\n{\n    [SerializeField] private string bridgeAddress = "DungeonSpawnBridge"; // Addressables address\n    private AsyncOperationHandle<DungeonSpawnBridgeSO> handle;\n    private DungeonSpawnBridgeSO bridge;\n\n    private void OnEnable()\n    {\n        handle = Addressables.LoadAssetAsync<DungeonSpawnBridgeSO>(bridgeAddress);\n        handle.Completed += op =>\n        {\n            if (op.Status != AsyncOperationStatus.Succeeded) { Debug.LogError("Load failed"); return; }\n            bridge = op.Result;\n            // Touch to ensure OnEnable subscriptions are active this session.\n            bridge.RuntimeInit(); // optional if it needs a runner GO\n            Debug.Log("[SceneScopedBootstrap] Bridge ready");\n        };\n    }\n\n    private void OnDisable()\n    {\n        if (handle.IsValid()) Addressables.Release(handle);\n        bridge = null; // After release and no other refs, OnDisable() on the SO will fire.\n        Debug.Log("[SceneScopedBootstrap] Bridge released");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// DungeonSpawnBridgeSO.cs \u2014 the feature-specific bridge.\n// Subscribes with instance methods; unsubscribes on disable.\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "Game/Dungeon/Spawn Bridge")]\npublic class DungeonSpawnBridgeSO : ScriptableObject\n{\n    [SerializeField] private DungeonEventChannelSO channel; // this channel also lives in the pack\n\n    private void OnEnable()\n    {\n        if (channel == null) return;\n        channel.OnWaveRequested += OnWaveRequested;   // instance methods\n        channel.OnClearRequested += OnClearRequested;\n        Debug.Log("[DungeonSpawnBridgeSO] Subscribed");\n    }\n\n    private void OnDisable()\n    {\n        if (channel == null) return;\n        channel.OnWaveRequested -= OnWaveRequested;\n        channel.OnClearRequested -= OnClearRequested;\n        Debug.Log("[DungeonSpawnBridgeSO] Unsubscribed");\n    }\n\n    public void RuntimeInit() { /* optional: spawn runners, pools, etc. */ }\n\n    private void OnWaveRequested(int wave) { /* spawn logic */ }\n    private void OnClearRequested() { /* cleanup logic */ }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When you unload the additive scene or call ",(0,t.jsx)(n.code,{children:"Addressables.Release"}),", there are no more strong references to the Bridge or its Channel; Unity unloads them and ",(0,t.jsx)(n.code,{children:"OnDisable()"})," runs. That\u2019s exactly when you ",(0,t.jsx)(n.em,{children:"want"})," a temporary subsystem to tear down."]}),"\n",(0,t.jsx)(n.h4,{id:"when-should-bridges-be-persistent",children:"When should bridges be persistent?"}),"\n",(0,t.jsx)(n.p,{children:"Keep them global if they represent core, reusable services that any scene may need at any time, and they don\u2019t waste memory sitting around. Audio, Save, global Scene control, Localization, Analytics dispatchers are typical \u201calways on\u201d bridges."}),"\n",(0,t.jsx)(n.h4,{id:"when-should-bridges-be-unloadable",children:"When should bridges be unloadable?"}),"\n",(0,t.jsx)(n.p,{children:"Make them scoped if they bind to content that isn\u2019t always loaded, if they carry notable memory/runtime cost (pools, large data tables), or if keeping them around risks interfering with other modes of play. In those cases, load them alongside their content (Addressables or additive scene), and release them when the content goes away."}),"\n",(0,t.jsx)(n.admonition,{title:"final note",type:"note",children:(0,t.jsxs)(n.p,{children:["Instance subscriptions make lifetime ",(0,t.jsx)(n.strong,{children:"predictable"})," while the publisher (channel) and a strong reference exist; they don\u2019t make the object permanent. If you want a Bridge to disappear naturally, drop the strong references (e.g., release Addressables handle, clear keep-alive holder, unload the additive scene and its channel). If you want it to stay, keep a reference in your Bootstrap (and optionally a keep-alive holder) and you\u2019ll get a stable, global subsystem."]})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(b,{...e})}):b(e)}},66866:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-16-11-01-34-55f9aeea1064a90ffa291d4b38a10671.png"},15119:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-17-39-6c39d67fe5738a72bd238278cdff4553.png"},83557:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-18-18-f4a404a3ce04cc51334780b3a3cb4fc8.png"},92390:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-18-48-e2614d1f71237bc54465c0310d827c23.png"},57004:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-20-41-79c6f417e77651de0e48c18c4aafda6d.png"},577:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-20-53-f703c5ad48eb16bb9787cffb5b55dbfe.png"},13626:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-21-08-1990627899fffc928b5e71c516fe4222.png"},44874:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-21-22-5e1d937332527e27c9c6f5a3ecbf2648.png"},69906:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-21-53-037421145791048c13f138a23346dfcd.png"},17285:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-23-45-4e8eae74942cd437def976cd1f94ecb6.png"},74783:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2025-10-17-15-24-15-d2cbdd086c069ca3b1b313a3d694a9fb.png"}}]);