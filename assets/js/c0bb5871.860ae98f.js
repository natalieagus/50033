"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[8417],{2121:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"general/sprite-resolver","title":"Using Sprite Resolver With Sprite Library","description":"Goal: to make Animator run purely on Category/Label, while you hot-swap the SpriteLibraryAsset at runtime and not care about which sprite is being shown.","source":"@site/resources/general/sprite-resolver.md","sourceDirName":"general","slug":"/general/sprite-resolver","permalink":"/50033/resources/general/sprite-resolver","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Diving into Unity Architecture Patterns","permalink":"/50033/resources/general/patterns"},"next":{"title":"Object Pooling","permalink":"/50033/resources/general/object-pooling"}}');var t=r(74848),s=r(28453),a=(r(53398),r(19894),r(88761));r(89166);const l={sidebar_position:6},o="Using Sprite Resolver With Sprite Library",c={},d=[{value:"Step 1: Install 2D Animation Package",id:"step-1-install-2d-animation-package",level:2},{value:"Step 2: Preparing the Spritesheets",id:"step-2-preparing-the-spritesheets",level:2},{value:"Naming Convention",id:"naming-convention",level:3},{value:"Sprite slicing and import settings",id:"sprite-slicing-and-import-settings",level:3},{value:"Workflow Overview",id:"workflow-overview",level:2},{value:"Monolithic Workflow (all-in-one libraries) Overview",id:"monolithic-workflow-all-in-one-libraries-overview",level:3},{value:"Modular Workflow Overview",id:"modular-workflow-overview",level:3},{value:"Visual Summary",id:"visual-summary",level:3},{value:"Creating the SpriteLibraryAsset",id:"creating-the-spritelibraryasset",level:2},{value:"Manual Creation of SpriteLibraryAsset",id:"manual-creation-of-spritelibraryasset",level:3},{value:"Batch Creation of SpriteLibraryAsset",id:"batch-creation-of-spritelibraryasset",level:3},{value:"Common Filename Structure of Spritesheets",id:"common-filename-structure-of-spritesheets",level:4},{value:"Why This Matters",id:"why-this-matters",level:4},{value:"JSON Config Format for Sprite Library Generation",id:"json-config-format-for-sprite-library-generation",level:4},{value:"Common Fields",id:"common-fields",level:5},{value:"Categories Without Style IDs",id:"categories-without-style-ids",level:4},{value:"Categories With Style IDs",id:"categories-with-style-ids",level:4},{value:"JSON Example",id:"json-example",level:4},{value:"Spritesheet Path",id:"spritesheet-path",level:4},{value:"Batch File (Modular)",id:"batch-file-modular",level:4},{value:"Batch File (Monolithic)",id:"batch-file-monolithic",level:4},{value:"Workflow Details",id:"workflow-details",level:2},{value:"Monolithic Workflow (One Library Per Full Character)",id:"monolithic-workflow-one-library-per-full-character",level:3},{value:"Test Swap at Runtime",id:"test-swap-at-runtime",level:4},{value:"Modular Workflow (One Library Per Type of Sprite)",id:"modular-workflow-one-library-per-type-of-sprite",level:3},{value:"Test Swap at Runtime",id:"test-swap-at-runtime-1",level:4},{value:"Which Workflow Should I Use?",id:"which-workflow-should-i-use",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"using-sprite-resolver-with-sprite-library",children:"Using Sprite Resolver With Sprite Library"})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Goal"}),": to make Animator run ",(0,t.jsx)(n.strong,{children:"purely"})," on Category/Label, while you hot-swap the SpriteLibraryAsset at runtime and ",(0,t.jsx)(n.strong,{children:"not"})," care about which sprite is being shown."]}),(0,t.jsxs)(n.p,{children:["This approach is a good fit when you want to reuse the same animation data but present it with ",(0,t.jsx)(n.em,{children:"different"})," sprite sets. A common example is ",(0,t.jsx)(n.strong,{children:"cosmetic"})," systems in games: your character has a walk cycle, an attack animation, and a death animation, and all of those are driven purely by label changes (",(0,t.jsx)(n.code,{children:"Walk_01, Walk_02, \u2026"}),")."]})]}),"\n",(0,t.jsxs)(n.p,{children:["When creating a game, sometimes you have multiple NPCs that behave the same way (e.g: walk, attack, stunned, etc), only that they differ in skin. Instead of creating ",(0,t.jsx)(n.em,{children:"new"})," animation clips and controller per NPC, you might want to use the ",(0,t.jsx)("span",{class:"orange-bold",children:"Sprite Resolver"})," with ",(0,t.jsx)("span",{class:"orange-bold",children:"Sprite Library asset"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["You can ",(0,t.jsx)(n.strong,{children:"swap"})," the entire sprite library at runtime, so you can instantly turn the same underlying animation into a \u201cpirate\u201d skin, a \u201ccyber\u201d skin, or a \u201choliday event\u201d variant without duplicating any clips."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"This not only reduces animator workload but ensures timing and polish remain consistent across variants."})}),"\n",(0,t.jsxs)(n.p,{children:["Finally, it\u2019s useful when you want to ",(0,t.jsx)(n.strong,{children:"scale"})," to multiple platforms or art directions. You can prepare low-resolution vs high-resolution atlases (mobile vs desktop), or censored vs uncensored regional art sets, and select the correct library at load time. Because the animator only cares about labels, you don\u2019t need to maintain separate timelines, which keeps your project much leaner and easier to maintain."]}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)("span",{class:"orange-bold",children:"only"})," requirement for this method to work is to have the ",(0,t.jsx)(n.strong,{children:"same number of frames"})," for each clip, e.g: ",(0,t.jsx)(n.em,{children:"walking"})," clip contains 18 frames for ",(0,t.jsx)(n.em,{children:"ANY"})," character."]}),(0,t.jsx)(n.p,{children:"We would suggest certain naming conventions later on that matters if you want to automate the creation of your sprite library."})]}),"\n",(0,t.jsx)(n.h2,{id:"step-1-install-2d-animation-package",children:"Step 1: Install 2D Animation Package"}),"\n",(0,t.jsx)(n.p,{children:"Open Window >> Package Management >> Package Manager and search for 2D Animation Package."}),"\n",(0,t.jsx)(a.A,{path:r(77774).A,widthPercentage:"100%"}),"\n",(0,t.jsxs)(n.p,{children:["This unlocks ",(0,t.jsx)(n.strong,{children:"Sprite Library Asset"})," + ",(0,t.jsx)(n.strong,{children:"Sprite Resolver"})," workflow."]}),"\n",(0,t.jsx)(n.h2,{id:"step-2-preparing-the-spritesheets",children:"Step 2: Preparing the Spritesheets"}),"\n",(0,t.jsx)(n.p,{children:"Consider a system you have a large cast of characters or NPCs that behave identically but should look different, such as: villagers in a town, enemies in a dungeon, or units in a strategy game."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recall the goal"}),": instead of authoring separate animation controllers, you keyframe the labels once and let different sprite libraries provide the art."]}),"\n",(0,t.jsx)(n.h3,{id:"naming-convention",children:"Naming Convention"}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["You need to ",(0,t.jsx)("span",{class:"orange-bold",children:"decide"})," your naming scheme up front."]})}),"\n",(0,t.jsxs)(n.p,{children:["Make sure your sprites are ",(0,t.jsx)(n.strong,{children:"named consistently"}),". This makes it easier ",(0,t.jsx)(n.em,{children:"if you want to automate"})," the creation of the Sprite Library later on. Here we suggest a naming convention and we design batch processor around this construct."]}),"\n",(0,t.jsx)(n.p,{children:"The filename structure of your spritesheets should follow this rule:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"{Category}[_StyleId]_{Dim}_{Variant}_{Slice}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Category"}),": Body, Hairstyle, Outfit, etc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"StyleId"}),": (optional) \u2192 which design (e.g. Hairstyle_24)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dim"}),": resolution tag (e.g. 48x48)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Variant"}),": color/skin index (e.g. 01, 05)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slice"}),": frame number from slicing (e.g. 114). This can be automatically generated in Unity."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For instance (without style ID),"}),"\n",(0,t.jsx)(a.A,{path:r(13651).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Body_48x48_03_0\n"})}),"\n",(0,t.jsx)(n.p,{children:"This shows a Body category spritesheet, 48\xd748 pixel dimension, variant 03, slice 0. This sheet would have its PPU set to 48 as well."}),"\n",(0,t.jsx)(n.p,{children:"Sometimes we need a style ID as well to differentiate between hairstyles, etc:"}),"\n",(0,t.jsx)(a.A,{path:r(68321).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Hairstyle_01_48x48_01_0\n"})}),"\n",(0,t.jsx)(n.p,{children:"This mean hairstyle category, style #01, 48\xd748 pixel dimension, variant 01, slice 0."}),"\n",(0,t.jsx)(n.h3,{id:"sprite-slicing-and-import-settings",children:"Sprite slicing and import settings"}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsxs)(n.p,{children:["For each art set, your sprite sheet ",(0,t.jsx)("span",{class:"orange-bold",children:"must"})," slice into the same naming scheme."]}),(0,t.jsxs)(n.p,{children:["It is also important to ensure that each sprite has the ",(0,t.jsx)("span",{class:"orange-bold",children:"same pivot"})," (e.g., at the feet), same Pixels Per Unit (PPU), and same orientation."]})]}),"\n",(0,t.jsx)(n.p,{children:"Here's some example of such spritesheets (e.g: VillagerA and VillagerB):"}),"\n",(0,t.jsx)(a.A,{path:r(2258).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(a.A,{path:r(46439).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h2,{id:"workflow-overview",children:"Workflow Overview"}),"\n",(0,t.jsxs)(n.p,{children:["When building characters with swappable parts (Body, Hairstyle, Outfit, etc.), you have two main ways of organizing your ",(0,t.jsx)(n.code,{children:"SpriteLibraryAssets"}),". The choice you make affects how you author assets, how you set up your Animator, and how much flexibility you have for customization at runtime. Below are the two dominant patterns, with their trade-offs spelled out."]}),"\n",(0,t.jsxs)(n.p,{children:["The two approaches are ",(0,t.jsx)(n.strong,{children:"Monolithic"})," and ",(0,t.jsx)(n.strong,{children:"Modular"})," workflows."]}),"\n",(0,t.jsx)(n.h3,{id:"monolithic-workflow-all-in-one-libraries-overview",children:"Monolithic Workflow (all-in-one libraries) Overview"}),"\n",(0,t.jsxs)(n.p,{children:["In the ",(0,t.jsx)(n.strong,{children:"monolithic"})," approach, you pre-bake every part into a single ",(0,t.jsx)(n.code,{children:"SpriteLibraryAsset"}),". Each library contains all the categories (Body, Hairstyle, Outfit, etc.) for a specific full character look. For example, ",(0,t.jsx)(n.code,{children:"Character_03_24_02.asset"})," might contain Body03, Hairstyle24, Outfit02 all inside ",(0,t.jsx)("span",{class:"orange-bold",children:"one"})," file."]}),"\n",(0,t.jsxs)(n.p,{children:["Your ",(0,t.jsx)(n.strong,{children:"Player"})," GameObject is much simpler here: it only has ONE ",(0,t.jsx)(n.code,{children:"SpriteRenderer + SpriteResolver + SpriteLibrary"}),", all under the ",(0,t.jsx)(n.em,{children:"root"})," Animator. The Animator still drives the same label changes (",(0,t.jsx)(n.code,{children:"walk_114"}),", ",(0,t.jsx)(n.code,{children:"walk_115"}),", \u2026), but the ",(0,t.jsx)("span",{class:"orange-bold",children:"active"})," library asset already knows which Body/Hair/Outfit sprites to display for that skin. To change appearance at runtime, you simply assign a different monolithic asset, and the whole character swaps instantly."]}),"\n",(0,t.jsxs)(n.p,{children:["This approach is straightforward for games that only have a handful of predefined skins. However, it doesn\u2019t scale well: if you want 3 Bodies \xd7 4 Hairstyles \xd7 3 Outfits, you\u2019ll need 36 separate ",(0,t.jsx)(n.code,{children:"SpriteLibraryAsset"}),"s to cover all combinations."]}),"\n",(0,t.jsx)(n.h3,{id:"modular-workflow-overview",children:"Modular Workflow Overview"}),"\n",(0,t.jsxs)(n.p,{children:["In the ",(0,t.jsx)(n.strong,{children:"modular"})," approach, you keep each category (Body, Hairstyle, Outfit) in its own ",(0,t.jsx)(n.code,{children:"SpriteLibraryAsset"}),". Instead of baking all the art into one giant library, you generate smaller, focused libraries that hold only one category at a time."]}),"\n",(0,t.jsxs)(n.p,{children:["Your ",(0,t.jsx)(n.strong,{children:"Player"})," GameObject has ",(0,t.jsx)(n.strong,{children:"one Animator"})," at the root, but ",(0,t.jsx)("span",{class:"orange-bold",children:"each part"})," (Body, Hairstyle, Outfit) gets its own ",(0,t.jsx)(n.code,{children:"SpriteRenderer + SpriteResolver + SpriteLibrary"}),". The Animator drives label changes (e.g. ",(0,t.jsx)(n.code,{children:"walk_114 \u2192 walk_115 \u2192 walk_116"}),"), and because all libraries share the same label scheme, Body, Hair, and Outfit update together without you having to animate them separately."]}),"\n",(0,t.jsxs)(n.p,{children:["At ",(0,t.jsx)(n.strong,{children:"runtime"}),", you decide which variant to load for each category. For example, you can assign ",(0,t.jsx)(n.code,{children:"BodySpriteLibrary_03.asset"}),", ",(0,t.jsx)(n.code,{children:"HairstyleSpriteLibrary_24.asset"}),", and ",(0,t.jsx)(n.code,{children:"OutfitSpriteLibrary_02.asset"})," to the respective resolvers, and the Animator will seamlessly run them in sync. This makes modular especially powerful for ",(0,t.jsx)(n.strong,{children:"character customization systems"})," where players can freely mix and match parts."]}),"\n",(0,t.jsx)(n.h3,{id:"visual-summary",children:"Visual Summary"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Monolithic (one shared library asset)"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'PlayerCharacter (Root)\n \u251c\u2500\u2500 Components on Root:\n \u2502    \u2022 Animator\n \u2502    \u2022 SpriteLibrary (Assign CharacterX.asset here)\n \u2502\n \u251c\u2500\u2500 Body (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteResolver (Category = "Body")\n \u2502\n \u251c\u2500\u2500 Hair (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteResolver (Category = "Hairstyle")\n \u2502\n \u2514\u2500\u2500 Outfit (Child GameObject)\n      \u2022 SpriteRenderer\n      \u2022 SpriteResolver (Category = "Outfit")\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Modular (separate library assets per part)"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'PlayerCharacter (Root)\n \u251c\u2500\u2500 Components on Root:\n \u2502    \u2022 Animator\n \u2502\n \u251c\u2500\u2500 Body (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteLibrary (assign Body_X.asset or similar)\n \u2502    \u2022 SpriteResolver (Category = "Body")\n \u2502\n \u251c\u2500\u2500 Hair (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteLibrary (assign Hairstyle_X.asset or similar)\n \u2502    \u2022 SpriteResolver (Category = "Hairstyle")\n \u2502\n \u2514\u2500\u2500 Outfit (Child GameObject)\n      \u2022 SpriteRenderer\n      \u2022 SpriteLibrary (assign Outfit_X.asset or similar)\n      \u2022 SpriteResolver (Category = "Outfit")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"creating-the-spritelibraryasset",children:"Creating the SpriteLibraryAsset"}),"\n",(0,t.jsx)(n.p,{children:"There are two approaches to this: Manual or Batch Processing."}),"\n",(0,t.jsx)(n.h3,{id:"manual-creation-of-spritelibraryasset",children:"Manual Creation of SpriteLibraryAsset"}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsx)(n.p,{children:"Manual creation of the assets is tedious but it allows you to be more relaxed with the naming convention of your sprites. You can use different .png files (doesnt have to be in the same spritesheet) for each category-label pair."})}),"\n",(0,t.jsxs)(n.p,{children:["In the Project window, right click >> Create >> 2D >> Sprite Library Asset. Then open its Sprite Library Editor via the inspector and start populating it. You can organize by Category such as ",(0,t.jsx)(n.code,{children:"Body"}),", ",(0,t.jsx)(n.code,{children:"Head"}),", ",(0,t.jsx)(n.code,{children:"Weapon"}),", and Label such as ",(0,t.jsx)(n.code,{children:"Idle01"}),", ",(0,t.jsx)(n.code,{children:"Walk01"}),", ",(0,t.jsx)(n.code,{children:"Attack 01"})," etc. You should create one SpriteLibraryAsset per skin/variant."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The Animator only ever talks in Category + Label terms (Body: Walk01, Head: Smile, etc)."}),"\n",(0,t.jsxs)(n.li,{children:["Each ",(0,t.jsx)(n.code,{children:"SpriteLibraryAsset"})," is just a ",(0,t.jsx)(n.strong,{children:"dictionary"})," mapping those labels to actual sprites."]}),"\n",(0,t.jsxs)(n.li,{children:["So if VillagerA and VillagerB both have categories/labels defined the ",(0,t.jsx)("span",{class:"orange-bold",children:"same"})," way, you can ",(0,t.jsx)(n.strong,{children:"swap"})," the library, and all the existing Animator clips continue to work ",(0,t.jsx)(n.em,{children:"but the art changes"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["All variants must share the ",(0,t.jsx)("span",{class:"orange-bold",children:"SAME"})," categories/labels. Animator only cares about the label, not which art set."]})}),"\n",(0,t.jsx)(n.p,{children:"For instance, suppose we have these SpriteLibraryAssets:"}),"\n",(0,t.jsx)(a.A,{path:r(66071).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="VillagerA.asset"',children:"Categories:\n  Body:\n    Walk_01: Body_48x48_03_114.png\n    Walk_02: Body_48x48_03_115.png\n    Walk_03: Body_48x48_03_116.png\n    ...\n  Hair:\n    Walk_01: Hairstyle_01_48x48_05_112.png\n    Walk_02: Hairstyle_01_48x48_05_113.png\n    ...\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title="VillagerB.asset"',children:"Categories:\n  Body:\n    Walk_01: Body_48x48_06_114.png\n    Walk_02: Body_48x48_06_115.png\n    Walk_03: Body_48x48_06_116.png\n    ...\n  Hair:\n    Walk_01: Hairstyle_03_48x48_04_112.png\n    Walk_02: Hairstyle_03_48x48_04_113.png\n    ...\n"})}),"\n",(0,t.jsx)(n.p,{children:"In the animator timeline, we refer to them as such:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Frame 0: Body Walk_01 & Hair Walk_01\nFrame 5: Body Walk_02 & Hair Walk_02\nFrame 10: Body Walk_03 & Hair Walk_02\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then during runtime, we would swap them:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:"spriteLibrary.spriteLibraryAsset = villagerA; // uses VillagerA art\nspriteLibrary.spriteLibraryAsset = villagerB; // instantly swaps to VillagerB art\n"})}),"\n",(0,t.jsx)(n.p,{children:"For monolithic approach, you need to create ONE sprite library asset per combination. Suppose you have 3 Body spritesheets, 4 Hair spritesheets, and 2 Outfit spritesheets."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You need to create 3x4x2 = 24 ",(0,t.jsx)(n.code,{children:"SpriteLibraryAsset"}),", which is quite a hefty work"]}),"\n",(0,t.jsxs)(n.li,{children:["Each asset has ",(0,t.jsx)(n.strong,{children:"ALL"})," three categories (",(0,t.jsx)(n.code,{children:"Hair"}),", ",(0,t.jsx)(n.code,{children:"Body"}),", ",(0,t.jsx)(n.code,{children:"Outfit"}),") as shown in the screenshot above"]}),"\n",(0,t.jsxs)(n.li,{children:["Each category has labels such as ",(0,t.jsx)(n.code,{children:"Walk_01"}),", etc"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here's a sample screenshot:"}),"\n",(0,t.jsx)(a.A,{path:r(90003).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.p,{children:"For modular approach, you need to create ONE sprite library asset per type, that is:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Create 3 different ",(0,t.jsx)(n.code,{children:"SpriteLibraryAssetBody"})," for each Body type","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Each asset only has ",(0,t.jsx)(n.em,{children:"one"})," category e.g: Body, and labels such as ",(0,t.jsx)(n.code,{children:"Walk_01"}),", etc"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"And 4 for hair, as well as 2 for outfit"}),"\n",(0,t.jsxs)(n.li,{children:["In the end, you have 3+4+2 = 9 ",(0,t.jsx)(n.code,{children:"SpriteLibraryAsset"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here's a sample screenshot:"}),"\n",(0,t.jsx)(a.A,{path:r(37519).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h3,{id:"batch-creation-of-spritelibraryasset",children:"Batch Creation of SpriteLibraryAsset"}),"\n",(0,t.jsxs)(n.p,{children:["Creating sprite library asset per skin/variant is a hefty task, be it the modular or monolithic way. If you can slice your sprites consistently (same pivot, PPU, and frame count), and name all the spritesheets consistently, you can batch create the library asset. For these batch processors (both ",(0,t.jsx)(n.strong,{children:"Modular"})," and ",(0,t.jsx)(n.strong,{children:"Monolithic"}),") to work, your sprites ",(0,t.jsx)(n.strong,{children:"must"})," follow a strict filename pattern."]}),"\n",(0,t.jsx)(n.p,{children:"This is how the script knows which category, style, variant, and slice each sprite belongs to."}),"\n",(0,t.jsx)(n.h4,{id:"common-filename-structure-of-spritesheets",children:"Common Filename Structure of Spritesheets"}),"\n",(0,t.jsx)(n.p,{children:"Your spritesheet should have the following structure as name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"{Category}[_StyleId]_{Dim}_{Variant}_{Slice}\n\n"})}),"\n",(0,t.jsx)(a.A,{path:r(23978).A,widthPercentage:"50%"}),"\n",(0,t.jsx)(n.p,{children:"Explanation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Category}"}),": the type of asset (e.g., Body, Hairstyle, Outfit)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[_StyleId]"}),": ",(0,t.jsx)(n.em,{children:"optional"})," style identifier (e.g., 24 for Hairstyle #24)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Dim}"}),": the dimension string, often matching your sliced sheet (e.g., 48x48)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Variant}"}),": the color/variant index (e.g., 01, 05)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Slice}"}),": the frame number produced ",(0,t.jsx)(n.em,{children:"when Unity slices your sheet"})," (e.g., 114, 594)."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"If a category does not use StyleId, the filename has 4 parts.\nIf it does, the filename has 5 parts."})}),"\n",(0,t.jsx)(n.h4,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,t.jsx)(n.p,{children:"The batch processors:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Split"})," the name on ",(0,t.jsx)(n.code,{children:"_"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Filter"})," by category, dimension, styleId, variant, and slice range"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generate labels"})," inside the Sprite Library using your ",(0,t.jsx)(n.code,{children:"labelTemplate"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"So if your filenames don\u2019t follow the rule, the script won\u2019t know how to organize them. You are free to come up with your naming convention but you need to edit the Batch Processor's logic accordingly."}),"\n",(0,t.jsx)(n.h4,{id:"json-config-format-for-sprite-library-generation",children:"JSON Config Format for Sprite Library Generation"}),"\n",(0,t.jsxs)(n.p,{children:["You can specify the Sprite Library Rules with a JSON file placed in a specific path of your choice. Right now we choose ",(0,t.jsx)(n.code,{children:"Assets/EditorConfig"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The JSON file defines ",(0,t.jsx)(n.strong,{children:"rules"})," for each category of sprites (Body, Hairstyle, Outfit, etc.).\nEach rule tells the generator how to parse filenames, filter sprites, and build labels inside a ",(0,t.jsx)(n.code,{children:"SpriteLibraryAsset"}),"."]}),"\n",(0,t.jsx)(n.h5,{id:"common-fields",children:"Common Fields"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "category": "Body",\n  "hasStyleId": false,\n  "variants": ["03", "06", "09"],\n  "dimFilter": "48x48",\n  "labelTemplate": "walk_{Slice}",\n  "minFrame": 114,\n  "maxFrame": 137\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Explanation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"category"}),":\nThe folder name under ",(0,t.jsx)(n.code,{children:"Assets/Resources"})," that holds the sprites."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Example: ",(0,t.jsx)(n.code,{children:'"Body"'})," \u2192 looks inside ",(0,t.jsx)(n.code,{children:"Assets/Resources/Body"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"hasStyleId"})," (",(0,t.jsx)(n.code,{children:"true"})," or ",(0,t.jsx)(n.code,{children:"false"}),"):\nWhether sprite filenames for this category contain a ",(0,t.jsx)(n.strong,{children:"styleId"})," field."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Body_48x48_03_120"})," \u2192 ",(0,t.jsx)(n.code,{children:"hasStyleId = false"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Hairstyle_24_48x48_01_594"})," \u2192 ",(0,t.jsx)(n.code,{children:"hasStyleId = true"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"dimFilter"}),":\nResolution or dimension string (e.g. ",(0,t.jsx)(n.code,{children:'"48x48"'}),") used to filter which sprites are included.\nIf empty, no dimension filtering is applied."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"labelTemplate"}),":\nA string pattern that decides what labels are added inside the Sprite Library.\nIt can use placeholders:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Category}"})," \u2192 type (e.g., ",(0,t.jsx)(n.code,{children:'"Body"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{StyleId}"})," \u2192 the style identifier (if any, e.g. ",(0,t.jsx)(n.code,{children:'"24"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Dim}"})," \u2192 dimension filter string (e.g. ",(0,t.jsx)(n.code,{children:'"48x48"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Variant}"})," \u2192 variant or color ID (e.g. ",(0,t.jsx)(n.code,{children:'"01"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"{Slice}"})," \u2192 the frame/slice number (e.g. ",(0,t.jsx)(n.code,{children:'"120"'}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"walk_{Slice}"'})," \u2192 ",(0,t.jsx)(n.code,{children:"walk_114"}),", ",(0,t.jsx)(n.code,{children:"walk_115"}),", ",(0,t.jsx)(n.code,{children:"walk_116"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"{StyleId}_{Slice}"'})," \u2192 ",(0,t.jsx)(n.code,{children:"24_594"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"minFrame / maxFrame"}),":\nOptional numeric filters on the slice/frame number."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Example: ",(0,t.jsx)(n.code,{children:"minFrame=114, maxFrame=137"})," means only frames between 114\u2013137 are included."]}),"\n",(0,t.jsxs)(n.li,{children:["Leave at ",(0,t.jsx)(n.code,{children:"-1"})," to disable filtering."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"categories-without-style-ids",children:"Categories Without Style IDs"}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"hasStyleId = false"}),", you just provide ",(0,t.jsx)(n.strong,{children:"variants"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "category": "Body",\n  "hasStyleId": false,\n  "variants": ["03", "06", "09"],\n  "dimFilter": "48x48",\n  "labelTemplate": "walk_{Slice}",\n  "minFrame": 114,\n  "maxFrame": 137\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This means we will create libraries out of Spritesheets named ",(0,t.jsx)(n.code,{children:"Body_48x48_03"}),", ",(0,t.jsx)(n.code,{children:"Body_48x48_06"}),", ",(0,t.jsx)(n.code,{children:"Body_48x48_09"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each library only includes slices 114\u2013137."}),"\n",(0,t.jsxs)(n.li,{children:["Labels are formatted as ",(0,t.jsx)(n.code,{children:'"walk_{Slice}"'}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"categories-with-style-ids",children:"Categories With Style IDs"}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"hasStyleId = true"}),", you define ",(0,t.jsx)(n.strong,{children:"explicit pairs"})," of styleId and variant. This avoids parallel arrays and makes it clearer which goes with which."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "category": "Hairstyle",\n  "hasStyleId": true,\n  "pairs": [\n    { "styleId": "01", "variant": "01" },\n    { "styleId": "01", "variant": "05" },\n    { "styleId": "24", "variant": "01" },\n    { "styleId": "28", "variant": "01" },\n    { "styleId": "28", "variant": "04" }\n  ],\n  "dimFilter": "48x48",\n  "labelTemplate": "walk_{Slice}",\n  "minFrame": 112,\n  "maxFrame": 135\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This means we will create libraries out of Spritesheets named ",(0,t.jsx)(n.code,{children:"Hairstyle_01_48x48_01"}),", ",(0,t.jsx)(n.code,{children:"Hairstyle_01_48x48_05"}),", ",(0,t.jsx)(n.code,{children:"Hairstyle_24_48x48_01"}),", ",(0,t.jsx)(n.code,{children:"Hairstyle_28_48x48_01"}),", and ",(0,t.jsx)(n.code,{children:"Hairstyle_28_48x48_04_*"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"json-example",children:"JSON Example"}),"\n",(0,t.jsx)(n.p,{children:"Here's a full example of the sprite library rules in JSON format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="SpriteLibraryRules.json"',children:'[\n  {\n    "category": "Body",\n    "hasStyleId": false,\n    "variants": ["03", "06", "09"],\n    "dimFilter": "48x48",\n    "labelTemplate": "walk_{Slice}",\n    "minFrame": 114,\n    "maxFrame": 137\n  },\n  {\n    "category": "Hairstyle",\n    "hasStyleId": true,\n    "pairs": [\n      { "styleId": "01", "variant": "01" },\n      { "styleId": "01", "variant": "05" },\n      { "styleId": "24", "variant": "01" },\n      { "styleId": "28", "variant": "01" },\n      { "styleId": "28", "variant": "04" }\n    ],\n    "dimFilter": "48x48",\n    "labelTemplate": "walk_{Slice}",\n    "minFrame": 112,\n    "maxFrame": 135\n  },\n  {\n    "category": "Outfit",\n    "hasStyleId": true,\n    "pairs": [\n      { "styleId": "01", "variant": "06" },\n      { "styleId": "01", "variant": "10" },\n      { "styleId": "13", "variant": "01" },\n      { "styleId": "13", "variant": "03" },\n      { "styleId": "16", "variant": "01" },\n      { "styleId": "16", "variant": "03" }\n    ],\n    "dimFilter": "48x48",\n    "labelTemplate": "{StyleId}_{Slice}"\n  }\n]\n'})}),"\n",(0,t.jsx)(n.h4,{id:"spritesheet-path",children:"Spritesheet Path"}),"\n",(0,t.jsxs)(n.p,{children:["The spritesheets must be stored inside a folder that matches the name of its ",(0,t.jsx)(n.code,{children:"category"}),". For instance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Assets/Resources\n\u251c\u2500\u2500 Body\n\u2502   \u251c\u2500\u2500 Body_48x48_03.png\n\u2502   \u251c\u2500\u2500 Body_48x48_06.png\n\u2502   \u2514\u2500\u2500 Body_48x48_09.png\n\u251c\u2500\u2500 Hairstyle\n\u2502   \u251c\u2500\u2500 Hairstyle_01_48x48_01.png\n\u2502   \u251c\u2500\u2500 Hairstyle_01_48x48_05.png\n\u2502   \u251c\u2500\u2500 Hairstyle_24_48x48_01.png\n\u2502   \u251c\u2500\u2500 Hairstyle_28_48x48_01.png\n\u2502   \u2514\u2500\u2500 Hairstyle_28_48x48_04.png\n\u251c\u2500\u2500 Outfit\n\u2502   \u251c\u2500\u2500 Outfit_01_48x48_06.png\n\u2502   \u251c\u2500\u2500 Outfit_01_48x48_10.png\n\u2502   \u251c\u2500\u2500 Outfit_13_48x48_01.png\n\u2502   \u251c\u2500\u2500 Outfit_13_48x48_03.png\n\u2502   \u251c\u2500\u2500 Outfit_16_48x48_01.png\n\u2502   \u2514\u2500\u2500Outfit_16_48x48_03.png\n"})}),"\n",(0,t.jsx)(n.h4,{id:"batch-file-modular",children:"Batch File (Modular)"}),"\n",(0,t.jsxs)(n.p,{children:["Add this file into the path ",(0,t.jsx)(n.code,{children:"Assets/Editor"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="SpriteLibraryBatchAutoCreateSpriteAssetLibrary_Modular"',children:'using UnityEngine;\nusing UnityEditor;\nusing UnityEngine.U2D.Animation;\nusing System.IO;\n\npublic class SpriteLibraryBatchAutoCreateSpriteAssetLibrary_Modular\n{\n    // ------------------------------------------------------------------------\n    // USER PATH SETTINGS\n    // ------------------------------------------------------------------------\n\n    private const string BaseSpritesPath = "Assets/Resources";          // Where sprites are stored, e.g: Assets/Resources/Body, Assets/Resources/Hairstyle\n    private const string LibraryOutputPath = "Assets/Resources/SpriteLibraryAssets"; // Where to save generated libraries\n    private const string ConfigPath = "Assets/EditorConfig/SpriteLibraryRules.json"; // JSON config\n\n    // ------------------------------------------------------------------------\n\n    [System.Serializable]\n    public class StyleVariantPair\n    {\n        public string styleId;\n        public string variant;\n    }\n\n    [System.Serializable]\n    private class CategoryRule\n    {\n        public string category;\n        public bool hasStyleId;\n        public StyleVariantPair[] pairs;\n        public string[] variants;\n        public string dimFilter;\n        public string labelTemplate;\n        public int minFrame = -1;\n        public int maxFrame = -1;\n    }\n\n    private struct ParsedName\n    {\n        public string type;\n        public string styleId;\n        public string dim;\n        public string colorId;\n        public string frameId;\n    }\n\n    [MenuItem("Tools/Sprite Library/Generate All Libraries (Modular JSON Config)")]\n    public static void GenerateAll()\n    {\n        if (!File.Exists(ConfigPath))\n        {\n            Debug.LogError($"Config file not found: {ConfigPath}");\n            return;\n        }\n\n        var json = File.ReadAllText(ConfigPath);\n        var rules = JsonHelper.FromJson<CategoryRule>(json);\n\n        foreach (var rule in rules)\n        {\n            if (rule.hasStyleId && rule.pairs != null)\n            {\n                foreach (var pair in rule.pairs)\n                    FillLibraryFor(rule, pair.styleId, pair.variant);\n            }\n            else\n            {\n                foreach (var variant in rule.variants)\n                    FillLibraryFor(rule, null, variant);\n            }\n        }\n\n        AssetDatabase.SaveAssets();\n        Debug.Log("Finished generating all modular libraries.");\n    }\n\n    private static void FillLibraryFor(CategoryRule rule, string styleId, string targetVariant)\n    {\n        string suffix = styleId == null ? targetVariant : $"{styleId}_{targetVariant}";\n        string spritesPath = Path.Combine(BaseSpritesPath, rule.category);\n        string libraryPath = Path.Combine(LibraryOutputPath, $"{rule.category}SpriteLibrary_{suffix}.asset");\n\n        var library = AssetDatabase.LoadAssetAtPath<SpriteLibraryAsset>(libraryPath);\n        if (library == null)\n        {\n            library = ScriptableObject.CreateInstance<SpriteLibraryAsset>();\n            AssetDatabase.CreateAsset(library, libraryPath);\n        }\n\n        var allGuids = AssetDatabase.FindAssets("t:Sprite", new[] { spritesPath });\n        int added = 0;\n\n        foreach (var guid in allGuids)\n        {\n            string assetPath = AssetDatabase.GUIDToAssetPath(guid);\n            var assetsAtPath = AssetDatabase.LoadAllAssetsAtPath(assetPath);\n            Debug.Log($"[FillLibraryFor] Found sprite source: {assetPath}");\n\n            foreach (var obj in assetsAtPath)\n            {\n                if (obj is not Sprite s) continue;\n                if (!TryParse(s.name, rule.hasStyleId, out var parsed)) continue;\n                if (parsed.type != rule.category) continue;\n                if (!string.IsNullOrEmpty(rule.dimFilter) && parsed.dim != rule.dimFilter) continue;\n                if (parsed.colorId != targetVariant) continue;\n                if (styleId != null && parsed.styleId != styleId) continue;\n                if (!InFrameRange(rule, parsed.frameId)) continue;\n\n                string label = BuildLabel(rule.labelTemplate, parsed);\n\n                var existing = library.GetSprite(rule.category, label);\n                if (existing != null)\n                {\n                    try { library.RemoveCategoryLabel(rule.category, label, false); } catch { }\n                }\n\n                library.AddCategoryLabel(s, rule.category, label);\n                added++;\n            }\n        }\n\n        EditorUtility.SetDirty(library);\n        Debug.Log($"{added} sprites added to {libraryPath} for {rule.category} style {styleId ?? "-"} variant {targetVariant}");\n    }\n\n    private static bool InFrameRange(CategoryRule rule, string frameIdStr)\n    {\n        if (rule.minFrame < 0 && rule.maxFrame < 0) return true;\n        if (!int.TryParse(frameIdStr, out int frame)) return false;\n        if (rule.minFrame >= 0 && frame < rule.minFrame) return false;\n        if (rule.maxFrame >= 0 && frame > rule.maxFrame) return false;\n        return true;\n    }\n\n    private static string BuildLabel(string template, ParsedName p)\n    {\n        return template\n            .Replace("{Category}", p.type)\n            .Replace("{StyleId}", p.styleId ?? "")\n            .Replace("{Dim}", p.dim)\n            .Replace("{Variant}", p.colorId)\n            .Replace("{Slice}", p.frameId);\n    }\n\n    private static bool TryParse(string spriteName, bool hasStyleId, out ParsedName p)\n    {\n        p = default;\n        var parts = spriteName.Split(\'_\');\n        if (hasStyleId)\n        {\n            if (parts.Length < 5) return false;\n            p.type = parts[0];\n            p.styleId = parts[1];\n            p.dim = parts[2];\n            p.colorId = parts[3];\n            p.frameId = parts[4];\n            return true;\n        }\n        else\n        {\n            if (parts.Length < 4) return false;\n            p.type = parts[0];\n            p.styleId = null;\n            p.dim = parts[1];\n            p.colorId = parts[2];\n            p.frameId = parts[3];\n            return true;\n        }\n    }\n\n    public static class JsonHelper\n    {\n        public static T[] FromJson<T>(string json)\n        {\n            string wrapped = "{\\"Items\\":" + json + "}";\n            Wrapper<T> wrapper = JsonUtility.FromJson<Wrapper<T>>(wrapped);\n            return wrapper.Items;\n        }\n\n        [System.Serializable]\n        private class Wrapper<T>\n        {\n            public T[] Items;\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Then go to Tools >> Sprite Library >> Generate All Libraries (Modular JSON Config). Wait for awhile, your computer might hang for a bit. This will create 14 libraries under ",(0,t.jsx)(n.code,{children:"Assets/SpriteLibraryAssets"})," if the ",(0,t.jsx)(n.a,{href:"#json-example",children:"JSON example above"})," is used:"]}),"\n",(0,t.jsx)(a.A,{path:r(56278).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h4,{id:"batch-file-monolithic",children:"Batch File (Monolithic)"}),"\n",(0,t.jsxs)(n.p,{children:["Add this file into the path ",(0,t.jsx)(n.code,{children:"Assets/Editor"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",metastring:'title="SpriteLibraryBatchAutoCreateSpriteAssetLibrary_Monolithic"',children:'using UnityEngine;\nusing UnityEditor;\nusing UnityEngine.U2D.Animation;\nusing System.IO;\nusing System.Collections.Generic;\n\n// Generates one SpriteLibraryAsset per full character combo across all categories.\n// Uses pairs for categories with styleId.\npublic class SpriteLibraryBatchAutoCreateSpriteAssetLibrary_Monolithic\n{\n    // ------------------------------------------------------------------------\n    // USER PATH SETTINGS\n    // ------------------------------------------------------------------------\n\n    private const string BaseSpritesPath = "Assets/Resources";          // Where sprites are stored, e.g: Assets/Resources/Body, Assets/Resources/Hairstyle\n    private const string LibraryOutputPath = "Assets/Resources/SpriteLibraryAssets"; // Where to save generated libraries\n    private const string ConfigPath = "Assets/EditorConfig/SpriteLibraryRules.json"; // JSON config\n\n    // ------------------------------------------------------------------------\n\n    [System.Serializable]\n    public class StyleVariantPair\n    {\n        public string styleId;\n        public string variant;\n    }\n\n    [System.Serializable]\n    private class CategoryRule\n    {\n        public string category;\n        public bool hasStyleId;\n        public StyleVariantPair[] pairs;\n        public string[] variants;\n        public string dimFilter;\n        public string labelTemplate;\n        public int minFrame = -1;\n        public int maxFrame = -1;\n    }\n\n    private struct ParsedName\n    {\n        public string type;\n        public string styleId;\n        public string dim;\n        public string colorId;\n        public string frameId;\n    }\n\n    [MenuItem("Tools/Sprite Library/Generate All Libraries (Monolithic JSON Config)")]\n    public static void GenerateAll()\n    {\n        if (!File.Exists(ConfigPath))\n        {\n            Debug.LogError($"Config file not found: {ConfigPath}");\n            return;\n        }\n\n        var json = File.ReadAllText(ConfigPath);\n        var rules = JsonHelper.FromJson<CategoryRule>(json);\n\n        GenerateCombinations(rules, new Dictionary<string, (string styleId, string variant)>(), 0);\n\n        AssetDatabase.SaveAssets();\n        Debug.Log("Finished generating all monolithic libraries.");\n    }\n\n    private static void GenerateCombinations(CategoryRule[] rules,\n        Dictionary<string, (string styleId, string variant)> chosen, int depth)\n    {\n        if (depth == rules.Length)\n        {\n            BuildLibrary(rules, chosen);\n            return;\n        }\n\n        var rule = rules[depth];\n\n        if (rule.hasStyleId && rule.pairs != null)\n        {\n            foreach (var pair in rule.pairs)\n            {\n                chosen[rule.category] = (pair.styleId, pair.variant);\n                GenerateCombinations(rules, chosen, depth + 1);\n            }\n        }\n        else\n        {\n            foreach (var variant in rule.variants)\n            {\n                chosen[rule.category] = (null, variant);\n                GenerateCombinations(rules, chosen, depth + 1);\n            }\n        }\n    }\n\n    private static void BuildLibrary(CategoryRule[] rules,\n        Dictionary<string, (string styleId, string variant)> chosen)\n    {\n        string comboName = "Character";\n        foreach (var kv in chosen)\n        {\n            string stylePart = kv.Value.styleId != null ? kv.Value.styleId : "";\n            comboName += $"_{kv.Key}{stylePart}{kv.Value.variant}";\n        }\n\n        string libraryPath = Path.Combine(LibraryOutputPath, $"{comboName}.asset");\n\n        var library = AssetDatabase.LoadAssetAtPath<SpriteLibraryAsset>(libraryPath);\n        if (library == null)\n        {\n            library = ScriptableObject.CreateInstance<SpriteLibraryAsset>();\n            AssetDatabase.CreateAsset(library, libraryPath);\n        }\n\n        int totalAdded = 0;\n\n        foreach (var rule in rules)\n        {\n            var choice = chosen[rule.category];\n            string spritesPath = Path.Combine(BaseSpritesPath, rule.category);\n            var allGuids = AssetDatabase.FindAssets("t:Sprite", new[] { spritesPath });\n\n            foreach (var guid in allGuids)\n            {\n                string assetPath = AssetDatabase.GUIDToAssetPath(guid);\n                var assetsAtPath = AssetDatabase.LoadAllAssetsAtPath(assetPath);\n\n                foreach (var obj in assetsAtPath)\n                {\n                    if (obj is not Sprite s) continue;\n                    if (!TryParse(s.name, rule.hasStyleId, out var parsed)) continue;\n                    if (parsed.type != rule.category) continue;\n                    if (!string.IsNullOrEmpty(rule.dimFilter) && parsed.dim != rule.dimFilter) continue;\n                    if (parsed.colorId != choice.variant) continue;\n                    if (choice.styleId != null && parsed.styleId != choice.styleId) continue;\n                    if (!InFrameRange(rule, parsed.frameId)) continue;\n\n                    string label = BuildLabel(rule.labelTemplate, parsed);\n\n                    var existing = library.GetSprite(rule.category, label);\n                    if (existing != null)\n                    {\n                        try { library.RemoveCategoryLabel(rule.category, label, false); } catch { }\n                    }\n\n                    library.AddCategoryLabel(s, rule.category, label);\n                    totalAdded++;\n                }\n            }\n        }\n\n        EditorUtility.SetDirty(library);\n        Debug.Log($"{comboName}: {totalAdded} sprites added.");\n    }\n\n    private static bool InFrameRange(CategoryRule rule, string frameIdStr)\n    {\n        if (rule.minFrame < 0 && rule.maxFrame < 0) return true;\n        if (!int.TryParse(frameIdStr, out int frame)) return false;\n        if (rule.minFrame >= 0 && frame < rule.minFrame) return false;\n        if (rule.maxFrame >= 0 && frame > rule.maxFrame) return false;\n        return true;\n    }\n\n    private static string BuildLabel(string template, ParsedName p)\n    {\n        return template\n            .Replace("{Category}", p.type)\n            .Replace("{StyleId}", p.styleId ?? "")\n            .Replace("{Dim}", p.dim)\n            .Replace("{Variant}", p.colorId)\n            .Replace("{Slice}", p.frameId);\n    }\n\n    private static bool TryParse(string spriteName, bool hasStyleId, out ParsedName p)\n    {\n        p = default;\n        var parts = spriteName.Split(\'_\');\n        if (hasStyleId)\n        {\n            if (parts.Length < 5) return false;\n            p.type = parts[0];\n            p.styleId = parts[1];\n            p.dim = parts[2];\n            p.colorId = parts[3];\n            p.frameId = parts[4];\n            return true;\n        }\n        else\n        {\n            if (parts.Length < 4) return false;\n            p.type = parts[0];\n            p.styleId = null;\n            p.dim = parts[1];\n            p.colorId = parts[2];\n            p.frameId = parts[3];\n            return true;\n        }\n    }\n\n    public static class JsonHelper\n    {\n        public static T[] FromJson<T>(string json)\n        {\n            string wrapped = "{\\"Items\\":" + json + "}";\n            Wrapper<T> wrapper = JsonUtility.FromJson<Wrapper<T>>(wrapped);\n            return wrapper.Items;\n        }\n\n        [System.Serializable]\n        private class Wrapper<T>\n        {\n            public T[] Items;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Since we are generating all combinations, let's use a smaller JSON config as demo:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "category": "Body",\n    "hasStyleId": false,\n    "variants": ["03", "06"],\n    "dimFilter": "48x48",\n    "labelTemplate": "walk_{Slice}",\n    "minFrame": 114,\n    "maxFrame": 137\n  },\n  {\n    "category": "Hairstyle",\n    "hasStyleId": true,\n    "pairs": [\n      { "styleId": "01", "variant": "01" },\n      { "styleId": "01", "variant": "05" }\n    ],\n    "dimFilter": "48x48",\n    "labelTemplate": "walk_{Slice}",\n    "minFrame": 112,\n    "maxFrame": 135\n  },\n  {\n    "category": "Outfit",\n    "hasStyleId": true,\n    "pairs": [{ "styleId": "01", "variant": "06" }],\n    "dimFilter": "48x48",\n    "labelTemplate": "{StyleId}_{Slice}",\n    "minFrame": 112,\n    "maxFrame": 135\n  }\n]\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Then go to Tools >> Sprite Library >> Generate All Libraries (Monolithic JSON Config). Wait for awhile, your computer might hang for a bit. This will create 4 libraries under ",(0,t.jsx)(n.code,{children:"Assets/SpriteLibraryAssets"})," if the JSON example above is used:"]}),"\n",(0,t.jsx)(a.A,{path:r(96117).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h2,{id:"workflow-details",children:"Workflow Details"}),"\n",(0,t.jsx)(n.h3,{id:"monolithic-workflow-one-library-per-full-character",children:"Monolithic Workflow (One Library Per Full Character)"}),"\n",(0,t.jsx)(n.p,{children:"You should have pre-baked SpriteAssetLibrary for each combination of sprites as follows:"}),"\n",(0,t.jsx)(a.A,{path:r(64866).A,widthPercentage:"100%"}),"\n",(0,t.jsxs)(n.p,{children:["Then, create a gameobject with this structure, where Root contains an Animator + SpriteAssetLibrary and the child Object contains Renderer + Resolver ",(0,t.jsx)("span",{class:"orange-bold",children:"each"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mathematica",children:'PlayerCharacter (Root)\n \u251c\u2500\u2500 Components on Root:\n \u2502    \u2022 Animator\n \u2502    \u2022 SpriteLibrary (Assign CharacterX.asset here)\n \u2502\n \u251c\u2500\u2500 Body (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteResolver (Category = "Body")\n \u2502\n \u251c\u2500\u2500 Hair (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteResolver (Category = "Hairstyle")\n \u2502\n \u2514\u2500\u2500 Outfit (Child GameObject)\n      \u2022 SpriteRenderer\n      \u2022 SpriteResolver (Category = "Outfit")\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The children SpriteResolver all points to the ",(0,t.jsx)(n.strong,{children:"same"})," library at Root."]})}),"\n",(0,t.jsxs)(n.p,{children:["You can set an initial sprite to show in the ",(0,t.jsx)(n.code,{children:"SpriteResolver"})," Inspector window for each object, as such so you can visualise the character:"]}),"\n",(0,t.jsx)(a.A,{path:r(13620).A,widthPercentage:"100%"}),"\n",(0,t.jsxs)(n.p,{children:["Afterwards, create animation clips and record as usual, but this time around record the changing of sprites by ",(0,t.jsx)(n.strong,{children:"clicking the sprites in the SpriteResolver"})," of each child GameObject. This gif shows the process to create one animation clip:"]}),"\n",(0,t.jsx)(a.A,{path:r(35330).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["The dopesheet should record ",(0,t.jsx)(n.em,{children:"Sprite Hash"})," in your sprite resolver instead of sprite address. This way, your animator creates key frame based on the Sprite Hash in the Sprite Library, and does not reference the sprite itself."]})}),"\n",(0,t.jsx)(n.h4,{id:"test-swap-at-runtime",children:"Test Swap at Runtime"}),"\n",(0,t.jsx)(n.p,{children:"Attach the following script to your Root GameObject:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We use ",(0,t.jsx)(n.code,{children:"InspectorButton"})," attribute from ",(0,t.jsx)(n.a,{href:"/resources/general/helper-buttons",children:"this"})," tutorial so that we can run those functions using buttons in the Inspector"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing UnityEngine.U2D.Animation;\nusing Game.DebugTools;\n\npublic class CharacterSkinSwitcherMonolithic : MonoBehaviour\n{\n    [SerializeField] private SpriteLibrary spriteLibrary;   // attach root SpriteLibrary\n    [SerializeField] private SpriteLibraryAsset[] skins;    // drag in all monolithic assets\n\n    private int currentIndex = 0;\n    [InspectorButton]\n    public void NextSkin()\n    {\n        currentIndex = (currentIndex + 1) % skins.Length;\n        spriteLibrary.spriteLibraryAsset = skins[currentIndex];\n        Debug.Log($"Swapped to monolithic skin: {skins[currentIndex].name}");\n    }\n    [InspectorButton]\n    public void SetSkin(int index)\n    {\n        if (index < 0 || index >= skins.Length) return;\n        spriteLibrary.spriteLibraryAsset = skins[index];\n        currentIndex = index;\n        Debug.Log($"Set monolithic skin: {skins[index].name}");\n    }\n}\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then load all skin assets you have created before. During runtime, you should see that they are easily swapped and the animation works seamlessly:"}),"\n",(0,t.jsx)(a.A,{path:r(5560).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h3,{id:"modular-workflow-one-library-per-type-of-sprite",children:"Modular Workflow (One Library Per Type of Sprite)"}),"\n",(0,t.jsx)(n.p,{children:"You should have pre-baked library for each type of sprites as follows:"}),"\n",(0,t.jsx)(a.A,{path:r(34661).A,widthPercentage:"100%"}),"\n",(0,t.jsxs)(n.p,{children:["Then, create a gameobject with this structure, where Root contains an Animator and the child Object contains Renderer + Resolver + Library ",(0,t.jsx)("span",{class:"orange-bold",children:"each"}),". This is unlike the Monolithic structure where there's only one Library at the Root:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mathematica",children:'PlayerCharacter (Root)\n \u251c\u2500\u2500 Components on Root:\n \u2502    \u2022 Animator\n \u2502\n \u251c\u2500\u2500 Body (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteLibrary (assign Body_X.asset or similar)\n \u2502    \u2022 SpriteResolver (Category = "Body")\n \u2502\n \u251c\u2500\u2500 Hair (Child GameObject)\n \u2502    \u2022 SpriteRenderer\n \u2502    \u2022 SpriteLibrary (assign Hairstyle_X.asset or similar)\n \u2502    \u2022 SpriteResolver (Category = "Hairstyle")\n \u2502\n \u2514\u2500\u2500 Outfit (Child GameObject)\n      \u2022 SpriteRenderer\n      \u2022 SpriteLibrary (assign Outfit_X.asset or similar)\n      \u2022 SpriteResolver (Category = "Outfit")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then record the animation clips as usual by changing the Sprite Resolver sprites on each child object:"}),"\n",(0,t.jsx)(a.A,{path:r(7039).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(a.A,{path:r(69882).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["Likewise, the dopesheet should record ",(0,t.jsx)(n.em,{children:"Sprite Hash"})," in your sprite resolver instead of sprite address. This way, your animator creates key frame based on the Sprite Hash in the Sprite Library, and does not reference the sprite itself."]})}),"\n",(0,t.jsx)(n.h4,{id:"test-swap-at-runtime-1",children:"Test Swap at Runtime"}),"\n",(0,t.jsx)(n.p,{children:"Attach the following script to your root gameobject:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We use ",(0,t.jsx)(n.code,{children:"InspectorButton"})," attribute from ",(0,t.jsx)(n.a,{href:"/resources/general/helper-buttons",children:"this"})," tutorial so that we can run those functions using buttons in the Inspector"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cs",children:'using UnityEngine;\nusing UnityEngine.U2D.Animation;\nusing Game.DebugTools;\n\npublic class CharacterSkinSwitcherModular : MonoBehaviour\n{\n    [Header("Sprite Libraries (assign child SpriteLibrary components)")]\n    [SerializeField] private SpriteLibrary bodyLibrary;\n    [SerializeField] private SpriteLibrary hairLibrary;\n    [SerializeField] private SpriteLibrary outfitLibrary;\n\n    [Header("Available Assets")]\n    [SerializeField] private SpriteLibraryAsset[] bodySkins;\n    [SerializeField] private SpriteLibraryAsset[] hairSkins;\n    [SerializeField] private SpriteLibraryAsset[] outfitSkins;\n\n    private int bodyIndex = 0;\n    private int hairIndex = 0;\n    private int outfitIndex = 0;\n\n    [InspectorButton]\n    public void NextBody()\n    {\n        if (bodySkins == null || bodySkins.Length == 0) return;\n        bodyIndex = (bodyIndex + 1) % bodySkins.Length;\n        bodyLibrary.spriteLibraryAsset = bodySkins[bodyIndex];\n        Debug.Log($"Swapped Body: {bodySkins[bodyIndex].name}");\n    }\n\n    [InspectorButton]\n    public void NextHair()\n    {\n        if (hairSkins == null || hairSkins.Length == 0) return;\n        hairIndex = (hairIndex + 1) % hairSkins.Length;\n        hairLibrary.spriteLibraryAsset = hairSkins[hairIndex];\n        Debug.Log($"Swapped Hair: {hairSkins[hairIndex].name}");\n    }\n\n    [InspectorButton]\n    public void NextOutfit()\n    {\n        if (outfitSkins == null || outfitSkins.Length == 0) return;\n        outfitIndex = (outfitIndex + 1) % outfitSkins.Length;\n        outfitLibrary.spriteLibraryAsset = outfitSkins[outfitIndex];\n        Debug.Log($"Swapped Outfit: {outfitSkins[outfitIndex].name}");\n    }\n\n    [InspectorButton]\n    public void SetBody(int index)\n    {\n        if (index < 0 || index >= bodySkins.Length) return;\n        bodyLibrary.spriteLibraryAsset = bodySkins[index];\n        bodyIndex = index;\n        Debug.Log($"Set Body: {bodySkins[index].name}");\n    }\n\n    [InspectorButton]\n    public void SetHair(int index)\n    {\n        if (index < 0 || index >= hairSkins.Length) return;\n        hairLibrary.spriteLibraryAsset = hairSkins[index];\n        hairIndex = index;\n        Debug.Log($"Set Hair: {hairSkins[index].name}");\n    }\n\n    [InspectorButton]\n    public void SetOutfit(int index)\n    {\n        if (index < 0 || index >= outfitSkins.Length) return;\n        outfitLibrary.spriteLibraryAsset = outfitSkins[index];\n        outfitIndex = index;\n        Debug.Log($"Set Outfit: {outfitSkins[index].name}");\n    }\n}\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then load all the modular skin assets you have created before. During runtime, you should see that they are easily swapped and the animation works seamlessly:"}),"\n",(0,t.jsx)(a.A,{path:r(76865).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.p,{children:"Here's a gif of the test script in action:"}),"\n",(0,t.jsx)(a.A,{path:r(51981).A,widthPercentage:"100%"}),"\n",(0,t.jsx)(n.h2,{id:"which-workflow-should-i-use",children:"Which Workflow Should I Use?"}),"\n",(0,t.jsxs)(n.p,{children:["Pick ",(0,t.jsx)("span",{class:"orange-bold",children:"Modular"})," if:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You need ",(0,t.jsx)(n.strong,{children:"customization"}),": players can pick any Body + Hairstyle + Outfit combination"]}),"\n",(0,t.jsxs)(n.li,{children:["You want to ",(0,t.jsx)(n.strong,{children:"add new parts later"})," (new haircuts, costumes) without re-authoring old assets"]}),"\n",(0,t.jsxs)(n.li,{children:["You want to ",(0,t.jsx)(n.strong,{children:"reuse Animator clips"})," across many characters"]}),"\n",(0,t.jsxs)(n.li,{children:["You care about ",(0,t.jsx)(n.strong,{children:"keeping library asset count low"})," (no combinatorial explosion)"]}),"\n",(0,t.jsxs)(n.li,{children:["You\u2019re okay with each character GameObject having multiple ",(0,t.jsx)(n.code,{children:"SpriteResolver"}),"s (one per part)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Best when:"})," you want ",(0,t.jsx)(n.em,{children:"prefab-per-character"}),", few total variants, and cheap swaps"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost"}),": large asset count if you support mix-and-match"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Pick ",(0,t.jsx)("span",{class:"orange-bold",children:"Monolithic"})," if:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You only need a ",(0,t.jsx)(n.strong,{children:"small set of predefined full skins"})]}),"\n",(0,t.jsxs)(n.li,{children:["Your game\u2019s characters are ",(0,t.jsx)(n.strong,{children:"fixed"})," (e.g. fighting game roster, boss enemies)"]}),"\n",(0,t.jsxs)(n.li,{children:["You want the ",(0,t.jsx)(n.strong,{children:"simplest runtime swapping"})," (just one asset per character)"]}),"\n",(0,t.jsxs)(n.li,{children:["You prefer a ",(0,t.jsx)(n.strong,{children:"minimal hierarchy"})," (only one ",(0,t.jsx)(n.code,{children:"SpriteResolver"})," on the root)"]}),"\n",(0,t.jsx)(n.li,{children:"You don\u2019t expect to mix & match Body/Hair/Outfit at runtime"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Best when:"})," you want a customization system (mix-and-match parts)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost"}),": 2\u20133x as many lookups per frame compared to monolithic, but still ",(0,t.jsx)(n.em,{children:"negligible"})," in real games"]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rule of thumb"}),":"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If your design doc says \u201cplayer can choose hair, outfit, etc.\u201d: choose ",(0,t.jsx)(n.strong,{children:"Modular"})]}),"\n",(0,t.jsxs)(n.li,{children:["If it says \u201cthis NPC has one skin, and we\u2019ll maybe have 3 alternate costumes\u201d: choose ",(0,t.jsx)(n.strong,{children:"Monolithic"})]}),"\n"]})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},2258:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-10-10-48-286016b4763cdcc9cd03eb16c968beb0.png"},46439:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-10-12-07-ff257a7167452d89bc47a580dd700270.png"},77774:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-10-13-30-9ecc53e0c1b46e0ac8625d60c8c6b352.png"},13651:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-10-31-57-26933f107763dbbaf8fc4b882ccfb004.png"},68321:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-10-33-44-e4924fd124589d1dca28da2e4d7d13b0.png"},66071:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-16-25-18-96a659db201537a0d6c5e8acca92064e.png"},23978:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-16-41-08-ff9550481fe5aa2ee1a10f7aef1b0efe.png"},56278:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-17-07-10-5423d841f0da091c5bc632be7f56cdef.png"},96117:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-09-30-18-02-53-72272474c4ffe9823d4b53e3a41c43d7.png"},64866:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-08-34-18-c421e6cb07882576fd6ebf5a17de5318.png"},13620:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-08-38-38-b1b2c9e8911ae13c2ece588ae0f47abc.png"},90003:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-08-46-58-82cd5edf1fb4c2b78650bce9685a2806.png"},37519:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-08-48-52-82cd5edf1fb4c2b78650bce9685a2806.png"},34661:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-08-58-11-a6c15097772ab35625fd0d30b6bb78bd.png"},7039:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-09-07-41-ab5203fd0c7d8f5a03a188bcadae1eed.png"},69882:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-09-07-53-7855878678287556e00851d2b41aedbf.png"},76865:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/2025-10-01-09-14-29-feae6c3c5e2c80f353df448d4acc17bb.png"},35330:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/spritelib-mono-anim-create-73185897e9fe3c044b8716fc1fb42095.gif"},51981:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/swap-modular-46fbc5ddbdb45d85abbc29a21b7bfd30.gif"},5560:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/swap-mono-ea86760cf2b9f4f5d197fcaaabcd0d49.gif"}}]);